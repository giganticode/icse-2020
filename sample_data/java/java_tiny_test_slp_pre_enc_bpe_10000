<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . dem@@ o ; import java . io . BufferedReader ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Cl@@ ar@@ a ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . Layout@@ In@@ fl@@ ater@@ Exception ; import com . vaadin . Application ; import com . vaadin . termin@@ al . Th@@ em@@ e@@ Resource ; import com . vaadin . ui . Button ; import com . vaadin . ui . Button . Click@@ Event ; import com . vaadin . ui . Component ; import com . vaadin . ui . Embed@@ ded ; import com . vaadin . ui . Horizontal@@ Layout ; import com . vaadin . ui . Horizontal@@ Split@@ Panel ; import com . vaadin . ui . TextArea ; import com . vaadin . ui . Vertical@@ Layout ; import com . vaadin . ui . Window ; import com . vaadin . ui . Window . Notification ; @ SuppressWarnings ( "@@ serial@@ " ) public class Demo@@ Application extends Application { private Demo@@ Controller controller ; private TextArea xml@@ Area ; private Horizontal@@ Split@@ Panel split = new Horizontal@@ Split@@ Panel ( ) ; private Window main@@ Window ; @ Override public void init ( ) { set@@ Th@@ eme ( "@@ cl@@ ar@@ a" ) ; set@@ Main@@ Window ( main@@ Window = new Window ( ) ) ; controller = new Demo@@ Controller ( main@@ Window ) ; main@@ Window . set@@ Content ( split ) ; Vertical@@ Layout editor = new Vertical@@ Layout ( ) ; editor . set@@ Spac@@ ing ( true ) ; editor . set@@ Margin ( false , false , false , true ) ; editor . set@@ Height ( "100@@ %@@ " ) ; editor . addComponent ( xml@@ Area = create@@ Xml@@ Area ( ) ) ; editor . set@@ Expand@@ Ratio ( xml@@ Area , 1.0f ) ; editor . addComponent ( create@@ Update@@ Button ( ) ) ; Horizontal@@ Layout wrapper = new Horizontal@@ Layout ( ) ; wrapper . set@@ Margin ( true ) ; wrapper . set@@ Size@@ F@@ ull ( ) ; wrapper . addComponent ( create@@ Log@@ o ( ) ) ; wrapper . addComponent ( editor ) ; wrapper . set@@ Expand@@ Ratio ( editor , 1.0f ) ; split . set@@ First@@ Component ( wrapper ) ; update@@ Layout ( ) ; } private Component create@@ Log@@ o ( ) { Embed@@ ded log@@ o = new Embed@@ ded ( null , new Th@@ em@@ e@@ Resource ( "" ) ) ; log@@ o . set@@ Height ( "@@ 9@@ 0@@ p@@ x" ) ; log@@ o . setWidth ( "@@ 9@@ 0@@ p@@ x" ) ; return log@@ o ; } private TextArea create@@ Xml@@ Area ( ) { TextArea area = new TextArea ( ) ; area . set@@ StyleName ( "@@ xml@@ -@@ area@@ " ) ; area . set@@ Size@@ F@@ ull ( ) ; area . setValue ( read@@ Start@@ ing@@ Point ( ) ) ; return area ; } private Button create@@ Update@@ Button ( ) { return new Button ( "@@ Update@@ " , new Button . ClickListener ( ) { public void button@@ Click ( Click@@ Event event ) { update@@ Layout ( ) ; } } ) ; } private String read@@ Start@@ ing@@ Point ( ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( getClass ( ) . getClassLoader ( ) . getResourceAsStream ( "" ) ) ) ; StringBuilder xml = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { xml . append ( line ) ; xml . append ( "n" ) ; } return xml . toString ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return null ; } private void update@@ Layout ( ) { try { Component c = Cl@@ ar@@ a . create ( new ByteArrayInputStream ( xml@@ Area . getValue ( ) . toString ( ) . getBytes ( ) ) , controller ) ; split . replace@@ Component ( split . getSec@@ ond@@ Component ( ) , c ) ; } catch ( Layout@@ In@@ fl@@ ater@@ Exception e ) { main@@ Window . show@@ Notification ( e . getMessage ( ) , Notification . TYPE_@@ ERROR_@@ MESSAGE ) ; } } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . dem@@ o ; import java . util . Date ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . DataSource ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . EventHandler ; import com . vaadin . data . Container ; import com . vaadin . data . Property ; import com . vaadin . data . Property . Value@@ ChangeEvent ; import com . vaadin . data . util . Indexed@@ Container ; import com . vaadin . data . util . Object@@ Property ; import com . vaadin . ui . Button . Click@@ Event ; import com . vaadin . ui . Window ; public class Demo@@ Controller { private Window window ; public Demo@@ Controller ( Window window ) { this . window = window ; } @ DataSource ( "@@ date@@ " ) public Property get@@ Date@@ Property ( ) { return new Object@@ Property < Date > ( new Date ( ) ) ; } @ DataSource ( "@@ person@@ -@@ list@@ " ) public Container get@@ Person@@ Container ( ) { Indexed@@ Container container = new Indexed@@ Container ( ) ; container . add@@ Container@@ Property ( "@@ Name" , String . class , "" ) ; container . add@@ Container@@ Property ( "A@@ ge@@ " , Integer . class , 0 ) ; Object item@@ Id = container . add@@ Item ( ) ; container . getItem ( item@@ Id ) . getItem@@ Property ( "@@ Name" ) . setValue ( "" ) ; container . getItem ( item@@ Id ) . getItem@@ Property ( "A@@ ge@@ " ) . setValue ( 32 ) ; item@@ Id = container . add@@ Item ( ) ; container . getItem ( item@@ Id ) . getItem@@ Property ( "@@ Name" ) . setValue ( "J@@ oh@@ n Sm@@ ith@@ " ) ; container . getItem ( item@@ Id ) . getItem@@ Property ( "A@@ ge@@ " ) . setValue ( 35 ) ; return container ; } @ EventHandler ( "@@ button@@ " ) public void handle@@ Button@@ Click ( Click@@ Event event ) { window . show@@ Notification ( "" ) ; } @ EventHandler ( "" ) public void handle@@ An@@ other@@ Button@@ Click ( Click@@ Event event ) { window . show@@ Notification ( "" ) ; } @ EventHandler ( "value@@ -@@ field@@ " ) public void s@@ ome@@ Value@@ Changed ( Value@@ ChangeEvent event ) { window . show@@ Notification ( "" + event . getProperty ( ) . getValue ( ) ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import org . junit . Before ; import org . junit . Test ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . Primitive@@ Attribute@@ Parser ; public class Primitive@@ Attribute@@ Parser@@ Test { private Primitive@@ Attribute@@ Parser handler ; @ Before public void setUp ( ) { handler = new Primitive@@ Attribute@@ Parser ( ) ; } @ Test public void test@@ Boolean ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Boolean . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Boolean . class ) ) ; assertEquals ( true , handler . getValue@@ A@@ s ( "true" , Boolean . TYPE ) ) ; assertEquals ( false , handler . getValue@@ A@@ s ( "false" , Boolean . TYPE ) ) ; assertEquals ( true , handler . getValue@@ A@@ s ( "true" , Boolean . class ) ) ; assertEquals ( false , handler . getValue@@ A@@ s ( "false" , Boolean . class ) ) ; } @ Test public void test@@ Integer ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Integer . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Integer . class ) ) ; assertEquals ( 10 , handler . getValue@@ A@@ s ( "@@ 10" , Integer . TYPE ) ) ; assertEquals ( - 10 , handler . getValue@@ A@@ s ( "-@@ 10" , Integer . TYPE ) ) ; assertEquals ( 20 , handler . getValue@@ A@@ s ( "@@ 20@@ " , Integer . class ) ) ; assertEquals ( - 20 , handler . getValue@@ A@@ s ( "-@@ 20@@ " , Integer . class ) ) ; } @ Test public void test@@ Byte ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Byte . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Byte . class ) ) ; assertEquals ( ( byte ) 10 , handler . getValue@@ A@@ s ( "@@ 10" , Byte . TYPE ) ) ; assertEquals ( ( byte ) - 10 , handler . getValue@@ A@@ s ( "-@@ 10" , Byte . TYPE ) ) ; assertEquals ( ( byte ) 20 , handler . getValue@@ A@@ s ( "@@ 20@@ " , Byte . class ) ) ; assertEquals ( ( byte ) - 20 , handler . getValue@@ A@@ s ( "-@@ 20@@ " , Byte . class ) ) ; } @ Test public void test@@ Short ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Short . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Short . class ) ) ; assertEquals ( ( short ) 10 , handler . getValue@@ A@@ s ( "@@ 10" , Short . TYPE ) ) ; assertEquals ( ( short ) - 10 , handler . getValue@@ A@@ s ( "-@@ 10" , Short . TYPE ) ) ; assertEquals ( ( short ) 20 , handler . getValue@@ A@@ s ( "@@ 20@@ " , Short . class ) ) ; assertEquals ( ( short ) - 20 , handler . getValue@@ A@@ s ( "-@@ 20@@ " , Short . class ) ) ; } @ Test public void test@@ Long ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Long . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Long . class ) ) ; assertEquals ( ( long ) 10 , handler . getValue@@ A@@ s ( "@@ 10" , Long . TYPE ) ) ; assertEquals ( ( long ) - 10 , handler . getValue@@ A@@ s ( "-@@ 10" , Long . TYPE ) ) ; assertEquals ( ( long ) 20 , handler . getValue@@ A@@ s ( "@@ 20@@ " , Long . class ) ) ; assertEquals ( ( long ) - 20 , handler . getValue@@ A@@ s ( "-@@ 20@@ " , Long . class ) ) ; } @ Test public void test@@ Character ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Character . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Character . class ) ) ; assertEquals ( 'a' , handler . getValue@@ A@@ s ( "a" , Character . TYPE ) ) ; assertEquals ( '@@ b@@ ' , handler . getValue@@ A@@ s ( "b" , Character . class ) ) ; } @ Test public void test@@ Float ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Float . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Float . class ) ) ; assertEquals ( 1.0f , handler . getValue@@ A@@ s ( "@@ 1.@@ 0" , Float . TYPE ) ) ; assertEquals ( 1.0f , handler . getValue@@ A@@ s ( "@@ 1.@@ 0" , Float . class ) ) ; } @ Test public void test@@ Double ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Double . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Double . class ) ) ; assertEquals ( 2.0@@ d , handler . getValue@@ A@@ s ( "@@ 2.0@@ " , Double . TYPE ) ) ; assertEquals ( 2.0@@ d , handler . getValue@@ A@@ s ( "@@ 2.0@@ " , Double . class ) ) ; } @ Test public void test@@ String ( ) throws Exception { assertTrue ( handler . is@@ Supported ( String . class ) ) ; assertEquals ( "@@ Hel@@ l@@ o world@@ !" , handler . getValue@@ A@@ s ( "@@ Hel@@ l@@ o world@@ !" , String . class ) ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . util ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import org . junit . Test ; import com . vaadin . ui . Button ; public class Reflection@@ Util@@ s@@ Test { public static class Class@@ To@@ Ex@@ am@@ ine { public void set@@ Foo@@ Bar ( ) { } public void set@@ Foo@@ Bar ( String foo ) { } public void set@@ Foo@@ Bar ( int foo ) { } public void set@@ Foo@@ Bar ( String foo , int bar ) { } } @ Test public void test_@@ get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( ) { assertEquals ( 1 , Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class@@ To@@ Ex@@ am@@ ine . class , "@@ set@@ Foo@@ Bar@@ " , 0 ) . size ( ) ) ; assertEquals ( 2 , Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class@@ To@@ Ex@@ am@@ ine . class , "@@ set@@ Foo@@ Bar@@ " , 1 ) . size ( ) ) ; assertEquals ( 1 , Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class@@ To@@ Ex@@ am@@ ine . class , "@@ set@@ Foo@@ Bar@@ " , 2 ) . size ( ) ) ; assertEquals ( 0 , Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class@@ To@@ Ex@@ am@@ ine . class , "@@ set@@ Foo@@ Bar@@ " , 3 ) . size ( ) ) ; assertEquals ( 0 , Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class@@ To@@ Ex@@ am@@ ine . class , "" , 1 ) . size ( ) ) ; } @ Test public void test_@@ is@@ Component ( ) { assertTrue ( Reflection@@ Utils . is@@ Component ( Button . class ) ) ; assertFalse ( Reflection@@ Utils . is@@ Component ( Class@@ To@@ Ex@@ am@@ ine . class ) ) ; assertFalse ( Reflection@@ Utils . is@@ Component ( null ) ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import org . junit . Before ; import org . junit . Test ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . LayoutInflater ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . Layout@@ In@@ fl@@ ater@@ Exception ; import com . vaadin . ui . Button ; import com . vaadin . ui . Component ; import com . vaadin . ui . Vertical@@ Layout ; public class Layout@@ In@@ fl@@ ater@@ Test { private LayoutInflater in@@ flater ; @ Before public void setUp ( ) { in@@ flater = new LayoutInflater ( ) ; } private InputStream get@@ Xml ( String fileName ) { return getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; } @ Test public void in@@ fl@@ ate@@ _@@ single@@ Button@@ _@@ button@@ Instanti@@ ated ( ) { Button button = ( Button ) in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; assertEquals ( com . vaadin . ui . Button . class , button . getClass ( ) ) ; assertEquals ( "M@@ y Button@@ " , button . getCap@@ tion ( ) ) ; assertEquals ( true , button . is@@ ReadOnly ( ) ) ; } @ Test public void in@@ fl@@ ate@@ _@@ single@@ Button@@ No@@ Namespace@@ _@@ button@@ Instanti@@ ated ( ) { Component button = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; assertEquals ( com . vaadin . ui . Button . class , button . getClass ( ) ) ; assertEquals ( "M@@ y Button@@ " , button . getCap@@ tion ( ) ) ; assertEquals ( true , button . is@@ ReadOnly ( ) ) ; } @ Test public void in@@ fl@@ ate@@ _@@ single@@ Layout@@ _@@ layout@@ With@@ Marg@@ in@@ s@@ Instanti@@ ated ( ) { Component layout = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; assertEquals ( com . vaadin . ui . Vertical@@ Layout . class , layout . getClass ( ) ) ; assertTrue ( ( ( Vertical@@ Layout ) layout ) . getM@@ arg@@ in ( ) . has@@ Top ( ) ) ; assertFalse ( ( ( Vertical@@ Layout ) layout ) . getM@@ arg@@ in ( ) . has@@ Right ( ) ) ; assertFalse ( ( ( Vertical@@ Layout ) layout ) . getM@@ arg@@ in ( ) . has@@ Bottom ( ) ) ; assertTrue ( ( ( Vertical@@ Layout ) layout ) . getM@@ arg@@ in ( ) . has@@ Left ( ) ) ; } @ Test public void in@@ fl@@ ate@@ _@@ layout@@ Attributes@@ _@@ layout@@ Attributes@@ App@@ li@@ ed ( ) { Component layout = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; assertEquals ( com . vaadin . ui . Vertical@@ Layout . class , layout . getClass ( ) ) ; Vertical@@ Layout ver@@ tical@@ Layout = ( Vertical@@ Layout ) layout ; Component button = ver@@ tical@@ Layout . getComponent@@ Iterator ( ) . next ( ) ; assertEquals ( 1.0f , ver@@ tical@@ Layout . get@@ Expand@@ Ratio ( button ) , 0.0f ) ; } @ Test public void in@@ fl@@ ate@@ _@@ component@@ Has@@ Width@@ _@@ width@@ Attribute@@ App@@ li@@ ed ( ) { Component layout = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( layout , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( 200@@ .0f , button@@ 200@@ p@@ x . getWidth ( ) , 0.0f ) ; } @ Test public void in@@ fl@@ ate@@ _@@ add@@ Attribute@@ Interceptor@@ _@@ value@@ Intercep@@ ted@@ Cor@@ rect@@ ly ( ) { LayoutInflater intercep@@ ting@@ Inflater = new LayoutInflater ( ) ; Attribute@@ Interceptor interceptor = new Attribute@@ Interceptor ( ) { @ Override public void intercep@@ t ( Attribute@@ Context attribute@@ Context ) { if ( attribute@@ Context . getValue ( ) . getClass ( ) == String . class ) { String value = ( String ) attribute@@ Context . getValue ( ) ; if ( value . startsWith ( "{@@ i18@@ n@@ :" ) ) { attribute@@ Context . setValue ( "" ) ; } } try { attribute@@ Context . pro@@ ce@@ ed ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ; intercep@@ ting@@ Inflater . add@@ Interceptor ( interceptor ) ; Component intercep@@ ted@@ View = intercep@@ ting@@ Inflater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; Component view = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( intercep@@ ted@@ View , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( view , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "{@@ i18@@ n@@ :@@ test@@ }" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; } @ Test public void in@@ fl@@ ate@@ _@@ single@@ Button@@ _@@ findBy@@ Id@@ Work@@ s ( ) { Component view = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; assertEquals ( com . vaadin . ui . Button . class , Cl@@ ar@@ a . find@@ Component@@ ById ( view , "@@ my@@ -@@ button@@ " ) . getClass ( ) ) ; assertEquals ( null , Cl@@ ar@@ a . find@@ Component@@ ById ( view , "" ) ) ; } @ Test ( expected = Layout@@ In@@ fl@@ ater@@ Exception . class ) public void in@@ fl@@ ate@@ _@@ non@@ Component@@ _@@ exception@@ Throw@@ n ( ) { in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; } @ Test ( expected = Layout@@ In@@ fl@@ ater@@ Exception . class ) public void in@@ fl@@ ate@@ _d@@ uplic@@ ate@@ Id_@@ exception@@ Throw@@ n ( ) { in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; } @ Test ( expected = Layout@@ In@@ fl@@ ater@@ Exception . class ) public void in@@ fl@@ ate@@ _@@ IO@@ Exception@@ _@@ exception@@ Throw@@ n ( ) { in@@ flater . in@@ fl@@ ate ( new InputStream ( ) { @ Override public int read ( ) throws IOException { throw new IOException ( ) ; } } ) ; } @ Test ( expected = Layout@@ In@@ fl@@ ater@@ Exception . class ) public void in@@ fl@@ ate@@ _@@ invalid@@ Xml@@ _@@ exception@@ Throw@@ n ( ) { in@@ flater . in@@ fl@@ ate ( new ByteArrayInputStream ( "" . getBytes ( ) ) ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import java . io . InputStream ; import org . junit . Before ; import org . junit . Test ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . EventHandler ; import com . vaadin . ui . Button ; import com . vaadin . ui . Component ; public class Cl@@ ar@@ a@@ Integration@@ Test { private InputStream xml ; private Controller controller ; private Attribute@@ Interceptor first@@ Interceptor ; private Attribute@@ Interceptor second@@ Interceptor ; public static class Controller { private boolean c@@ lic@@ ked ; @ EventHandler ( "@@ button@@ 200@@ p@@ x" ) public void c@@ lic@@ ked ( Button . Click@@ Event event ) { c@@ lic@@ ked = true ; } } @ Before public void setUp ( ) { xml = get@@ Xml ( "" ) ; controller = new Controller ( ) ; first@@ Interceptor = get@@ Interceptor ( ) ; second@@ Interceptor = getSec@@ ond@@ Interceptor ( ) ; } @ Test public void test@@ Create@@ Method@@ _@@ us@@ ing@@ All@@ Parameter@@ sWith@@ Two@@ Interceptor@@ s_@@ intercep@@ tor@@ s@@ And@@ Controller@@ Called ( ) { Component layout = Cl@@ ar@@ a . create ( xml , controller , first@@ Interceptor , second@@ Interceptor ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( layout , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; assertFalse ( controller . c@@ lic@@ ked ) ; button@@ 200@@ p@@ x . c@@ lick ( ) ; assertTrue ( controller . c@@ lic@@ ked ) ; } @ Test public void test@@ Create@@ Method@@ _@@ us@@ ing@@ All@@ Parameter@@ s_@@ intercep@@ tor@@ And@@ Controller@@ Called ( ) { Component layout = Cl@@ ar@@ a . create ( xml , controller , first@@ Interceptor ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( layout , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; assertFalse ( controller . c@@ lic@@ ked ) ; button@@ 200@@ p@@ x . c@@ lick ( ) ; assertTrue ( controller . c@@ lic@@ ked ) ; } @ Test public void test@@ Create@@ Method@@ _@@ us@@ ing@@ Only@@ Controller@@ _@@ controll@@ er@@ Called ( ) { Component layout = Cl@@ ar@@ a . create ( xml , controller ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( layout , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "{@@ i18@@ n@@ :@@ test@@ }" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; assertFalse ( controller . c@@ lic@@ ked ) ; button@@ 200@@ p@@ x . c@@ lick ( ) ; assertTrue ( controller . c@@ lic@@ ked ) ; } @ Test public void test@@ Create@@ Method@@ _@@ us@@ ing@@ No@@ Parameter@@ s_@@ component@@ In@@ fl@@ ated@@ Cor@@ rect@@ ly ( ) { Component layout = Cl@@ ar@@ a . create ( xml ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( layout , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "{@@ i18@@ n@@ :@@ test@@ }" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; } private InputStream get@@ Xml ( String fileName ) { return getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; } public Attribute@@ Interceptor get@@ Interceptor ( ) { return new Attribute@@ Interceptor ( ) { @ Override public void intercep@@ t ( Attribute@@ Context attribute@@ Context ) { if ( attribute@@ Context . getValue ( ) . getClass ( ) == String . class ) { String value = ( String ) attribute@@ Context . getValue ( ) ; if ( value . startsWith ( "{@@ i18@@ n@@ :" ) ) { attribute@@ Context . setValue ( "" ) ; } } try { attribute@@ Context . pro@@ ce@@ ed ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ; } public Attribute@@ Interceptor getSec@@ ond@@ Interceptor ( ) { return new Attribute@@ Interceptor ( ) { @ Override public void intercep@@ t ( Attribute@@ Context attribute@@ Context ) { if ( attribute@@ Context . getValue ( ) . getClass ( ) == String . class ) { String value = ( String ) attribute@@ Context . getValue ( ) ; if ( value . startsWith ( "" ) ) { attribute@@ Context . setValue ( "" ) ; } } try { attribute@@ Context . pro@@ ce@@ ed ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . util . Date ; import org . junit . Before ; import org . junit . Test ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . Binder ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . DataSource ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . EventHandler ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . LayoutInflater ; import com . vaadin . data . Property ; import com . vaadin . ui . Button ; import com . vaadin . ui . Button . Click@@ Event ; import com . vaadin . ui . Date@@ Field ; public class Bin@@ der@@ Test { private LayoutInflater in@@ flater ; private boolean c@@ lick@@ Called ; @ Before public void setUp ( ) { in@@ flater = new LayoutInflater ( ) ; } private InputStream get@@ Xml ( String fileName ) { return getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; } @ EventHandler ( "@@ my@@ -@@ button@@ " ) public void handle@@ Button@@ Click ( Click@@ Event event ) { c@@ lick@@ Called = true ; } @ DataSource ( "@@ my@@ -@@ date@@ field@@ " ) public Property get@@ DataSource ( ) { Date date = new Date ( 13@@ 37@@ 33@@ 7@@ 47@@ 7@@ 57@@ 8@@ L ) ; return new com . vaadin . data . util . Object@@ Property < Date > ( date ) ; } @ Test public void bin@@ d_@@ c@@ lick@@ Listener@@ _c@@ lick@@ Listener@@ Invo@@ ked ( ) { Button button = ( Button ) in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; Binder bin@@ der = new Binder ( ) ; bin@@ der . bind ( button , this ) ; c@@ lick@@ Called = false ; si@@ mul@@ ate@@ Button@@ Click ( button ) ; assertTrue ( "" , c@@ lick@@ Called ) ; } @ Test public void bin@@ d_@@ data@@ Source@@ _@@ data@@ Source@@ Attach@@ ed ( ) { Date@@ Field view = ( Date@@ Field ) in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; Binder bin@@ der = new Binder ( ) ; bin@@ der . bind ( view , this ) ; Date value = ( Date ) view . getValue ( ) ; assertEquals ( 13@@ 37@@ 33@@ 7@@ 47@@ 7@@ 57@@ 8@@ L , value . getTime ( ) ) ; } private void si@@ mul@@ ate@@ Button@@ Click ( Button button ) { Method fire@@ Click ; try { fire@@ Click = Button . class . getDeclared@@ Method ( "@@ fire@@ Click@@ " ) ; fire@@ Click . set@@ Accessible ( true ) ; fire@@ Click . invoke ( button ) ; } catch ( Exception e ) { throw new RuntimeException ( "" , e ) ; } } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import com . vaadin . ui . Component ; public interface Attribute@@ Interceptor { void intercep@@ t ( Attribute@@ Context invo@@ cation@@ Context ) ; } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import java . lang . reflect . Method ; public abstract class Attribute@@ Context { private Object value ; private Method set@@ ter ; public Attribute@@ Context ( Method set@@ ter , Object value ) { this . value = value ; this . set@@ ter = set@@ ter ; } public abstract void pro@@ ce@@ ed ( ) throws Exception ; public Object getValue ( ) { return value ; } public void setValue ( Object value ) { this . value = value ; } public Method get@@ Set@@ ter ( ) { return set@@ ter ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der ; import java . lang . reflect . Invocation@@ Handler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . Set ; import java . util . logging . Logger ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Cl@@ ar@@ a ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . DataSource ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . EventHandler ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . util . Reflection@@ Utils ; import com . vaadin . data . Container ; import com . vaadin . data . Item ; import com . vaadin . data . Property ; import com . vaadin . ui . Component ; public class Binder { protected Logger getLogger ( ) { return Logger . getLogger ( Binder . class . getName ( ) ) ; } public void bind ( Component component@@ Root , Object controller ) { Method [ ] methods = controller . getClass ( ) . get@@ Methods ( ) ; for ( Method method : methods ) { if ( method . is@@ Annotation@@ Present ( DataSource . class ) ) { bind@@ DataSource ( component@@ Root , controller , method , method . get@@ Annotation ( DataSource . class ) ) ; } if ( method . is@@ Annotation@@ Present ( EventHandler . class ) ) { bind@@ EventHandler ( component@@ Root , controller , method , method . get@@ Annotation ( EventHandler . class ) ) ; } } } private void bind@@ EventHandler ( Component component@@ Root , Object controller , Method method , EventHandler event@@ Listener ) { String component@@ Id = event@@ Listener . value ( ) ; Component component = Cl@@ ar@@ a . find@@ Component@@ ById ( component@@ Root , component@@ Id ) ; Class < ? > event@@ Class = ( method . getParameter@@ Types ( ) . length > 0 ? method . getParameter@@ Types ( ) [ 0 ] : null ) ; if ( event@@ Class != null && component != null ) { Method add@@ Listener@@ Method = get@@ Add@@ Listener@@ Method ( component . getClass ( ) , event@@ Class ) ; if ( add@@ Listener@@ Method != null ) { try { Object listener = create@@ Listener@@ Proxy ( add@@ Listener@@ Method . getParameter@@ Types ( ) [ 0 ] , event@@ Class , method , controller ) ; add@@ Listener@@ Method . invoke ( component , listener ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } } } private Object create@@ Listener@@ Proxy ( Class < ? > listener@@ Class , final Class < ? > event@@ Class , final Method listener@@ Method , final Object controller ) { Object proxy = Proxy . new@@ Proxy@@ Instance ( listener@@ Class . getClassLoader ( ) , new Class < ? > [ ] { listener@@ Class } , new Invocation@@ Handler ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( args != null && args . length > 0 && event@@ Class . isAssignableFrom ( args [ 0 ] . getClass ( ) ) ) { getLogger ( ) . fin@@ e ( String . format ( "" , method . getName ( ) , listener@@ Method . getName ( ) ) ) ; return listener@@ Method . invoke ( controller , args ) ; } getLogger ( ) . fin@@ e ( String . format ( "" , method . getName ( ) , controller . getClass ( ) ) ) ; return method . invoke ( controller , args ) ; } } ) ; getLogger ( ) . fin@@ e ( String . format ( "" , listener@@ Class ) ) ; return proxy ; } private Method get@@ Add@@ Listener@@ Method ( Class < ? extends Component > component@@ Class , Class < ? > event@@ Class ) { Set < Method > methods = Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( component@@ Class , "@@ add@@ Listener@@ " , 1 ) ; for ( Method method : methods ) { Class < ? > listener@@ Class = method . getParameter@@ Types ( ) [ 0 ] ; Method [ ] listener@@ Methods = listener@@ Class . get@@ Methods ( ) ; for ( Method listener@@ Method : listener@@ Methods ) { if ( listener@@ Method . getParameter@@ Types ( ) . length == 1 && listener@@ Method . getParameter@@ Types ( ) [ 0 ] . equals ( event@@ Class ) ) { return method ; } } } return null ; } private void bind@@ DataSource ( Component component@@ Root , Object controller , Method method , DataSource dataSource ) { String component@@ Id = dataSource . value ( ) ; Component component = Cl@@ ar@@ a . find@@ Component@@ ById ( component@@ Root , component@@ Id ) ; Class < ? > data@@ Source@@ Class = method . get@@ ReturnType ( ) ; try { if ( is@@ Container ( data@@ Source@@ Class ) && component instanceof Container . Viewer ) { ( ( Container . Viewer ) component ) . set@@ Container@@ DataSource ( ( Container ) method . invoke ( controller ) ) ; } else if ( is@@ Property ( data@@ Source@@ Class ) && component instanceof Property . Viewer ) { ( ( Property . Viewer ) component ) . set@@ Property@@ DataSource ( ( Property ) method . invoke ( controller ) ) ; } else if ( is@@ Item ( data@@ Source@@ Class ) && component instanceof Item . Viewer ) { ( ( Item . Viewer ) component ) . set@@ Item@@ DataSource ( ( Item ) method . invoke ( controller ) ) ; } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } private boolean is@@ Container ( Class < ? > data@@ Source@@ Class ) { return Container . class . isAssignableFrom ( data@@ Source@@ Class ) ; } private boolean is@@ Item ( Class < ? > data@@ Source@@ Class ) { return Item . class . isAssignableFrom ( data@@ Source@@ Class ) ; } private boolean is@@ Property ( Class < ? > data@@ Source@@ Class ) { return Property . class . isAssignableFrom ( data@@ Source@@ Class ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import com . vaadin . ui . Button ; import com . vaadin . ui . Button . Click@@ Event ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD ) public @ interface EventHandler { String value ( ) ; } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import com . vaadin . data . Container ; import com . vaadin . data . Item ; import com . vaadin . data . Property ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD ) public @ interface DataSource { String value ( ) ; } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . util ; import java . lang . reflect . Method ; import java . util . HashSet ; import java . util . Set ; import com . vaadin . ui . Component ; public class Reflection@@ Utils { private Reflection@@ Utils ( ) { throw new Assertion@@ Error ( ) ; } public static Set < Method > get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class < ? > clazz , String methodName , int numberOf@@ Params ) { Set < Method > methods = new HashSet < Method > ( ) ; for ( Method method : clazz . get@@ Methods ( ) ) { if ( method . getName ( ) . equals ( methodName ) && method . getParameter@@ Types ( ) . length == numberOf@@ Params ) { methods . add ( method ) ; } } return methods ; } public static boolean is@@ Component ( Class < ? > component@@ Class ) { if ( component@@ Class != null ) { return Component . class . isAssignableFrom ( component@@ Class ) ; } else { return false ; } } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import java . io . InputStream ; import java . util . Iterator ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . Binder ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . LayoutInflater ; import com . vaadin . ui . Component ; import com . vaadin . ui . Component@@ Container ; public class Cl@@ ar@@ a { public static Component create ( InputStream xml ) { return create ( xml , null ) ; } public static Component create ( InputStream xml , Object controller , Attribute@@ Interceptor ... intercep@@ tors ) { LayoutInflater in@@ flater = new LayoutInflater ( ) ; if ( intercep@@ tors != null ) { for ( Attribute@@ Interceptor interceptor : intercep@@ tors ) { in@@ flater . add@@ Interceptor ( interceptor ) ; } } Component result = in@@ flater . in@@ fl@@ ate ( xml ) ; if ( controller != null ) { Binder bin@@ der = new Binder ( ) ; bin@@ der . bind ( result , controller ) ; } return result ; } public static Component find@@ Component@@ ById ( Component root , String component@@ Id ) { if ( component@@ Id == null ) { throw new IllegalArgumentException ( "" ) ; } if ( component@@ Id . equals ( root . get@@ Debug@@ Id ( ) ) ) { return root ; } else if ( root instanceof Component@@ Container ) { for ( Iterator < Component > i = ( ( Component@@ Container ) root ) . getComponent@@ Iterator ( ) ; i . hasNext ( ) ; ) { Component c = find@@ Component@@ ById ( i . next ( ) , component@@ Id ) ; if ( c != null ) { return c ; } } } return null ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; public interface Attribute@@ Parser { boolean is@@ Supported ( Class < ? > value@@ Type ) ; Object getValue@@ A@@ s ( String value , Class < ? > value@@ Type ) ; } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . util . HashMap ; import java . util . Map ; import java . util . Stack ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helper@@ s . Default@@ Handler ; import com . vaadin . ui . Component ; import com . vaadin . ui . Component@@ Container ; class Layout@@ In@@ fl@@ ater@@ Content@@ Handler extends Default@@ Handler { private static final String UR@@ N_@@ NAMESP@@ ACE_@@ ID = "@@ package@@ " ; private static final String DEFAULT_@@ NAMESPACE = "@@ urn@@ :" + UR@@ N_@@ NAMESP@@ ACE_@@ ID + "" ; private static final String LAY@@ OUT_@@ ATTRIBUTE_@@ NAMESPACE = "" ; private Stack < Component > component@@ Stack = new Stack < Component > ( ) ; private Component@@ Container current@@ Container ; private Component current@@ Component ; private Component root ; private final Component@@ Manager component@@ Factory ; private final Map < String , Component > id@@ Map = new HashMap < String , Component > ( ) ; public Layout@@ In@@ fl@@ ater@@ Content@@ Handler ( Component@@ Manager component@@ Factory ) { this . component@@ Factory = component@@ Factory ; } public Component getRoot ( ) { return root ; } @ Override public void start@@ Element ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { super . start@@ Element ( uri , localName , qName , attributes ) ; if ( uri == null || uri . length ( ) == 0 ) { uri = DEFAULT_@@ NAMESPACE ; } current@@ Component = null ; if ( uri . startsWith ( "@@ urn@@ :" + UR@@ N_@@ NAMESP@@ ACE_@@ ID + ":" ) ) { String package@@ Name = uri . substring ( ( "@@ urn@@ :" + UR@@ N_@@ NAMESP@@ ACE_@@ ID + ":" ) . length ( ) ) ; String className = localName ; Map < String , String > attribute@@ Map = getAttribute@@ Map ( attributes ) ; Map < String , String > layout@@ Attribute@@ Map = get@@ Layout@@ Attribute@@ Map ( attributes ) ; current@@ Component = component@@ Factory . create@@ Component ( package@@ Name , className , attribute@@ Map ) ; if ( current@@ Component . get@@ Debug@@ Id ( ) != null ) { id@@ Map . put ( current@@ Component . get@@ Debug@@ Id ( ) , current@@ Component ) ; } if ( root == null ) { root = current@@ Component ; } if ( current@@ Container != null ) { current@@ Container . addComponent ( current@@ Component ) ; component@@ Factory . apply@@ Layout@@ Attributes ( current@@ Container , current@@ Component , layout@@ Attribute@@ Map ) ; } if ( current@@ Component instanceof Component@@ Container ) { current@@ Container = ( Component@@ Container ) current@@ Component ; } component@@ Stack . push ( current@@ Component ) ; } } private Map < String , String > getAttribute@@ Map ( Attributes attributes ) { Map < String , String > attribute@@ Map = new HashMap < String , String > ( attributes . getLength ( ) ) ; for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { if ( ! attributes . getURI ( i ) . equals ( LAY@@ OUT_@@ ATTRIBUTE_@@ NAMESPACE ) ) { String value = attributes . getValue ( i ) ; String name = attributes . getLocalName ( i ) ; if ( name . equals ( "id" ) ) { if ( id@@ Map . containsKey ( value ) ) { throw new Layout@@ In@@ fl@@ ater@@ Exception ( String . format ( "" , value ) ) ; } name = "@@ debug@@ Id" ; } attribute@@ Map . put ( name , value ) ; } } return attribute@@ Map ; } private Map < String , String > get@@ Layout@@ Attribute@@ Map ( Attributes attributes ) { Map < String , String > attribute@@ Map = new HashMap < String , String > ( attributes . getLength ( ) ) ; for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { if ( attributes . getURI ( i ) . equals ( LAY@@ OUT_@@ ATTRIBUTE_@@ NAMESPACE ) ) { String value = attributes . getValue ( i ) ; String name = attributes . getLocalName ( i ) ; attribute@@ Map . put ( name , value ) ; } } return attribute@@ Map ; } @ Override public void end@@ Element ( String uri , String localName , String qName ) throws SAXException { super . end@@ Element ( uri , localName , qName ) ; Component component = component@@ Stack . pop ( ) ; if ( component instanceof Component@@ Container ) { current@@ Container = ( Component@@ Container ) component . getParent ( ) ; } } public Map < String , Component > get@@ Id@@ Map ( ) { return id@@ Map ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . logging . Logger ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Attribute@@ Context ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Attribute@@ Interceptor ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . util . Reflection@@ Utils ; import com . vaadin . ui . Component ; import com . vaadin . ui . Component@@ Container ; public class Default@@ Component@@ Manager implements Component@@ Manager { private List < Attribute@@ Parser > attribute@@ Parser@@ s = new ArrayList < Attribute@@ Parser > ( ) ; private List < Attribute@@ Interceptor > intercep@@ tors = new ArrayList < Attribute@@ Interceptor > ( ) ; private Logger getLogger ( ) { return Logger . getLogger ( Default@@ Component@@ Manager . class . getName ( ) ) ; } public Default@@ Component@@ Manager ( ) { add@@ Attribute@@ Parser ( new Primitive@@ Attribute@@ Parser ( ) ) ; add@@ Attribute@@ Parser ( new V@@ aad@@ in@@ Attribute@@ Parser ( ) ) ; } public void add@@ Attribute@@ Parser ( Attribute@@ Parser handler ) { attribute@@ Parser@@ s . add ( handler ) ; } public void remove@@ Attribute@@ Parser ( Attribute@@ Parser handler ) { attribute@@ Parser@@ s . remove ( handler ) ; } public Component create@@ Component ( String namespace , String name , Map < String , String > attributes ) throws Component@@ Instanti@@ ationException { try { Class < ? extends Component > component@@ Class = resolve@@ Component@@ Class ( namespace , name ) ; Component new@@ Component = component@@ Class . newInstance ( ) ; handle@@ Attributes ( new@@ Component , attributes ) ; return new@@ Component ; } catch ( Exception e ) { throw create@@ Exception ( e , namespace , name ) ; } } protected Component@@ Instanti@@ ationException create@@ Exception ( Exception e , String namespace , String name ) { String message = String . format ( "" , namespace , name ) ; if ( e != null ) { return new Component@@ Instanti@@ ationException ( message , e ) ; } else { return new Component@@ Instanti@@ ationException ( message ) ; } } @ SuppressWarnings ( "unchecked" ) protected Class < ? extends Component > resolve@@ Component@@ Class ( String namespace , String name ) throws ClassNotFoundException { String quali@@ fied@@ ClassName = namespace + "." + name ; Class < ? > component@@ Class = null ; component@@ Class = Class . forName ( quali@@ fied@@ ClassName ) ; if ( Reflection@@ Utils . is@@ Component ( component@@ Class ) ) { return ( Class < ? extends Component > ) component@@ Class ; } else { throw new IllegalArgumentException ( String . format ( "" , component@@ Class . getName ( ) , Component . class . getName ( ) ) ) ; } } protected void handle@@ Attributes ( Component component , Map < String , String > attributes ) { getLogger ( ) . fin@@ e ( attributes . toString ( ) ) ; try { for ( Map . Entry < String , String > attribute : attributes . entrySet ( ) ) { Method set@@ ter = get@@ Set@@ ter ( attribute . getKey ( ) , component . getClass ( ) ) ; if ( set@@ ter != null ) { Attribute@@ Parser handler = get@@ Handler@@ For ( set@@ ter . getParameter@@ Types ( ) [ 0 ] ) ; if ( handler != null ) { String attribute@@ Value = attribute . getValue ( ) ; if ( attribute@@ Value == null || attribute@@ Value . length ( ) == 0 ) { invoke@@ With@@ Intercep@@ tors ( set@@ ter , component , attribute@@ Value ) ; } else { invoke@@ With@@ Intercep@@ tors ( set@@ ter , component , handler . getValue@@ A@@ s ( attribute@@ Value , set@@ ter . getParameter@@ Types ( ) [ 0 ] ) ) ; } } } } } catch ( SecurityException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } protected void invoke@@ With@@ Intercep@@ tors ( final Method method@@ To@@ Invo@@ ke , final Object obj , final Object ... args ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { if ( intercep@@ tors . isEmpty ( ) ) { method@@ To@@ Invo@@ ke . invoke ( obj , args ) ; } else { final LinkedList < Attribute@@ Interceptor > intercep@@ tor@@ s@@ Copy = new LinkedList < Attribute@@ Interceptor > ( intercep@@ tors ) ; Attribute@@ Interceptor interceptor = intercep@@ tor@@ s@@ Copy . pop ( ) ; interceptor . intercep@@ t ( new Attribute@@ Context ( method@@ To@@ Invo@@ ke , args . length > 1 ? args [ 1 ] : args [ 0 ] ) { @ Override public void pro@@ ce@@ ed ( ) throws Exception { if ( intercep@@ tor@@ s@@ Copy . size ( ) > 0 ) { intercep@@ tor@@ s@@ Copy . pop ( ) . intercep@@ t ( this ) ; } else { if ( args . length > 1 ) { method@@ To@@ Invo@@ ke . invoke ( obj , args [ 0 ] , this . getValue ( ) ) ; } else { method@@ To@@ Invo@@ ke . invoke ( obj , this . getValue ( ) ) ; } } } } ) ; } } protected Attribute@@ Parser get@@ Handler@@ For ( Class < ? > type ) { for ( Attribute@@ Parser handler : attribute@@ Parser@@ s ) { if ( handler . is@@ Supported ( type ) ) { return handler ; } } return null ; } public void apply@@ Layout@@ Attributes ( Component@@ Container container , Component component , Map < String , String > attributes ) { if ( ! component . getParent ( ) . equals ( container ) ) { throw new IllegalStateException ( "" ) ; } try { for ( Map . Entry < String , String > attribute : attributes . entrySet ( ) ) { Method layout@@ Method = get@@ Layout@@ Method ( container . getClass ( ) , attribute . getKey ( ) ) ; if ( layout@@ Method != null ) { Attribute@@ Parser handler = get@@ Handler@@ For ( layout@@ Method . getParameter@@ Types ( ) [ 1 ] ) ; if ( handler != null ) { invoke@@ With@@ Intercep@@ tors ( layout@@ Method , container , component , handler . getValue@@ A@@ s ( attribute . getValue ( ) , layout@@ Method . getParameter@@ Types ( ) [ 1 ] ) ) ; } } } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } private Method get@@ Set@@ ter ( String propertyName , Class < ? extends Component > component@@ Class ) { Set < Method > write@@ Methods = Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( component@@ Class , "@@ set@@ " + cap@@ it@@ alize ( propertyName ) , 1 ) ; return select@@ Preferred@@ Method ( write@@ Methods , 0 ) ; } private static String cap@@ it@@ alize ( String propertyName ) { if ( propertyName . length ( ) > 0 ) { return propertyName . substring ( 0 , 1 ) . toUpperCase ( ) + propertyName . substring ( 1 ) ; } return "" ; } private Method get@@ Layout@@ Method ( Class < ? extends Component@@ Container > layout@@ Class , String propertyName ) { String method@@ To@@ Look@@ For = "@@ set@@ " + propertyName . substring ( 0 , 1 ) . toUpperCase ( ) + propertyName . substring ( 1 ) ; Set < Method > set@@ ter@@ sWith@@ Two@@ Params = Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( layout@@ Class , method@@ To@@ Look@@ For , 2 ) ; return select@@ Preferred@@ Method ( set@@ ter@@ sWith@@ Two@@ Params , 1 ) ; } private Method select@@ Preferred@@ Method ( Set < Method > methods , int data@@ Param@@ Index ) { Method candid@@ ate = null ; for ( Method method : methods ) { if ( data@@ Param@@ Index > 0 && ! Reflection@@ Utils . is@@ Component ( method . getParameter@@ Types ( ) [ 0 ] ) ) { continue ; } Class < ? > parameter@@ Type = method . getParameter@@ Types ( ) [ data@@ Param@@ Index ] ; Attribute@@ Parser handler = get@@ Handler@@ For ( parameter@@ Type ) ; if ( handler != null && ! ( handler instanceof Primitive@@ Attribute@@ Parser ) ) { return method ; } if ( method . is@@ Annotation@@ Present ( Deprecated . class ) || ! parameter@@ Type . equals ( String . class ) ) { candid@@ ate = method ; } else { return method ; } } return candid@@ ate ; } @ Override public void add@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) { intercep@@ tors . add ( attribute@@ Interceptor ) ; } @ Override public void remove@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) { intercep@@ tors . remove ( attribute@@ Interceptor ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; @ SuppressWarnings ( "@@ serial@@ " ) public class Layout@@ In@@ fl@@ ater@@ Exception extends RuntimeException { public Layout@@ In@@ fl@@ ater@@ Exception ( String message ) { super ( message ) ; } public Layout@@ In@@ fl@@ ater@@ Exception ( String message , Throwable e ) { super ( message , e ) ; } public Layout@@ In@@ fl@@ ater@@ Exception ( Throwable e ) { super ( e ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; @ SuppressWarnings ( "@@ serial@@ " ) public class Component@@ Instanti@@ ationException extends RuntimeException { public Component@@ Instanti@@ ationException ( ) { super ( ) ; } public Component@@ Instanti@@ ationException ( String message ) { super ( message ) ; } public Component@@ Instanti@@ ationException ( String message , Throwable e ) { super ( message , e ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . util . Arrays ; import java . util . List ; public class Primitive@@ Attribute@@ Parser implements Attribute@@ Parser { @ SuppressWarnings ( "unchecked" ) private static final List < Class < ? > > supported@@ Classes = Arrays . asList ( String . class , Object . class , Boolean . class , Integer . class , Byte . class , Short . class , Long . class , Character . class , Float . class , Double . class ) ; public boolean is@@ Supported ( Class < ? > value@@ Type ) { return value@@ Type != null && ( value@@ Type . is@@ Primitive ( ) || supported@@ Classes . contains ( value@@ Type ) ) ; } public Object getValue@@ A@@ s ( String value , Class < ? > type ) { if ( type == String . class || type == Object . class ) { return value ; } if ( type == Boolean . TYPE || type == Boolean . class ) { return Boolean . valueOf ( value ) ; } if ( type == Integer . TYPE || type == Integer . class ) { return Integer . valueOf ( value ) ; } if ( type == Byte . TYPE || type == Byte . class ) { return Byte . valueOf ( value ) ; } if ( type == Short . TYPE || type == Short . class ) { return Short . valueOf ( value ) ; } if ( type == Long . TYPE || type == Long . class ) { return Long . valueOf ( value ) ; } if ( type == Character . TYPE || type == Character . class ) { return value . charAt ( 0 ) ; } if ( type == Float . TYPE || type == Float . class ) { return Float . valueOf ( value ) ; } if ( type == Double . TYPE || type == Double . class ) { return Double . valueOf ( value ) ; } return null ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Attribute@@ Interceptor ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XML@@ Reader ; import org . xml . sax . helper@@ s . XML@@ Reader@@ Factory ; import com . vaadin . Application ; import com . vaadin . service . ApplicationContext ; import com . vaadin . ui . Component ; public class LayoutInflater { private Component@@ Manager component@@ Manager = new Default@@ Component@@ Manager ( ) ; public void set@@ Component@@ Manager ( Component@@ Manager component@@ Manager ) { this . component@@ Manager = component@@ Manager ; } public Component in@@ fl@@ ate ( Application app , String xml@@ File ) throws Layout@@ In@@ fl@@ ater@@ Exception { File layout@@ File = get@@ Layout@@ File ( app . getContext ( ) , xml@@ File ) ; try { return in@@ fl@@ ate ( new FileInputStream ( layout@@ File ) ) ; } catch ( FileNotFoundException e ) { throw new Layout@@ In@@ fl@@ ater@@ Exception ( "G@@ ive@@ n file " + layout@@ File . getAbsolutePath ( ) + "" ) ; } } public Component in@@ fl@@ ate ( InputStream xml ) throws Layout@@ In@@ fl@@ ater@@ Exception { try { Layout@@ In@@ fl@@ ater@@ Content@@ Handler handler = new Layout@@ In@@ fl@@ ater@@ Content@@ Handler ( component@@ Manager ) ; XML@@ Reader parser = XML@@ Reader@@ Factory . create@@ XML@@ Reader ( ) ; parser . setContent@@ Handler ( handler ) ; parser . parse ( new InputSource ( xml ) ) ; return handler . getRoot ( ) ; } catch ( SAXException e ) { throw new Layout@@ In@@ fl@@ ater@@ Exception ( e ) ; } catch ( IOException e ) { throw new Layout@@ In@@ fl@@ ater@@ Exception ( e ) ; } catch ( Component@@ Instanti@@ ationException e ) { throw new Layout@@ In@@ fl@@ ater@@ Exception ( e . getMessage ( ) , e ) ; } } public void add@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) { component@@ Manager . add@@ Interceptor ( attribute@@ Interceptor ) ; } public void remove@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) { component@@ Manager . remove@@ Interceptor ( attribute@@ Interceptor ) ; } private static File get@@ Layout@@ File ( ApplicationContext context , String file@@ path ) { return new File ( context . getBase@@ Directory ( ) . getAbsolute@@ File ( ) + File . separator + "@@ V@@ A@@ AD@@ IN@@ " + File . separator + "@@ layout@@ s" + File . separator + file@@ path ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . util . Map ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Attribute@@ Interceptor ; import com . vaadin . ui . Component ; import com . vaadin . ui . Component@@ Container ; public interface Component@@ Manager { Component create@@ Component ( String namespace , String name , Map < String , String > attributes ) throws Component@@ Instanti@@ ationException ; void apply@@ Layout@@ Attributes ( Component@@ Container container , Component component , Map < String , String > attributes ) ; void add@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) ; void remove@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) ; } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . util . HashMap ; import java . util . Map ; import com . vaadin . ui . Alignment ; import com . vaadin . ui . Layout . Marg@@ in@@ Info ; public class V@@ aad@@ in@@ Attribute@@ Parser implements Attribute@@ Parser { protected static final Map < String , Alignment > align@@ ment@@ Map ; static { align@@ ment@@ Map = new HashMap < String , Alignment > ( ) ; align@@ ment@@ Map . put ( "" , Alignment . BO@@ T@@ TO@@ M_@@ CENTER ) ; align@@ ment@@ Map . put ( "@@ BO@@ T@@ TO@@ M_@@ LEF@@ T" , Alignment . BO@@ T@@ TO@@ M_@@ LEFT ) ; align@@ ment@@ Map . put ( "@@ BO@@ T@@ TO@@ M_@@ R@@ IG@@ HT@@ " , Alignment . BO@@ T@@ TO@@ M_@@ RIGHT ) ; align@@ ment@@ Map . put ( "" , Alignment . M@@ ID@@ D@@ LE_@@ CENTER ) ; align@@ ment@@ Map . put ( "M@@ ID@@ D@@ LE_@@ LEF@@ T" , Alignment . M@@ ID@@ D@@ LE_@@ LEFT ) ; align@@ ment@@ Map . put ( "M@@ ID@@ D@@ LE_@@ R@@ IG@@ HT@@ " , Alignment . M@@ ID@@ D@@ LE_@@ RIGHT ) ; align@@ ment@@ Map . put ( "@@ TO@@ P_@@ CEN@@ TER@@ " , Alignment . TO@@ P_@@ CENTER ) ; align@@ ment@@ Map . put ( "@@ TO@@ P_@@ LEF@@ T" , Alignment . TO@@ P_@@ LEFT ) ; align@@ ment@@ Map . put ( "@@ TO@@ P_@@ R@@ IG@@ HT@@ " , Alignment . TO@@ P_@@ RIGHT ) ; } public boolean is@@ Supported ( Class < ? > value@@ Type ) { return value@@ Type != null && ( value@@ Type == Marg@@ in@@ Info . class || value@@ Type == Alignment . class ) ; } public Object getValue@@ A@@ s ( String value , Class < ? > value@@ Type ) { if ( value@@ Type == Marg@@ in@@ Info . class ) { return parse@@ Marg@@ in@@ Info ( value ) ; } else if ( value@@ Type == Alignment . class ) { return parse@@ Alignment ( value ) ; } return null ; } private Object parse@@ Alignment ( String value ) { return align@@ ment@@ Map . get ( value ) ; } protected Marg@@ in@@ Info parse@@ Marg@@ in@@ Info ( String marg@@ in ) { if ( marg@@ in . length ( ) > 4 ) { String [ ] marg@@ ins = marg@@ in . split ( " " ) ; if ( marg@@ ins . length == 4 ) { return new Marg@@ in@@ Info ( Boolean . valueOf ( marg@@ ins [ 0 ] ) , Boolean . valueOf ( marg@@ ins [ 1 ] ) , Boolean . valueOf ( marg@@ ins [ 2 ] ) , Boolean . valueOf ( marg@@ ins [ 3 ] ) ) ; } } return new Marg@@ in@@ Info ( Boolean . valueOf ( marg@@ in ) ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import org . osgi . framework . Bundle ; public class Plugin@@ In@@ Stream@@ Provider implements IT@@ emp@@ late@@ In@@ Stream@@ Provider { Bundle f@@ Bundle ; public Plugin@@ In@@ Stream@@ Provider ( Bundle bundle ) { f@@ Bundle = bundle ; } public InputStream open@@ Stream ( String path ) { URL url = f@@ Bundle . get@@ Entry ( path ) ; InputStream in = null ; if ( url != null ) { try { in = url . open@@ Stream ( ) ; } catch ( IOException e ) { } } return in ; } public void close@@ Stream ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . util . List ; public interface I@@ External@@ Template@@ Path@@ Provider { List < String > get@@ External@@ Template@@ Path ( ) ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class Template@@ F@@ S@@ File@@ Creator implements IT@@ emp@@ late@@ File@@ Creator { private File f@@ Root ; public Template@@ F@@ S@@ File@@ Creator ( File root ) { f@@ Root = root ; } public void create@@ File ( String path , InputStream content ) { File file = new File ( f@@ Root , path ) ; byte tmp [ ] = new byte [ 16@@ 38@@ 4 ] ; int len ; if ( ! file . getParent@@ File ( ) . exists ( ) ) { file . getParent@@ File ( ) . mk@@ dirs ( ) ; } try { FileOutputStream fos = new FileOutputStream ( file ) ; while ( ( len = content . read ( tmp , 0 , tmp . length ) ) > 0 ) { fos . write ( tmp , 0 , len ) ; } fos . close ( ) ; } catch ( IOException e ) { } } public OutputStream open@@ Stream ( String path ) { File target = new File ( f@@ Root , path ) ; try { return new FileOutputStream ( target ) ; } catch ( IOException e ) { } return null ; } public void close@@ Stream ( OutputStream out ) { try { out . close ( ) ; } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . File ; import java . io . InputStream ; import java . util . List ; public abstract class Abstract@@ External@@ Template@@ Finder extends Abstract@@ Template@@ Finder { private IT@@ emp@@ late@@ In@@ Stream@@ Provider f@@ In@@ Provider ; public Abstract@@ External@@ Template@@ Finder ( IT@@ emp@@ late@@ In@@ Stream@@ Provider in_@@ provider ) { super ( ) ; f@@ In@@ Provider = in_@@ provider ; } @ Override public void find ( ) { List < String > path@@ s = find@@ Template@@ Paths ( ) ; for ( String path : path@@ s ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path ) ; InputStream in = open@@ File ( path ) ; File tmp@@ l@@ _@@ dir = new File ( path ) . getParent@@ File ( ) ; if ( in == null ) { f@@ Log . error ( "" + path + "\"" ) ; continue ; } SV@@ T@@ Parser p = new SV@@ T@@ Parser ( tmp@@ l@@ _@@ dir . getPath ( ) , f@@ In@@ Provider ) ; try { p . parse ( in ) ; } catch ( Exception e ) { f@@ Log . error ( "" + path + "\@@ ": " + e . getMessage ( ) , e ) ; } for ( Template@@ Category c : p . getC@@ ateg@@ ories ( ) ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + c . getId ( ) + " name@@ =" + c . getName ( ) ) ; } f@@ Categ@@ ories . addAll ( p . getC@@ ateg@@ ories ( ) ) ; for ( Template@@ Info t@@ i : p . get@@ Template@@ s ( ) ) { f@@ Template@@ s . add ( t@@ i ) ; f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + t@@ i . getId ( ) + " name@@ =" + t@@ i . getName ( ) ) ; if ( ! t@@ i . get@@ Template@@ s ( ) . iterator ( ) . hasNext ( ) ) { List < String > files = list@@ Files ( tmp@@ l@@ _@@ dir . getPath ( ) ) ; for ( String file : files ) { File f = new File ( file ) ; if ( ! f . getName ( ) . endsWith ( ".@@ sv@@ t" ) && ! f . getName ( ) . startsWith ( "." ) ) { File fn = new File ( file ) ; t@@ i . add@@ Template ( file , fn . getName ( ) ) ; } } } } close@@ Stream ( in ) ; } } protected abstract List < String > find@@ Template@@ Paths ( ) ; protected abstract List < String > list@@ Files ( String path ) ; protected abstract InputStream open@@ File ( String path ) ; protected abstract void close@@ Stream ( InputStream in ) ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . InputStream ; public interface IT@@ emp@@ late@@ File@@ Creator { void create@@ File ( String path , InputStream content ) ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . log . LogFactory ; public class F@@ S@@ External@@ Template@@ Finder extends Abstract@@ External@@ Template@@ Finder { private File f@@ Path ; public F@@ S@@ External@@ Template@@ Finder ( File path ) { super ( new F@@ S@@ In@@ Stream@@ Provider ( ) ) ; f@@ Path = path ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; } @ Override protected List < String > find@@ Template@@ Paths ( ) { List < String > template@@ _@@ path@@ s = new ArrayList < String > ( ) ; find@@ Template@@ Paths ( template@@ _@@ path@@ s , f@@ Path ) ; return template@@ _@@ path@@ s ; } private void find@@ Template@@ Paths ( List < String > path@@ s , File path ) { File files [ ] = path . list@@ Files ( ) ; if ( files != null ) { for ( File file : files ) { if ( file . isDirectory ( ) ) { find@@ Template@@ Paths ( path@@ s , file ) ; } else if ( file . getName ( ) . endsWith ( ".@@ sv@@ t" ) ) { path@@ s . add ( file . getAbsolutePath ( ) ) ; } } } } @ Override protected List < String > list@@ Files ( String path ) { File file = new File ( path ) ; List < String > ret = new ArrayList < String > ( ) ; if ( file . isDirectory ( ) ) { File files [ ] = file . list@@ Files ( ) ; if ( files != null ) { for ( File f : files ) { if ( f . is@@ File ( ) ) { ret . add ( f . getAbsolutePath ( ) ) ; } } } } return ret ; } @ Override protected InputStream open@@ File ( String path ) { InputStream in = null ; try { in = new FileInputStream ( path ) ; } catch ( IOException e ) { } return in ; } @ Override protected void close@@ Stream ( InputStream in ) { try { if ( in != null ) { in . close ( ) ; } } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . InputStream ; public interface IT@@ emp@@ late@@ In@@ Stream@@ Provider { InputStream open@@ Stream ( String path ) ; void close@@ Stream ( InputStream in ) ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . xml . sax . Error@@ Handler ; import org . xml . sax . SAXException ; import org . xml . sax . SAX@@ ParseException ; public class SV@@ T@@ Parser { private Document f@@ Document ; private List < Template@@ Info > f@@ Template@@ s ; private List < Template@@ Category > f@@ Categ@@ ories ; private Log@@ Handle f@@ Log ; private IT@@ emp@@ late@@ In@@ Stream@@ Provider f@@ In@@ Provider ; private String f@@ Template@@ Base ; public SV@@ T@@ Parser ( String template@@ _@@ base , IT@@ emp@@ late@@ In@@ Stream@@ Provider in_@@ provider ) { f@@ Template@@ s = new ArrayList < Template@@ Info > ( ) ; f@@ Categ@@ ories = new ArrayList < Template@@ Category > ( ) ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "S@@ V@@ T@@ Parser@@ " ) ; f@@ In@@ Provider = in_@@ provider ; f@@ Template@@ Base = template@@ _@@ base ; } public void parse ( InputStream in ) throws Exception { DocumentBuilderFactory f = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder b = f . new@@ DocumentBuilder ( ) ; f@@ Template@@ s . clear ( ) ; f@@ Categ@@ ories . clear ( ) ; b . set@@ Error@@ Handler ( f@@ Error@@ Handler ) ; f@@ Document = b . parse ( in ) ; NodeList s@@ v_@@ template@@ _@@ list = f@@ Document . getElementsBy@@ TagName ( "s@@ v_@@ template@@ " ) ; if ( s@@ v_@@ template@@ _@@ list . getLength ( ) == 0 ) { return ; } Element s@@ v_@@ template = ( Element ) s@@ v_@@ template@@ _@@ list . item ( 0 ) ; NodeList category@@ _@@ list = s@@ v_@@ template . getElementsBy@@ TagName ( "c@@ ateg@@ ory@@ " ) ; for ( int i = 0 ; i < category@@ _@@ list . getLength ( ) ; i ++ ) { add@@ Category ( ( Element ) category@@ _@@ list . item ( i ) ) ; } NodeList template@@ _@@ list = s@@ v_@@ template . getElementsBy@@ TagName ( "@@ template@@ " ) ; for ( int i = 0 ; i < template@@ _@@ list . getLength ( ) ; i ++ ) { add@@ Template ( ( Element ) template@@ _@@ list . item ( i ) ) ; } } public List < Template@@ Category > getC@@ ateg@@ ories ( ) { return f@@ Categ@@ ories ; } public List < Template@@ Info > get@@ Template@@ s ( ) { return f@@ Template@@ s ; } private void add@@ Category ( Element category ) { String name = category . getAttribute ( "name" ) ; String id = category . getAttribute ( "id" ) ; String parent = category . getAttribute ( "@@ parent@@ " ) ; if ( parent == null ) { parent = "" ; } Template@@ Category c = new Template@@ Category ( id , name , parent ) ; NodeList d@@ l = category . getElementsBy@@ TagName ( "@@ descrip@@ tion" ) ; if ( d@@ l . getLength ( ) > 0 ) { Element desc = ( Element ) d@@ l . item ( 0 ) ; c . setDescription ( desc . getText@@ Content ( ) ) ; } if ( ! f@@ Categ@@ ories . contains ( c ) ) { f@@ Categ@@ ories . add ( c ) ; } } private void add@@ Template ( Element template ) { String name = template . getAttribute ( "name" ) ; String id = template . getAttribute ( "id" ) ; String category = template . getAttribute ( "c@@ ateg@@ ory@@ " ) ; Template@@ Info t = new Template@@ Info ( id , name , category , "" , f@@ In@@ Provider ) ; NodeList description = template . getElementsBy@@ TagName ( "@@ descrip@@ tion" ) ; if ( description . getLength ( ) > 0 ) { Element e = ( Element ) description . item ( 0 ) ; t . setDescription ( e . getText@@ Content ( ) ) ; } NodeList files = template . getElementsBy@@ TagName ( "@@ fil@@ es" ) ; if ( files . getLength ( ) > 0 ) { Element e = ( Element ) files . item ( 0 ) ; NodeList file@@ _@@ list = e . getElementsBy@@ TagName ( "file@@ " ) ; for ( int i = 0 ; i < file@@ _@@ list . getLength ( ) ; i ++ ) { Element file = ( Element ) file@@ _@@ list . item ( i ) ; String filename = file . getAttribute ( "name" ) ; String tmp@@ l@@ _@@ path = file . getAttribute ( "@@ template@@ " ) ; filename = filename . trim ( ) ; tmp@@ l@@ _@@ path = tmp@@ l@@ _@@ path . trim ( ) ; t . add@@ Template ( f@@ Template@@ Base + "/" + tmp@@ l@@ _@@ path , filename ) ; } } NodeList parameters = template . getElementsBy@@ TagName ( "parameter@@ s" ) ; if ( parameters . getLength ( ) > 0 ) { Element e = ( Element ) parameters . item ( 0 ) ; NodeList parameter@@ s_@@ list = e . getElementsBy@@ TagName ( "parameter@@ " ) ; for ( int i = 0 ; i < parameter@@ s_@@ list . getLength ( ) ; i ++ ) { Element parameter = ( Element ) parameter@@ s_@@ list . item ( i ) ; Template@@ Parameter@@ Type p@@ _type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Id ; String p@@ _name = parameter . getAttribute ( "name" ) ; String p_@@ type@@ _@@ s = parameter . getAttribute ( "type" ) ; String p@@ _d@@ fl@@ t = parameter . getAttribute ( "@@ default@@ " ) ; String p_@@ ext = parameter . getAttribute ( "@@ ext@@ end@@ s_@@ from@@ " ) ; String p_@@ res@@ tr = parameter . getAttribute ( "@@ res@@ tr@@ iction@@ s" ) ; if ( p_@@ type@@ _@@ s . equals ( "@@ class@@ " ) ) { p@@ _type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Class ; } else if ( p_@@ type@@ _@@ s . equals ( "id" ) ) { p@@ _type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Id ; } else if ( p_@@ type@@ _@@ s . equals ( "@@ int@@ " ) ) { p@@ _type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Int ; } Template@@ Parameter p = new Template@@ Parameter ( p@@ _type , p@@ _name , p@@ _d@@ fl@@ t , p_@@ ext ) ; if ( p_@@ res@@ tr != null && ! p_@@ res@@ tr . trim ( ) . equals ( "" ) ) { String res@@ tr [ ] = p_@@ res@@ tr . split ( "," ) ; for ( String r : res@@ tr ) { r = r . trim ( ) ; p . add@@ Value ( r ) ; } } t . add@@ Parameter ( p ) ; } } f@@ Template@@ s . add ( t ) ; } private Error@@ Handler f@@ Error@@ Handler = new Error@@ Handler ( ) { public void error ( SAX@@ ParseException arg0 ) throws SAXException { throw arg0 ; } public void f@@ at@@ al@@ Error ( SAX@@ ParseException arg0 ) throws SAXException { throw arg0 ; } public void warn@@ ing ( SAX@@ ParseException arg0 ) throws SAXException { } } ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; public class F@@ S@@ In@@ Stream@@ Provider implements IT@@ emp@@ late@@ In@@ Stream@@ Provider { public InputStream open@@ Stream ( String path ) { File file = new File ( path ) ; InputStream in = null ; try { in = new FileInputStream ( file ) ; } catch ( IOException e ) { } return in ; } public void close@@ Stream ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . log . LogFactory ; import org . eclipse . core . resources . I@@ Container ; import org . eclipse . core . resources . I@@ File ; import org . eclipse . core . resources . I@@ Resource ; import org . eclipse . core . resources . I@@ Work@@ space@@ Root ; import org . eclipse . core . resources . Resources@@ Plugin ; import org . eclipse . core . runtime . Core@@ Exception ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; import org . eclipse . core . runtime . Path ; public class WS@@ External@@ Template@@ Finder extends Abstract@@ External@@ Template@@ Finder { private I@@ Container f@@ Path ; public WS@@ External@@ Template@@ Finder ( I@@ Container path ) { super ( new WS@@ In@@ Stream@@ Provider ( ) ) ; f@@ Path = path ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; } @ Override protected List < String > find@@ Template@@ Paths ( ) { List < String > template@@ s = new ArrayList < String > ( ) ; find@@ Template@@ Paths ( template@@ s , f@@ Path ) ; return template@@ s ; } private void find@@ Template@@ Paths ( List < String > template@@ s , I@@ Container parent ) { I@@ Resource resources [ ] = null ; try { resources = parent . mem@@ bers ( ) ; } catch ( Core@@ Exception e ) { } if ( resources != null ) { for ( I@@ Resource r : resources ) { if ( r instanceof I@@ File && r . getName ( ) . endsWith ( ".@@ sv@@ t" ) ) { template@@ s . add ( ( ( I@@ File ) r ) . getFull@@ Path ( ) . to@@ O@@ S@@ String ( ) ) ; } else if ( r instanceof I@@ Container ) { find@@ Template@@ Paths ( template@@ s , ( I@@ Container ) r ) ; } } } } @ Override protected List < String > list@@ Files ( String path ) { List < String > files = new ArrayList < String > ( ) ; I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ Container c = null ; try { c = root . get@@ Folder ( new Path ( path ) ) ; } catch ( IllegalArgumentException e ) { } if ( c == null ) { if ( path . startsWith ( "/" ) ) { String p@@ name = path . substring ( 1 ) ; try { c = root . get@@ Project ( p@@ name ) ; } catch ( IllegalArgumentException e ) { } } } if ( c != null ) { I@@ Resource resources [ ] = null ; try { resources = c . mem@@ bers ( ) ; } catch ( Core@@ Exception e ) { } if ( resources != null ) { for ( I@@ Resource r : resources ) { if ( r instanceof I@@ File ) { files . add ( ( ( I@@ File ) r ) . getFull@@ Path ( ) . to@@ O@@ S@@ String ( ) ) ; } } } } return files ; } @ Override protected InputStream open@@ File ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; InputStream in = null ; I@@ File file = root . getFile ( new Path ( path ) ) ; if ( file . exists ( ) ) { for ( int i = 0 ; i < 2 ; i ++ ) { try { in = file . get@@ Contents ( ) ; break ; } catch ( Core@@ Exception e ) { f@@ Log . error ( "" + path + "\@@ ": " + e . getMessage ( ) , e ) ; if ( e . getMessage ( ) . contains ( "@@ out of syn@@ c" ) ) { try { file . getParent ( ) . refresh@@ Local ( I@@ Resource . DE@@ P@@ TH_@@ INF@@ IN@@ ITE , new Null@@ ProgressMonitor ( ) ) ; } catch ( Core@@ Exception e2 ) { } } } } } else { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "@@ File \"" + path + "" ) ; } return in ; } @ Override protected void close@@ Stream ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . IOException ; import java . io . InputStream ; import org . eclipse . core . resources . I@@ File ; import org . eclipse . core . resources . I@@ Work@@ space@@ Root ; import org . eclipse . core . resources . Resources@@ Plugin ; import org . eclipse . core . runtime . Core@@ Exception ; import org . eclipse . core . runtime . Path ; public class WS@@ In@@ Stream@@ Provider implements IT@@ emp@@ late@@ In@@ Stream@@ Provider { public InputStream open@@ Stream ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; InputStream in = null ; try { I@@ File file = root . getFile ( new Path ( path ) ) ; if ( file . exists ( ) ) { in = file . get@@ Contents ( ) ; } } catch ( Core@@ Exception e ) { } return in ; } public void close@@ Stream ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Set ; public class Dynamic@@ Template@@ Parameter@@ Provider implements IT@@ emp@@ late@@ Parameter@@ Provider { public boolean pro@@ vi@@ des@@ Parameter ( String id ) { return ( id . equals ( "@@ date@@ " ) || id . equals ( "user@@ " ) ) ; } public String getParameter@@ Value ( String id , String arg ) { if ( id . equals ( "user@@ " ) ) { return System . getProperty ( "user@@ .@@ name" ) ; } else if ( id . equals ( "@@ date@@ " ) ) { SimpleDateFormat format ; if ( arg != null ) { format = new SimpleDateFormat ( arg ) ; } else { format = new SimpleDateFormat ( "M@@ M@@ /@@ dd@@ /@@ Y@@ Y@@ Y@@ Y@@ " ) ; } return format . format ( new Date ( ) ) ; } else { return null ; } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . Tuple ; import net . sf . sv@@ editor . core . log . LogFactory ; import org . eclipse . core . runtime . I@@ Configuration@@ Element ; import org . eclipse . core . runtime . I@@ Extension ; import org . eclipse . core . runtime . I@@ Extension@@ Point ; import org . eclipse . core . runtime . I@@ Extension@@ Registry ; import org . eclipse . core . runtime . P@@ latform ; import org . osgi . framework . Bundle ; public class Extension@@ Template@@ Finder extends Abstract@@ Template@@ Finder { public Extension@@ Template@@ Finder ( ) { super ( ) ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; } public void find ( ) { I@@ Extension@@ Registry ext@@ _r@@ g@@ y = P@@ latform . get@@ Extension@@ Registry ( ) ; I@@ Extension@@ Point ext@@ _p@@ t = ext@@ _r@@ g@@ y . get@@ Extension@@ Point ( SV@@ Core@@ Plugin . PL@@ UG@@ IN_@@ ID , "S@@ V@@ Temp@@ lat@@ es" ) ; I@@ Extension ext@@ _@@ list [ ] = ext@@ _p@@ t . get@@ Exten@@ sions ( ) ; for ( I@@ Extension ext : ext@@ _@@ list ) { I@@ Configuration@@ Element ce@@ _@@ l [ ] = ext . get@@ Configuration@@ Elements ( ) ; for ( I@@ Configuration@@ Element ce : ce@@ _@@ l ) { String name = ce . getName ( ) ; if ( name . equals ( "c@@ ateg@@ ory@@ " ) ) { add@@ Category ( ce ) ; } else if ( name . equals ( "@@ template@@ " ) ) { add@@ Template ( ce ) ; } else { f@@ Log . error ( "" + name + "\"" ) ; } } } } private void add@@ Category ( I@@ Configuration@@ Element ce ) { String id = ce . getAttribute ( "id" ) ; String name = ce . getAttribute ( "name" ) ; String parent = ce . getAttribute ( "@@ parent@@ " ) ; Template@@ Category c = new Template@@ Category ( id , name , parent ) ; for ( I@@ Configuration@@ Element ci : ce . getChildren ( ) ) { if ( ci . getName ( ) . equals ( "@@ descrip@@ tion" ) ) { c . setDescription ( ci . getValue ( ) ) ; } } f@@ Categ@@ ories . add ( c ) ; } private void add@@ Template ( I@@ Configuration@@ Element ce ) { String id = ce . getAttribute ( "id" ) ; String name = ce . getAttribute ( "name" ) ; String category = ce . getAttribute ( "c@@ ateg@@ ory@@ " ) ; String description = "" ; Bundle bundle = P@@ latform . get@@ Bundle ( ce . get@@ Con@@ tribut@@ or ( ) . getName ( ) ) ; for ( I@@ Configuration@@ Element ce@@ _@@ c : ce . getChildren ( ) ) { if ( ce@@ _@@ c . getName ( ) . equals ( "@@ descrip@@ tion" ) ) { description = ce@@ _@@ c . getValue ( ) ; } } Template@@ Info info = new Template@@ Info ( id , name , category , description , new Plugin@@ In@@ Stream@@ Provider ( bundle ) ) ; f@@ Template@@ s . add ( info ) ; for ( I@@ Configuration@@ Element ce@@ _@@ c : ce . getChildren ( ) ) { if ( ce@@ _@@ c . getName ( ) . equals ( "@@ fil@@ es" ) ) { for ( I@@ Configuration@@ Element tmp@@ l : ce@@ _@@ c . getChildren ( ) ) { String template = tmp@@ l . getAttribute ( "@@ template@@ " ) ; String tmp@@ l@@ _name = tmp@@ l . getAttribute ( "name" ) ; info . add@@ Template ( new Tuple < String , String > ( template , tmp@@ l@@ _name ) ) ; } } else if ( ce@@ _@@ c . getName ( ) . equals ( "parameter@@ s" ) ) { for ( I@@ Configuration@@ Element p : ce@@ _@@ c . getChildren ( ) ) { if ( p . getName ( ) . equals ( "parameter@@ " ) ) { String p@@ _type = p . getAttribute ( "type" ) ; String p@@ _name = p . getAttribute ( "name" ) ; String p@@ _d@@ fl@@ t = p . getAttribute ( "@@ default@@ " ) ; String p_@@ ext@@ _f@@ rom = p . getAttribute ( "@@ ext@@ end@@ s_@@ from@@ " ) ; String p_@@ res@@ tr = p . getAttribute ( "@@ res@@ tr@@ iction@@ s" ) ; Template@@ Parameter@@ Type type = null ; if ( p@@ _type . equals ( "@@ int@@ " ) ) { type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Int ; } else if ( p@@ _type . equals ( "id" ) ) { type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Id ; } else if ( p@@ _type . equals ( "@@ class@@ " ) ) { type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Class ; } else { f@@ Log . error ( "" + p@@ _type + "\"" ) ; continue ; } Template@@ Parameter tp = new Template@@ Parameter ( type , p@@ _name , p@@ _d@@ fl@@ t , p_@@ ext@@ _f@@ rom ) ; if ( p_@@ res@@ tr != null && ! p_@@ res@@ tr . trim ( ) . equals ( "" ) ) { String r [ ] = p_@@ res@@ tr . split ( "," ) ; for ( String rs : r ) { rs = rs . trim ( ) ; if ( ! rs . equals ( "" ) ) { tp . add@@ Value ( rs ) ; } } } info . add@@ Parameter ( tp ) ; } } } } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import net . sf . sv@@ editor . core . Tuple ; public class Template@@ Info { private String f@@ Id ; private String f@@ Name ; private String f@@ Category@@ Id ; private String f@@ Description ; private List < Tuple < String , String > > f@@ Template@@ List ; private List < Template@@ Parameter > f@@ Parameters ; private IT@@ emp@@ late@@ In@@ Stream@@ Provider f@@ Stream@@ Provider ; public Template@@ Info ( String id , String name , String category@@ _id , String description , IT@@ emp@@ late@@ In@@ Stream@@ Provider stream@@ _@@ provider ) { f@@ Id = id ; f@@ Name = name ; f@@ Category@@ Id = ( category@@ _id != null ) ? category@@ _id : "" ; f@@ Description = description ; f@@ Template@@ List = new ArrayList < Tuple < String , String > > ( ) ; f@@ Parameters = new ArrayList < Template@@ Parameter > ( ) ; f@@ Stream@@ Provider = stream@@ _@@ provider ; } public String getId ( ) { return f@@ Id ; } public String getName ( ) { return f@@ Name ; } public String getC@@ ateg@@ ory@@ Id ( ) { return f@@ Category@@ Id ; } public void set@@ Category@@ Id ( String id ) { f@@ Category@@ Id = id ; } public void setDescription ( String description ) { f@@ Description = description ; } public String getDescription ( ) { return f@@ Description ; } public Iterable < Tuple < String , String > > get@@ Template@@ s ( ) { return new Iterable < Tuple < String , String > > ( ) { public Iterator < Tuple < String , String > > iterator ( ) { return f@@ Template@@ List . iterator ( ) ; } } ; } public void add@@ Template ( String template , String filename ) { add@@ Template ( new Tuple < String , String > ( template , filename ) ) ; } public void add@@ Template ( Tuple < String , String > template ) { f@@ Template@@ List . add ( template ) ; } public void add@@ Parameter ( Template@@ Parameter p ) { f@@ Parameters . add ( p ) ; } public List < Template@@ Parameter > getParameters ( ) { return f@@ Parameters ; } public InputStream open@@ Template ( String path ) { return f@@ Stream@@ Provider . open@@ Stream ( path ) ; } public void close@@ Template ( InputStream in ) { f@@ Stream@@ Provider . close@@ Stream ( in ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . util . ArrayList ; import java . util . List ; public class Template@@ Parameter { private Template@@ Parameter@@ Type f@@ Type ; private String f@@ Name ; private String f@@ Default ; private String f@@ Value ; private String f@@ Ext@@ From ; private List < String > f@@ Values ; public Template@@ Parameter ( Template@@ Parameter@@ Type type , String name , String d@@ fl@@ t , String ext@@ _f@@ rom ) { f@@ Type = type ; f@@ Name = name ; f@@ Default = d@@ fl@@ t ; f@@ Value = d@@ fl@@ t ; f@@ Ext@@ From = ext@@ _f@@ rom ; f@@ Values = new ArrayList < String > ( ) ; } public Template@@ Parameter@@ Type getType ( ) { return f@@ Type ; } public String getType@@ Name ( ) { switch ( f@@ Type ) { case Parameter@@ Type@@ _@@ Id : { if ( f@@ Values . size ( ) == 0 ) { return "@@ identi@@ fier@@ " ; } else { return "@@ cho@@ ice@@ " ; } } case Parameter@@ Type@@ _@@ Class : return "@@ class@@ " ; case Parameter@@ Type@@ _@@ Int : return "@@ integer@@ " ; default : return "un@@ kn@@ ow@@ n" ; } } public String getName ( ) { return f@@ Name ; } public String getDefault ( ) { return f@@ Default ; } public String getValue ( ) { return f@@ Value ; } public void setValue ( String val ) { f@@ Value = val ; } public String get@@ Ext@@ From ( ) { return f@@ Ext@@ From ; } public List < String > get@@ Values ( ) { return f@@ Values ; } public void add@@ Value ( String value ) { if ( ! f@@ Values . contains ( value ) ) { f@@ Values . add ( value ) ; } } public Template@@ Parameter d@@ uplic@@ ate ( ) { Template@@ Parameter p = new Template@@ Parameter ( f@@ Type , f@@ Name , f@@ Default , f@@ Ext@@ From ) ; p . setValue ( f@@ Value ) ; for ( String v : f@@ Values ) { p . add@@ Value ( v ) ; } return p ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; public enum Template@@ Parameter@@ Type { Parameter@@ Type@@ _@@ Id , Parameter@@ Type@@ _@@ Int , Parameter@@ Type@@ _@@ Class } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . File ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import net . sf . sv@@ editor . core . SV@@ FileUtils ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import org . eclipse . core . resources . I@@ Container ; public class Template@@ Registry implements I@@ Log@@ Level { private static Log@@ Handle f@@ Log ; private List < Template@@ Category > f@@ Categ@@ ories ; private List < Template@@ Info > f@@ Template@@ s ; private Map < String , List < Template@@ Info > > f@@ Category@@ Map ; private List < I@@ External@@ Template@@ Path@@ Provider > f@@ Path@@ Pro@@ viders ; private boolean f@@ Load@@ Ext@@ Points ; static { f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; } public Template@@ Registry ( boolean load@@ _@@ ext@@ s ) { f@@ Categ@@ ories = new ArrayList < Template@@ Category > ( ) ; f@@ Template@@ s = new ArrayList < Template@@ Info > ( ) ; f@@ Category@@ Map = new HashMap < String , List < Template@@ Info > > ( ) ; f@@ Path@@ Pro@@ viders = new ArrayList < I@@ External@@ Template@@ Path@@ Provider > ( ) ; f@@ Load@@ Ext@@ Points = load@@ _@@ ext@@ s ; load@@ _@@ extensions ( ) ; } public void add@@ Path@@ Provider ( I@@ External@@ Template@@ Path@@ Provider p ) { f@@ Path@@ Pro@@ viders . add ( p ) ; } public void clear@@ Path@@ Pro@@ viders ( ) { f@@ Path@@ Pro@@ viders . clear ( ) ; } public List < Template@@ Category > getC@@ ateg@@ ories ( ) { return f@@ Categ@@ ories ; } public List < String > getC@@ ateg@@ ory@@ Names ( ) { List < String > ret = new ArrayList < String > ( ) ; for ( Template@@ Category c : f@@ Categ@@ ories ) { ret . add ( c . getName ( ) ) ; } return ret ; } public List < String > getC@@ ateg@@ ory@@ IDs ( ) { List < String > ret = new ArrayList < String > ( ) ; for ( Template@@ Category c : f@@ Categ@@ ories ) { ret . add ( c . getId ( ) ) ; } return ret ; } public List < Template@@ Info > get@@ Template@@ s ( String id ) { List < Template@@ Info > ret = new ArrayList < Template@@ Info > ( ) ; if ( id == null ) { id = "" ; } if ( f@@ Category@@ Map . containsKey ( id ) ) { ret . addAll ( f@@ Category@@ Map . get ( id ) ) ; } return ret ; } public Template@@ Info find@@ Template ( String id ) { for ( Template@@ Info info : f@@ Template@@ s ) { if ( info . getId ( ) . equals ( id ) ) { return info ; } } return null ; } public void load@@ _@@ extensions ( ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" ) ; List < Abstract@@ Template@@ Finder > template@@ _@@ find@@ ers = new ArrayList < Abstract@@ Template@@ Finder > ( ) ; f@@ Template@@ s . clear ( ) ; f@@ Categ@@ ories . clear ( ) ; f@@ Category@@ Map . clear ( ) ; if ( f@@ Load@@ Ext@@ Points ) { template@@ _@@ find@@ ers . add ( new Extension@@ Template@@ Finder ( ) ) ; } if ( f@@ Path@@ Pro@@ viders . size ( ) > 0 ) { for ( I@@ External@@ Template@@ Path@@ Provider p : f@@ Path@@ Pro@@ viders ) { for ( String path : p . get@@ External@@ Template@@ Path ( ) ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + path + "\"" ) ; if ( path . startsWith ( "" ) ) { path = path . substring ( "" . length ( ) ) ; I@@ Container c = SV@@ FileUtils . get@@ Work@@ space@@ Folder ( path ) ; template@@ _@@ find@@ ers . add ( new WS@@ External@@ Template@@ Finder ( c ) ) ; } else { template@@ _@@ find@@ ers . add ( new F@@ S@@ External@@ Template@@ Finder ( new File ( path ) ) ) ; } } } } for ( Abstract@@ Template@@ Finder f : template@@ _@@ find@@ ers ) { f . find ( ) ; List < Template@@ Info > tmp@@ l@@ _@@ list = f . get@@ Template@@ s ( ) ; List < Template@@ Category > category@@ _@@ list = f . getC@@ ateg@@ ories ( ) ; f@@ Template@@ s . addAll ( tmp@@ l@@ _@@ list ) ; for ( Template@@ Category new_@@ c : category@@ _@@ list ) { if ( ! f@@ Categ@@ ories . contains ( new_@@ c ) ) { f@@ Categ@@ ories . add ( new_@@ c ) ; } } } for ( int i = 0 ; i < f@@ Categ@@ ories . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < f@@ Categ@@ ories . size ( ) ; j ++ ) { Template@@ Category c_@@ i = f@@ Categ@@ ories . get ( i ) ; Template@@ Category c_@@ j = f@@ Categ@@ ories . get ( j ) ; if ( c_@@ j . getName ( ) . compareTo ( c_@@ i . getName ( ) ) < 0 ) { f@@ Categ@@ ories . set ( j , c_@@ i ) ; f@@ Categ@@ ories . set ( i , c_@@ j ) ; } } } for ( Template@@ Info t : f@@ Template@@ s ) { if ( t . getC@@ ateg@@ ory@@ Id ( ) == null || t . getC@@ ateg@@ ory@@ Id ( ) . trim ( ) . equals ( "" ) ) { if ( ! f@@ Category@@ Map . containsKey ( "" ) ) { Template@@ Category c = new Template@@ Category ( "" , "@@ Oth@@ er" , "" ) ; c . setDescription ( "" ) ; t . set@@ Category@@ Id ( "" ) ; } } if ( ! f@@ Category@@ Map . containsKey ( t . getC@@ ateg@@ ory@@ Id ( ) ) ) { f@@ Category@@ Map . put ( t . getC@@ ateg@@ ory@@ Id ( ) , new ArrayList < Template@@ Info > ( ) ) ; } f@@ Category@@ Map . get ( t . getC@@ ateg@@ ory@@ Id ( ) ) . add ( t ) ; } for ( Entry < String , List < Template@@ Info > > c : f@@ Category@@ Map . entrySet ( ) ) { List < Template@@ Info > t = c . getValue ( ) ; for ( int i = 0 ; i < t . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < t . size ( ) ; j ++ ) { Template@@ Info t_@@ i = t . get ( i ) ; Template@@ Info t_@@ j = t . get ( j ) ; if ( t_@@ j . getName ( ) . compareTo ( t_@@ i . getName ( ) ) < 0 ) { t . set ( i , t_@@ j ) ; t . set ( j , t_@@ i ) ; } } } } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; public class Default@@ Template@@ Parameter@@ Provider extends Template@@ Parameter@@ Provider { public static final String FILE_@@ HEA@@ DER = "file@@ _@@ header@@ " ; public static final String FILE_@@ HEADER_@@ DF@@ LT = "" + "" + "" ; public static final String FILE_@@ FO@@ O@@ TER = "file@@ _f@@ oo@@ ter@@ " ; public static final String FILE_@@ FO@@ O@@ TER_@@ DF@@ LT = "" ; public Default@@ Template@@ Parameter@@ Provider ( IT@@ emp@@ late@@ Parameter@@ Provider p ) { super ( ) ; set_@@ de@@ faults ( ) ; if ( p . pro@@ vi@@ des@@ Parameter ( FILE_@@ HEA@@ DER ) ) { set@@ Tag ( FILE_@@ HEA@@ DER , p . getParameter@@ Value ( FILE_@@ HEA@@ DER , null ) ) ; } if ( p . pro@@ vi@@ des@@ Parameter ( FILE_@@ FO@@ O@@ TER ) ) { set@@ Tag ( FILE_@@ HEA@@ DER , p . getParameter@@ Value ( FILE_@@ FO@@ O@@ TER , null ) ) ; } } private void set_@@ de@@ faults ( ) { set@@ Tag ( FILE_@@ HEA@@ DER , FILE_@@ HEADER_@@ DF@@ LT ) ; set@@ Tag ( FILE_@@ FO@@ O@@ TER , FILE_@@ FO@@ O@@ TER_@@ DF@@ LT ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; public class Template@@ Category implements Comparable < Template@@ Category > { private String f@@ Id ; private String f@@ Name ; private String f@@ Description ; private String f@@ Parent ; public Template@@ Category ( String id , String name , String parent ) { f@@ Id = id ; f@@ Name = name ; f@@ Description = "" ; f@@ Parent = parent ; } public String getId ( ) { return f@@ Id ; } public String getName ( ) { return f@@ Name ; } public String getDescription ( ) { return f@@ Description ; } public void setDescription ( String desc ) { f@@ Description = desc ; } public String getParent ( ) { return f@@ Parent ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof Template@@ Category ) { return f@@ Id . equals ( ( ( Template@@ Category ) obj ) . f@@ Id ) ; } else { return false ; } } public int compareTo ( Template@@ Category o ) { return f@@ Name . compareTo ( o . f@@ Name ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; public interface IT@@ emp@@ late@@ Parameter@@ Provider { boolean pro@@ vi@@ des@@ Parameter ( String id ) ; String getParameter@@ Value ( String id , String arg ) ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; public abstract class Abstract@@ Template@@ Finder implements I@@ Log@@ Level { protected Log@@ Handle f@@ Log ; protected List < Template@@ Info > f@@ Template@@ s ; protected List < Template@@ Category > f@@ Categ@@ ories ; public Abstract@@ Template@@ Finder ( ) { f@@ Template@@ s = new ArrayList < Template@@ Info > ( ) ; f@@ Categ@@ ories = new ArrayList < Template@@ Category > ( ) ; } public abstract void find ( ) ; public List < Template@@ Info > get@@ Template@@ s ( ) { return f@@ Template@@ s ; } public List < Template@@ Category > getC@@ ateg@@ ories ( ) { return f@@ Categ@@ ories ; } protected void add@@ Template ( Template@@ Info template ) { f@@ Template@@ s . add ( template ) ; } protected void add@@ Category ( Template@@ Category category ) { f@@ Categ@@ ories . add ( category ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . String@@ InputStream ; import net . sf . sv@@ editor . core . Tuple ; import net . sf . sv@@ editor . core . indent . IS@@ V@@ Ind@@ enter ; import net . sf . sv@@ editor . core . indent . SV@@ Ind@@ ent@@ Scanner ; import net . sf . sv@@ editor . core . scan@@ utils . Input@@ Stream@@ Text@@ Scanner ; import net . sf . sv@@ editor . core . text . Tag@@ Processor ; public class Template@@ Processor { private IT@@ emp@@ late@@ File@@ Creator f@@ Stream@@ Provider ; private static final String f@@ Default@@ File@@ Header = "" + "" + "" ; public Template@@ Processor ( IT@@ emp@@ late@@ File@@ Creator provider ) { f@@ Stream@@ Provider = provider ; } public static List < String > getOutput@@ Files ( Template@@ Info template , Tag@@ Processor pro@@ c ) { List < String > ret = new ArrayList < String > ( ) ; for ( Tuple < String , String > t : template . get@@ Template@@ s ( ) ) { String name = pro@@ c . process ( t . second ( ) ) ; ret . add ( name ) ; } return ret ; } public void process ( Template@@ Info template , Tag@@ Processor pro@@ c ) { Template@@ Parameter@@ Provider local@@ _@@ p = new Template@@ Parameter@@ Provider ( ) ; pro@@ c . add@@ Parameter@@ Provider ( local@@ _@@ p ) ; for ( Tuple < String , String > t : template . get@@ Template@@ s ( ) ) { int n@@ _@@ repl@@ ac@@ em@@ ents = 0 ; String temp@@ l = t . first ( ) ; String name = pro@@ c . process ( t . second ( ) ) ; name = name . trim ( ) ; local@@ _@@ p . set@@ Tag ( "@@ fil@@ ename@@ " , name ) ; InputStream in = template . open@@ Template ( temp@@ l ) ; ByteArrayInputStream in_@@ t = read@@ InputStream ( in ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; do { try { n@@ _@@ repl@@ ac@@ em@@ ents = pro@@ c . process ( in_@@ t , out ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } in_@@ t = new ByteArrayInputStream ( out . toByteArray ( ) ) ; out = new ByteArrayOutputStream ( ) ; } while ( n@@ _@@ repl@@ ac@@ em@@ ents > 0 ) ; InputStream in_@@ ind = null ; if ( sho@@ ul@@ d_@@ s@@ v_@@ indent ( name ) ) { SV@@ Ind@@ ent@@ Scanner scanner = new SV@@ Ind@@ ent@@ Scanner ( new Input@@ Stream@@ Text@@ Scanner ( in_@@ t , name ) ) ; IS@@ V@@ Ind@@ enter ind@@ enter = SV@@ Core@@ Plugin . getDefault ( ) . create@@ Ind@@ enter ( ) ; ind@@ enter . init ( scanner ) ; in_@@ ind = new String@@ InputStream ( ind@@ enter . indent ( ) ) ; } else { in_@@ ind = in_@@ t ; } f@@ Stream@@ Provider . create@@ File ( name , in_@@ ind ) ; template . close@@ Template ( in ) ; } pro@@ c . remove@@ Parameter@@ Provider ( local@@ _@@ p ) ; } private boolean sho@@ ul@@ d_@@ s@@ v_@@ indent ( String name ) { String ext = "" ; if ( name . lastIndexOf ( '.' ) != - 1 ) { ext = name . substring ( name . lastIndexOf ( '.' ) ) ; } List < String > ext@@ s = SV@@ Core@@ Plugin . getDefault ( ) . getDefault@@ SV@@ Ex@@ ts ( ) ; return ext@@ s . contains ( ext ) ; } private ByteArrayInputStream read@@ InputStream ( InputStream in ) { ByteArrayOutputStream bo@@ s = new ByteArrayOutputStream ( ) ; byte tmp [ ] = new byte [ 16@@ 38@@ 4 ] ; int len ; try { while ( ( len = in . read ( tmp , 0 , tmp . length ) ) > 0 ) { bo@@ s . write ( tmp , 0 , len ) ; } } catch ( IOException e ) { } return new ByteArrayInputStream ( bo@@ s . toByteArray ( ) ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class SV@@ T@@ Utils { public static boolean ensure@@ Expected@@ Sec@@ tions ( Document doc , Element s@@ v_@@ template ) { NodeList nl = s@@ v_@@ template . getChild@@ Nodes ( ) ; boolean ret = false ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; if ( n instanceof Element ) { Element e = ( Element ) n ; if ( e . getNode@@ Name ( ) . equals ( "@@ template@@ " ) ) { ret |= ensure@@ Expected@@ Template@@ Sec@@ tions ( doc , e ) ; } else if ( e . getNode@@ Name ( ) . equals ( "c@@ ateg@@ ory@@ " ) ) { ret |= ensure@@ Expected@@ Category@@ Sec@@ tions ( doc , e ) ; } } } return ret ; } private static boolean ensure@@ Expected@@ Template@@ Sec@@ tions ( Document doc , Element template ) { boolean ret = false ; ret |= add@@ Element@@ If@@ Missing ( doc , template , "@@ descrip@@ tion" ) ; ret |= add@@ Element@@ If@@ Missing ( doc , template , "parameter@@ s" ) ; ret |= add@@ Element@@ If@@ Missing ( doc , template , "@@ fil@@ es" ) ; return ret ; } private static boolean ensure@@ Expected@@ Category@@ Sec@@ tions ( Document doc , Element template ) { boolean ret = false ; ret |= add@@ Element@@ If@@ Missing ( doc , template , "@@ descrip@@ tion" ) ; return ret ; } private static boolean add@@ Element@@ If@@ Missing ( Document doc , Element e , String elem ) { NodeList nl = e . getChild@@ Nodes ( ) ; boolean found = false ; boolean ret = false ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; if ( n instanceof Element && ( ( Element ) n ) . getNode@@ Name ( ) . equals ( elem ) ) { found = true ; break ; } } if ( ! found ) { Element new_@@ e = doc . createElement ( elem ) ; e . appendChild ( new_@@ e ) ; ret = true ; } return ret ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . util . HashMap ; import java . util . Map ; public class Template@@ Parameter@@ Provider implements IT@@ emp@@ late@@ Parameter@@ Provider { private Map < String , String > f@@ Tag@@ Map ; public Template@@ Parameter@@ Provider ( ) { f@@ Tag@@ Map = new HashMap < String , String > ( ) ; } public Template@@ Parameter@@ Provider ( Map < String , String > init ) { this ( ) ; f@@ Tag@@ Map . put@@ All ( init ) ; } public Template@@ Parameter@@ Provider ( Template@@ Parameter@@ Provider init ) { this ( ) ; f@@ Tag@@ Map . put@@ All ( init . f@@ Tag@@ Map ) ; } public boolean pro@@ vi@@ des@@ Parameter ( String id ) { return f@@ Tag@@ Map . containsKey ( id ) ; } public String getParameter@@ Value ( String id , String arg ) { return get@@ Tag ( id ) ; } public void set@@ Tag ( String tag , String value ) { if ( f@@ Tag@@ Map . containsKey ( tag ) ) { f@@ Tag@@ Map . remove ( tag ) ; } f@@ Tag@@ Map . put ( tag , value ) ; } public void remove@@ Tag ( String tag ) { f@@ Tag@@ Map . remove ( tag ) ; } public boolean has@@ Tag ( String tag ) { return f@@ Tag@@ Map . containsKey ( tag ) ; } public String get@@ Tag ( String tag ) { return f@@ Tag@@ Map . get ( tag ) ; } public void append@@ Tag ( String tag , String value ) { String val ; if ( f@@ Tag@@ Map . containsKey ( tag ) ) { val = f@@ Tag@@ Map . get ( tag ) ; f@@ Tag@@ Map . remove ( tag ) ; } else { val = "" ; } val += value ; f@@ Tag@@ Map . put ( tag , val ) ; } } </s>
<s> package net . sf . sv@@ editor . core . content@@ _@@ assist ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item ; public class SV@@ CompletionPropos@@ al { private IS@@ V@@ DB@@ Item@@ Base f@@ Item ; private String f@@ Prefix ; private String f@@ Repl@@ acement ; private int f@@ Repl@@ ac@@ ement@@ Offset ; private int f@@ Repl@@ ac@@ ement@@ Length ; private SV@@ CompletionPropos@@ al@@ Type f@@ Type ; public SV@@ CompletionPropos@@ al ( IS@@ V@@ DB@@ Item@@ Base item , String prefix , int repl@@ ac@@ ement@@ Offset , int repl@@ ac@@ ement@@ Length ) { f@@ Item = item ; f@@ Prefix = prefix ; f@@ Repl@@ acement = SV@@ DB@@ Item . getName ( item ) ; f@@ Repl@@ ac@@ ement@@ Offset = repl@@ ac@@ ement@@ Offset ; f@@ Repl@@ ac@@ ement@@ Length = repl@@ ac@@ ement@@ Length ; f@@ Type = SV@@ CompletionPropos@@ al@@ Type . SV@@ Object ; } public String get@@ Prefix ( ) { return f@@ Prefix ; } public String get@@ Repl@@ acement ( ) { return f@@ Repl@@ acement ; } public void set@@ Repl@@ acement ( String repl@@ acement ) { f@@ Repl@@ acement = repl@@ acement ; } public SV@@ CompletionPropos@@ al ( String repl@@ acement , int start@@ Offset , int repl@@ ac@@ ement@@ Length ) { f@@ Repl@@ acement = repl@@ acement ; f@@ Repl@@ ac@@ ement@@ Offset = start@@ Offset ; f@@ Repl@@ ac@@ ement@@ Length = repl@@ ac@@ ement@@ Length ; f@@ Type = SV@@ CompletionPropos@@ al@@ Type . Un@@ known ; } public SV@@ CompletionPropos@@ al ( String repl@@ acement , int start@@ Offset , int repl@@ ac@@ ement@@ Length , SV@@ CompletionPropos@@ al@@ Type type ) { f@@ Repl@@ acement = repl@@ acement ; f@@ Repl@@ ac@@ ement@@ Offset = start@@ Offset ; f@@ Repl@@ ac@@ ement@@ Length = repl@@ ac@@ ement@@ Length ; f@@ Type = type ; } public IS@@ V@@ DB@@ Item@@ Base getItem ( ) { return f@@ Item ; } public SV@@ CompletionPropos@@ al@@ Type getType ( ) { return f@@ Type ; } public int get@@ Repl@@ ac@@ ement@@ Offset ( ) { return f@@ Repl@@ ac@@ ement@@ Offset ; } public int get@@ Repl@@ ac@@ ement@@ Length ( ) { return f@@ Repl@@ ac@@ ement@@ Length ; } } </s>
<s> package net . sf . sv@@ editor . core . content@@ _@@ assist ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . I@@ Field@@ Item@@ Attr ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Parent ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Named@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Scope@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Class@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Function ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Interface@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ If@@ c@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ If@@ c@@ In@@ st ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ port@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ port@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ port@@ Port@@ s@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ port@@ Simple@@ Port ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ port@@ Simple@@ Port@@ s@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Package@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Task ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ TypeInfo ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Type@@ Info@@ Enum ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; import net . sf . sv@@ editor . core . db . index . IS@@ V@@ DB@@ Index@@ Iterator ; import net . sf . sv@@ editor . core . db . index . SV@@ DB@@ Decl@@ Cache@@ Item ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ ByName ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ By@@ Name@@ In@@ Class@@ Hierarch@@ y ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ By@@ Name@@ In@@ Scop@@ es ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ By@@ Name@@ Matcher ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ Default@@ Name@@ Matcher ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ Inclu@@ ded@@ File ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ Super@@ Class ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Param@@ Port@@ Decl ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Stmt ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Typed@@ ef@@ Stmt ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Var@@ Decl@@ Item ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Var@@ Decl@@ Stmt ; import net . sf . sv@@ editor . core . db . utils . SV@@ DB@@ Search@@ Utils ; import net . sf . sv@@ editor . core . expr@@ _@@ utils . SV@@ Content@@ As@@ sist@@ Expr@@ Visitor ; import net . sf . sv@@ editor . core . expr@@ _@@ utils . SV@@ Expr@@ Context ; import net . sf . sv@@ editor . core . expr@@ _@@ utils . SV@@ Expr@@ Context . Context@@ Type ; import net . sf . sv@@ editor . core . expr@@ _@@ utils . SV@@ Expr@@ Scanner ; import net . sf . sv@@ editor . core . expr@@ _@@ utils . SV@@ Expr@@ Util@@ s@@ Parser ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import net . sf . sv@@ editor . core . parser . SV@@ ParseException ; import net . sf . sv@@ editor . core . scan@@ utils . IB@@ ID@@ I@@ Text@@ Scanner ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; public abstract class Abstract@@ Completion@@ Processor implements I@@ Log@@ Level { protected List < SV@@ CompletionPropos@@ al > f@@ CompletionPropos@@ als ; protected Log@@ Handle f@@ Log ; public Abstract@@ Completion@@ Processor ( ) { f@@ CompletionPropos@@ als = new ArrayList < SV@@ CompletionPropos@@ al > ( ) ; } protected abstract IS@@ V@@ DB@@ Index@@ Iterator getIndex@@ Iterator ( ) ; protected abstract SV@@ DB@@ File getS@@ V@@ DB@@ File ( ) ; protected void add@@ Propos@@ al ( SV@@ CompletionPropos@@ al p ) { boolean found = false ; synchronized ( f@@ CompletionPropos@@ als ) { for ( SV@@ CompletionPropos@@ al p_@@ t : f@@ CompletionPropos@@ als ) { if ( p_@@ t . equals ( p ) ) { found = true ; break ; } } if ( ! found ) { f@@ CompletionPropos@@ als . add ( p ) ; } } } public List < SV@@ CompletionPropos@@ al > get@@ CompletionPropos@@ als ( ) { return f@@ CompletionPropos@@ als ; } public void compute@@ Propos@@ als ( IB@@ ID@@ I@@ Text@@ Scanner scanner , SV@@ DB@@ File active@@ _@@ file , int lin@@ en@@ o ) { compute@@ Propos@@ als ( scanner , active@@ _@@ file , lin@@ en@@ o , - 1 ) ; } public void compute@@ Propos@@ als ( IB@@ ID@@ I@@ Text@@ Scanner scanner , SV@@ DB@@ File active@@ _@@ file , int lin@@ en@@ o , int line@@ pos ) { SV@@ Expr@@ Scanner expr@@ _@@ sc@@ an = new SV@@ Expr@@ Scanner ( ) ; synchronized ( f@@ CompletionPropos@@ als ) { f@@ CompletionPropos@@ als . clear ( ) ; } f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + active@@ _@@ file . getFile@@ Path ( ) + ":" + lin@@ en@@ o + ":" + line@@ pos ) ; IS@@ V@@ DB@@ Scope@@ Item src@@ _@@ scope = SV@@ DB@@ Search@@ Utils . find@@ Active@@ Scope ( active@@ _@@ file , lin@@ en@@ o ) ; if ( src@@ _@@ scope != null ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "@@ src@@ _@@ s@@ cop@@ e@@ : " + src@@ _@@ scope . getType ( ) + " " + SV@@ DB@@ Item . getName ( src@@ _@@ scope ) ) ; } SV@@ Expr@@ Context ctxt = expr@@ _@@ sc@@ an . extract@@ Expr@@ Context ( scanner , false ) ; f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "c@@ txt@@ : type@@ =" + ctxt . f@@ Type + " trig@@ ger@@ =" + ctxt . f@@ Trig@@ ger + " root@@ =" + ctxt . f@@ Root + " le@@ af@@ =" + ctxt . f@@ Lea@@ f + " start@@ =" + ctxt . f@@ Start ) ; if ( ctxt . f@@ Trig@@ ger != null ) { if ( ctxt . f@@ Trig@@ ger . equals ( "@@ `@@ " ) ) { find@@ M@@ ac@@ ro@@ Items ( ctxt , getIndex@@ Iterator ( ) ) ; } else if ( ctxt . f@@ Root != null && ( ctxt . f@@ Trig@@ ger . equals ( "=" ) || ctxt . f@@ Trig@@ ger . equals ( "." ) || ctxt . f@@ Trig@@ ger . equals ( ":@@ :" ) || ctxt . f@@ Trig@@ ger . equals ( ":" ) ) ) { if ( ctxt . f@@ Trig@@ ger . equals ( "." ) || ctxt . f@@ Trig@@ ger . equals ( ":@@ :" ) ) { SV@@ DB@@ Expr expr = null ; SV@@ Expr@@ Util@@ s@@ Parser parser = new SV@@ Expr@@ Util@@ s@@ Parser ( ctxt ) ; try { expr = parser . parsers ( ) . expr@@ Parser ( ) . expression ( ) ; } catch ( SV@@ ParseException e ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" , e ) ; return ; } SV@@ Content@@ As@@ sist@@ Expr@@ Visitor v = new SV@@ Content@@ As@@ sist@@ Expr@@ Visitor ( src@@ _@@ scope , SV@@ DB@@ Find@@ Default@@ Name@@ Matcher . getDefault ( ) , getIndex@@ Iterator ( ) ) ; IS@@ V@@ DB@@ Item@@ Base item = null ; if ( expr != null ) { item = v . find@@ Type@@ Item ( expr ) ; } if ( item == null ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" ) ; return ; } f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "@@ Item@@ : " + item . getType ( ) + " " + SV@@ DB@@ Item . getName ( item ) ) ; find@@ Trig@@ ger@@ ed@@ Propos@@ als ( ctxt , src@@ _@@ scope , item ) ; } else if ( ctxt . f@@ Trig@@ ger . equals ( "=" ) ) { SV@@ DB@@ Expr expr = null ; SV@@ Expr@@ Util@@ s@@ Parser parser = new SV@@ Expr@@ Util@@ s@@ Parser ( ctxt ) ; try { expr = parser . parsers ( ) . expr@@ Parser ( ) . expression ( ) ; } catch ( SV@@ ParseException e ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" , e ) ; return ; } SV@@ Content@@ As@@ sist@@ Expr@@ Visitor v = new SV@@ Content@@ As@@ sist@@ Expr@@ Visitor ( src@@ _@@ scope , SV@@ DB@@ Find@@ Default@@ Name@@ Matcher . getDefault ( ) , getIndex@@ Iterator ( ) ) ; IS@@ V@@ DB@@ Item@@ Base item = null ; if ( expr != null ) { try { item = v . find@@ Type@@ Item ( expr ) ; } catch ( RuntimeException e ) { } } if ( item == null ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" ) ; } f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "@@ Item@@ : " + ( ( item != null ) ? ( item . getType ( ) + " " + SV@@ DB@@ Item . getName ( item ) ) : "null" ) ) ; find@@ Assign@@ Trig@@ ger@@ ed@@ Propos@@ als ( ctxt , src@@ _@@ scope , item ) ; } else if ( ctxt . f@@ Trig@@ ger . equals ( ":" ) ) { if ( ctxt . f@@ Root . startsWith ( "@@ end@@ " ) ) { find@@ End@@ Label@@ Propos@@ als ( ctxt , src@@ _@@ scope ) ; } else { find@@ Un@@ trig@@ ger@@ ed@@ Propos@@ als ( ctxt , src@@ _@@ scope ) ; } } else { } } else if ( ctxt . f@@ Trig@@ ger . equals ( "." ) ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" ) ; find@@ Port@@ CompletionPropos@@ als ( ctxt , src@@ _@@ scope , lin@@ en@@ o , line@@ pos ) ; } else { } } else { find@@ Un@@ trig@@ ger@@ ed@@ Propos@@ als ( ctxt , src@@ _@@ scope ) ; } order@@ _@@ pro@@ pos@@ als ( ctxt . f@@ Lea@@ f , f@@ CompletionPropos@@ als ) ; } private void find@@ Trig@@ ger@@ ed@@ Propos@@ als ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Child@@ Item src@@ _@@ scope , IS@@ V@@ DB@@ Item@@ Base le@@ af@@ _@@ item ) { boolean stati@@ c_@@ ref = ctxt . f@@ Trig@@ ger . equals ( ":@@ :" ) ; f@@ Log . debug ( "" + le@@ af@@ _@@ item . getType ( ) ) ; if ( le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl || le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ Struct || le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Interface@@ Decl || le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Module@@ Decl ) { SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; SV@@ DB@@ Find@@ Super@@ Class super@@ _@@ fin@@ der = new SV@@ DB@@ Find@@ Super@@ Class ( getIndex@@ Iterator ( ) ) ; IS@@ V@@ DB@@ Child@@ Parent si = ( IS@@ V@@ DB@@ Child@@ Parent ) le@@ af@@ _@@ item ; while ( si != null ) { for ( IS@@ V@@ DB@@ Child@@ Item it : si . getChildren ( ) ) { if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Stmt ) { SV@@ DB@@ Var@@ Decl@@ Stmt v = ( SV@@ DB@@ Var@@ Decl@@ Stmt ) it ; if ( ( v . get@@ Attr ( ) & SV@@ DB@@ Var@@ Decl@@ Stmt . Field@@ Attr@@ _@@ Stati@@ c ) != 0 == stati@@ c_@@ ref ) { for ( IS@@ V@@ DB@@ Item@@ Base it@@ _1 : ( ( SV@@ DB@@ Var@@ Decl@@ Stmt ) it ) . getChildren ( ) ) { debug ( "" + SV@@ DB@@ Item . getName ( it@@ _1 ) ) ; if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _1 , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it@@ _1 , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } else if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) { SV@@ DB@@ Typed@@ ef@@ Stmt t@@ d_@@ stmt = ( SV@@ DB@@ Typed@@ ef@@ Stmt ) it ; if ( matcher . match ( t@@ d_@@ stmt , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( t@@ d_@@ stmt , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } if ( t@@ d_@@ stmt . getType@@ Info ( ) != null && t@@ d_@@ stmt . getType@@ Info ( ) . getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ Enum ) { SV@@ DB@@ Type@@ Info@@ Enum enum@@ _type = ( SV@@ DB@@ Type@@ Info@@ Enum ) t@@ d_@@ stmt . getType@@ Info ( ) ; for ( SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator enum@@ er@@ ator : enum@@ _type . get@@ Enum@@ er@@ ators ( ) ) { if ( matcher . match ( enum@@ er@@ ator , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( enum@@ er@@ ator , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } else if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Mod@@ port@@ Decl ) { for ( IS@@ V@@ DB@@ Item@@ Base it@@ _1 : ( ( SV@@ DB@@ Mod@@ port@@ Decl ) it ) . getChildren ( ) ) { debug ( "" + SV@@ DB@@ Item . getName ( it@@ _1 ) ) ; if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _1 , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it@@ _1 , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } else if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Mod@@ If@@ c@@ In@@ st ) { for ( IS@@ V@@ DB@@ Item@@ Base it@@ _1 : ( ( SV@@ DB@@ Mod@@ If@@ c@@ In@@ st ) it ) . getChildren ( ) ) { if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _1 , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it@@ _1 , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } else if ( it instanceof IS@@ V@@ DB@@ Named@@ Item ) { if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } if ( si . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl ) { SV@@ DB@@ Class@@ Decl cl@@ s_@@ dec@@ l = ( SV@@ DB@@ Class@@ Decl ) si ; si = super@@ _@@ fin@@ der . find ( cl@@ s_@@ dec@@ l ) ; } else { if ( si . getType ( ) . is@@ Elem@@ Of ( SV@@ DB@@ Item@@ Type . Interface@@ Decl ) ) { SV@@ DB@@ Interface@@ Decl if@@ c = ( SV@@ DB@@ Interface@@ Decl ) si ; for ( SV@@ DB@@ Param@@ Port@@ Decl p : if@@ c . getPort@@ s ( ) ) { for ( IS@@ V@@ DB@@ Item@@ Base v@@ i : p . getChildren ( ) ) { if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) v@@ i , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( v@@ i , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } si = null ; } } } else if ( le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Package@@ Decl ) { SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; if ( ! stati@@ c_@@ ref ) { f@@ Log . debug ( "" ) ; } IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it = getIndex@@ Iterator ( ) ; SV@@ DB@@ Package@@ Decl pk@@ g_@@ dec@@ l = ( SV@@ DB@@ Package@@ Decl ) le@@ af@@ _@@ item ; List < SV@@ DB@@ Decl@@ Cache@@ Item > result = index@@ _@@ it . find@@ Global@@ Scope@@ Decl ( new Null@@ ProgressMonitor ( ) , pk@@ g_@@ dec@@ l . getName ( ) , new SV@@ DB@@ Find@@ By@@ Name@@ Matcher ( SV@@ DB@@ Item@@ Type . Package@@ Decl ) ) ; if ( result . size ( ) > 0 ) { SV@@ DB@@ Decl@@ Cache@@ Item pk@@ g_@@ item = result . get ( 0 ) ; List < SV@@ DB@@ Decl@@ Cache@@ Item > pk@@ g_@@ items = index@@ _@@ it . find@@ Package@@ Decl ( new Null@@ ProgressMonitor ( ) , pk@@ g_@@ item ) ; for ( SV@@ DB@@ Decl@@ Cache@@ Item ci : pk@@ g_@@ items ) { IS@@ V@@ DB@@ Item@@ Base item = ci . getS@@ V@@ DB@@ Item ( ) ; if ( item . getType ( ) == SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) { SV@@ DB@@ Typed@@ ef@@ Stmt t@@ d_@@ stmt = ( SV@@ DB@@ Typed@@ ef@@ Stmt ) item ; if ( matcher . match ( t@@ d_@@ stmt , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( t@@ d_@@ stmt , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } if ( t@@ d_@@ stmt . getType@@ Info ( ) != null && t@@ d_@@ stmt . getType@@ Info ( ) . getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ Enum ) { SV@@ DB@@ Type@@ Info@@ Enum enum@@ _type = ( SV@@ DB@@ Type@@ Info@@ Enum ) t@@ d_@@ stmt . getType@@ Info ( ) ; for ( SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator enum@@ er@@ ator : enum@@ _type . get@@ Enum@@ er@@ ators ( ) ) { if ( matcher . match ( enum@@ er@@ ator , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( enum@@ er@@ ator , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } else if ( item instanceof IS@@ V@@ DB@@ Named@@ Item ) { IS@@ V@@ DB@@ Named@@ Item n@@ i = ( IS@@ V@@ DB@@ Named@@ Item ) item ; f@@ Log . debug ( "" + n@@ i . getName ( ) + "\"" ) ; if ( matcher . match ( n@@ i , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( item , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { f@@ Log . debug ( "" + SV@@ DB@@ Item . getName ( item ) ) ; } } } else { f@@ Log . debug ( "" + pk@@ g_@@ dec@@ l . getName ( ) + "\"" ) ; } System . out . println ( "@@ Package Decl@@ " ) ; } else if ( le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Item ) { IS@@ V@@ DB@@ Item@@ Base ite@@ m_@@ type = getItem@@ Type ( le@@ af@@ _@@ item ) ; if ( ite@@ m_@@ type != null && ite@@ m_@@ type . getType ( ) . is@@ Elem@@ Of ( SV@@ DB@@ Item@@ Type . Class@@ Decl ) ) { IS@@ V@@ DB@@ Scope@@ Item si = ( IS@@ V@@ DB@@ Scope@@ Item ) ite@@ m_@@ type ; SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; for ( IS@@ V@@ DB@@ Item@@ Base it : si . getChildren ( ) ) { if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Stmt ) { for ( IS@@ V@@ DB@@ Item@@ Base it@@ _1 : ( ( SV@@ DB@@ Var@@ Decl@@ Stmt ) it ) . getChildren ( ) ) { debug ( "" + SV@@ DB@@ Item . getName ( it@@ _1 ) ) ; if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _1 , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it@@ _1 , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } else if ( it instanceof IS@@ V@@ DB@@ Named@@ Item ) { if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } } else if ( le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Mod@@ port@@ Item ) { SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; SV@@ DB@@ Mod@@ port@@ Item mp@@ i = ( SV@@ DB@@ Mod@@ port@@ Item ) le@@ af@@ _@@ item ; for ( SV@@ DB@@ Mod@@ port@@ Port@@ s@@ Decl p@@ d : mp@@ i . getPort@@ sList ( ) ) { if ( p@@ d . getType ( ) == SV@@ DB@@ Item@@ Type . Mod@@ port@@ Simple@@ Port@@ s@@ Decl ) { SV@@ DB@@ Mod@@ port@@ Simple@@ Port@@ s@@ Decl simple@@ _p@@ d = ( SV@@ DB@@ Mod@@ port@@ Simple@@ Port@@ s@@ Decl ) p@@ d ; for ( SV@@ DB@@ Mod@@ port@@ Simple@@ Port p : simple@@ _p@@ d . getPort@@ List ( ) ) { if ( matcher . match ( p , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( p , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } else { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + p@@ d . getType ( ) ) ; } } } } private void find@@ Assign@@ Trig@@ ger@@ ed@@ Propos@@ als ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Child@@ Item src@@ _@@ scope , IS@@ V@@ DB@@ Item@@ Base item ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\"" ) ; List < IS@@ V@@ DB@@ Item@@ Base > result = new ArrayList < IS@@ V@@ DB@@ Item@@ Base > ( ) ; List < IS@@ V@@ DB@@ Item@@ Base > tmp = null ; SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; SV@@ DB@@ Find@@ By@@ Name@@ In@@ Scop@@ es fin@@ der@@ _@@ s = new SV@@ DB@@ Find@@ By@@ Name@@ In@@ Scop@@ es ( getIndex@@ Iterator ( ) , matcher ) ; tmp = fin@@ der@@ _@@ s . find ( src@@ _@@ scope , ctxt . f@@ Lea@@ f , false ) ; result . addAll ( tmp ) ; SV@@ DB@@ Find@@ By@@ Name@@ In@@ Class@@ Hierarch@@ y fin@@ der@@ _@@ h = new SV@@ DB@@ Find@@ By@@ Name@@ In@@ Class@@ Hierarch@@ y ( getIndex@@ Iterator ( ) , matcher ) ; tmp = fin@@ der@@ _@@ h . find ( src@@ _@@ scope , ctxt . f@@ Lea@@ f ) ; result . addAll ( tmp ) ; if ( result . size ( ) > 0 ) { for ( int i = 0 ; i < result . size ( ) ; i ++ ) { boolean add = true ; if ( result . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Function && ( ( IS@@ V@@ DB@@ Named@@ Item ) result . get ( i ) ) . getName ( ) . equals ( "@@ new@@ " ) ) { add = false ; } if ( add ) { add@@ Propos@@ al ( result . get ( i ) , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c fin@@ der@@ _c@@ ls = new SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c ( getIndex@@ Iterator ( ) , matcher ) ; List < IS@@ V@@ DB@@ Child@@ Item > cl@@ _@@ l = fin@@ der@@ _c@@ ls . find ( ctxt . f@@ Lea@@ f ) ; if ( cl@@ _@@ l . size ( ) > 0 ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\" retur@@ ned " + cl@@ _@@ l . size ( ) ) ; for ( IS@@ V@@ DB@@ Child@@ Item cl : cl@@ _@@ l ) { f@@ Log . debug ( " " + cl . getType ( ) + " " + SV@@ DB@@ Item . getName ( cl ) ) ; } for ( IS@@ V@@ DB@@ Item@@ Base it : cl@@ _@@ l ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "" ) ; } SV@@ DB@@ Find@@ ByName fin@@ der@@ _@@ t@@ f = new SV@@ DB@@ Find@@ ByName ( getIndex@@ Iterator ( ) , matcher ) ; List < IS@@ V@@ DB@@ Item@@ Base > it@@ _@@ l = fin@@ der@@ _@@ t@@ f . find ( ctxt . f@@ Lea@@ f ) ; for ( int i = 0 ; i < it@@ _@@ l . size ( ) ; i ++ ) { if ( it@@ _@@ l . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Function || it@@ _@@ l . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Task ) { SV@@ DB@@ Task t@@ f = ( SV@@ DB@@ Task ) it@@ _@@ l . get ( i ) ; if ( ( t@@ f . get@@ Attr ( ) & I@@ Field@@ Item@@ Attr . Field@@ Attr@@ _@@ Ex@@ tern ) == 0 && t@@ f . getName ( ) . contains ( ":@@ :" ) ) { it@@ _@@ l . remove ( i ) ; i -- ; } IS@@ V@@ DB@@ Item@@ Base s@@ cop@@ e_@@ t = t@@ f ; while ( s@@ cop@@ e_@@ t != null && s@@ cop@@ e_@@ t . getType ( ) != SV@@ DB@@ Item@@ Type . Class@@ Decl && s@@ cop@@ e_@@ t . getType ( ) != SV@@ DB@@ Item@@ Type . Module@@ Decl ) { s@@ cop@@ e_@@ t = ( ( IS@@ V@@ DB@@ Child@@ Item ) s@@ cop@@ e_@@ t ) . getParent ( ) ; } if ( s@@ cop@@ e_@@ t != null && ( s@@ cop@@ e_@@ t . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl || s@@ cop@@ e_@@ t . getType ( ) == SV@@ DB@@ Item@@ Type . Module@@ Decl ) ) { it@@ _@@ l . remove ( i ) ; i -- ; } } } if ( it@@ _@@ l != null && it@@ _@@ l . size ( ) > 0 ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\" retur@@ ned@@ :" ) ; for ( IS@@ V@@ DB@@ Item@@ Base it : it@@ _@@ l ) { f@@ Log . debug ( " " + it . getType ( ) + " " + ( ( IS@@ V@@ DB@@ Named@@ Item ) it ) . getName ( ) ) ; } for ( IS@@ V@@ DB@@ Item@@ Base it : it@@ _@@ l ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "" ) ; } f@@ Log . debug ( "" + ( ( item != null ) ? item . getType ( ) : "null" ) ) ; if ( item != null && ( item . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl ) && ( "@@ new@@ " . startsWith ( ctxt . f@@ Lea@@ f ) || ctxt . f@@ Lea@@ f . equals ( "" ) ) ) { SV@@ DB@@ Class@@ Decl cls = ( SV@@ DB@@ Class@@ Decl ) item ; f@@ Log . debug ( "" + SV@@ DB@@ Item . getName ( item ) ) ; for ( IS@@ V@@ DB@@ Child@@ Item c : cls . getChildren ( ) ) { if ( c . getType ( ) == SV@@ DB@@ Item@@ Type . Function ) { SV@@ DB@@ Function f = ( SV@@ DB@@ Function ) c ; if ( f . getName ( ) . equals ( "@@ new@@ " ) ) { add@@ Propos@@ al ( c , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } } private void find@@ Port@@ CompletionPropos@@ als ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Child@@ Parent src@@ _@@ scope , int lin@@ en@@ o , int line@@ pos ) { f@@ Log . debug ( "" ) ; SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; f@@ Log . debug ( "1" ) ; if ( src@@ _@@ scope == null || ( src@@ _@@ scope . getType ( ) != SV@@ DB@@ Item@@ Type . Module@@ Decl && src@@ _@@ scope . getType ( ) != SV@@ DB@@ Item@@ Type . Interface@@ Decl ) ) { f@@ Log . debug ( "" + src@@ _@@ scope + ")" ) ; return ; } f@@ Log . debug ( "2" ) ; SV@@ DB@@ Mod@@ If@@ c@@ In@@ st inst = find@@ In@@ st ( src@@ _@@ scope , lin@@ en@@ o , line@@ pos ) ; f@@ Log . debug ( "@@ 3" ) ; if ( inst == null ) { f@@ Log . debug ( "" ) ; return ; } f@@ Log . debug ( "@@ 4" ) ; f@@ Log . debug ( "" + inst . getType@@ Name ( ) ) ; SV@@ DB@@ Mod@@ If@@ c@@ Decl dec@@ l ; SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c fin@@ der = new SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c ( getIndex@@ Iterator ( ) ) ; List < IS@@ V@@ DB@@ Child@@ Item > result = fin@@ der . find ( inst . getType@@ Name ( ) ) ; if ( result . size ( ) > 0 && ( result . get ( 0 ) . getType ( ) == SV@@ DB@@ Item@@ Type . Module@@ Decl || result . get ( 0 ) . getType ( ) == SV@@ DB@@ Item@@ Type . Interface@@ Decl ) ) { dec@@ l = ( SV@@ DB@@ Mod@@ If@@ c@@ Decl ) result . get ( 0 ) ; } else { f@@ Log . debug ( "" + inst . getType@@ Name ( ) + "\"" ) ; return ; } for ( SV@@ DB@@ Param@@ Port@@ Decl p : dec@@ l . getPort@@ s ( ) ) { for ( IS@@ V@@ DB@@ Child@@ Item pi : p . getChildren ( ) ) { if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) pi , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( pi , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } f@@ Log . debug ( "" ) ; } private SV@@ DB@@ Mod@@ If@@ c@@ In@@ st find@@ In@@ st ( IS@@ V@@ DB@@ Child@@ Parent p , int lin@@ en@@ o , int line@@ pos ) { SV@@ DB@@ Mod@@ If@@ c@@ In@@ st last@@ _@@ inst = null ; for ( IS@@ V@@ DB@@ Child@@ Item c : p . getChildren ( ) ) { if ( c . getType ( ) == SV@@ DB@@ Item@@ Type . Mod@@ If@@ c@@ In@@ st ) { last@@ _@@ inst = ( SV@@ DB@@ Mod@@ If@@ c@@ In@@ st ) c ; if ( c . getLocation ( ) . getL@@ ine ( ) > lin@@ en@@ o ) { break ; } } else if ( c instanceof IS@@ V@@ DB@@ Child@@ Parent ) { if ( c . getLocation ( ) != null && c . getLocation ( ) . getL@@ ine ( ) > lin@@ en@@ o ) { break ; } if ( ( last@@ _@@ inst = find@@ In@@ st ( ( IS@@ V@@ DB@@ Child@@ Parent ) c , lin@@ en@@ o , line@@ pos ) ) != null ) { break ; } } } return last@@ _@@ inst ; } private void find@@ End@@ Label@@ Propos@@ als ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Child@@ Item src@@ _@@ scope ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\"" ) ; f@@ Log . debug ( "" + SV@@ DB@@ Item . getName ( src@@ _@@ scope ) ) ; if ( src@@ _@@ scope == null || ! ( src@@ _@@ scope instanceof IS@@ V@@ DB@@ Named@@ Item ) ) { return ; } IS@@ V@@ DB@@ Named@@ Item item = ( IS@@ V@@ DB@@ Named@@ Item ) src@@ _@@ scope ; if ( ctxt . f@@ Lea@@ f . equals ( "" ) || item . getName ( ) . startsWith ( ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( new SV@@ CompletionPropos@@ al ( ( ( IS@@ V@@ DB@@ Named@@ Item ) src@@ _@@ scope ) . getName ( ) , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ) ; } else { find@@ Un@@ trig@@ ger@@ ed@@ Propos@@ als ( ctxt , src@@ _@@ scope ) ; } } private void find@@ Un@@ trig@@ ger@@ ed@@ Propos@@ als ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Child@@ Item src@@ _@@ scope ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\"" ) ; List < IS@@ V@@ DB@@ Item@@ Base > result = null ; SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; SV@@ DB@@ Find@@ By@@ Name@@ In@@ Scop@@ es fin@@ der@@ _@@ s = new SV@@ DB@@ Find@@ By@@ Name@@ In@@ Scop@@ es ( getIndex@@ Iterator ( ) , matcher ) ; f@@ Log . debug ( "" ) ; result = fin@@ der@@ _@@ s . find ( src@@ _@@ scope , ctxt . f@@ Lea@@ f , false ) ; f@@ Log . debug ( " " + result . size ( ) + " result@@ s" ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { if ( ! ( SV@@ DB@@ Item . getName ( result . get ( i ) ) . equals ( ctxt . f@@ Lea@@ f ) && is@@ Same@@ Scope@@ Var@@ Decl ( src@@ _@@ scope , result . get ( i ) ) ) ) { add@@ Propos@@ al ( result . get ( i ) , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } SV@@ DB@@ Find@@ By@@ Name@@ In@@ Class@@ Hierarch@@ y fin@@ der@@ _@@ h = new SV@@ DB@@ Find@@ By@@ Name@@ In@@ Class@@ Hierarch@@ y ( getIndex@@ Iterator ( ) , matcher ) ; result = fin@@ der@@ _@@ h . find ( src@@ _@@ scope , ctxt . f@@ Lea@@ f ) ; if ( result . size ( ) > 0 ) { for ( int i = 0 ; i < result . size ( ) ; i ++ ) { boolean add = true ; if ( ctxt . f@@ Trig@@ ger != null && ctxt . f@@ Trig@@ ger . equals ( "=" ) && "@@ new@@ " . startsWith ( ctxt . f@@ Lea@@ f ) ) { if ( result . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Function && ( ( IS@@ V@@ DB@@ Named@@ Item ) result . get ( i ) ) . getName ( ) . equals ( "@@ new@@ " ) ) { add = false ; } } if ( ctxt . f@@ Type == Context@@ Type . Ext@@ ends ) { f@@ Log . debug ( "@@ Ext@@ end@@ s@@ : " + result . get ( i ) . getType ( ) ) ; if ( result . get ( i ) . getType ( ) != SV@@ DB@@ Item@@ Type . Class@@ Decl ) { add = false ; } } if ( add ) { add@@ Propos@@ al ( result . get ( i ) , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c fin@@ der@@ _c@@ ls = new SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c ( getIndex@@ Iterator ( ) , matcher ) ; List < IS@@ V@@ DB@@ Child@@ Item > cl@@ _@@ l = fin@@ der@@ _c@@ ls . find ( ctxt . f@@ Lea@@ f ) ; if ( cl@@ _@@ l . size ( ) > 0 ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\" retur@@ ned " + cl@@ _@@ l . size ( ) ) ; for ( IS@@ V@@ DB@@ Child@@ Item cl : cl@@ _@@ l ) { f@@ Log . debug ( " " + cl . getType ( ) + " " + SV@@ DB@@ Item . getName ( cl ) ) ; } for ( IS@@ V@@ DB@@ Item@@ Base it : cl@@ _@@ l ) { if ( ctxt . f@@ Type == Context@@ Type . Ext@@ ends ) { if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } else { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "" ) ; } if ( ctxt . f@@ Type != Context@@ Type . Ext@@ ends ) { SV@@ DB@@ Find@@ ByName fin@@ der@@ _@@ t@@ f = new SV@@ DB@@ Find@@ ByName ( getIndex@@ Iterator ( ) , matcher ) ; List < IS@@ V@@ DB@@ Item@@ Base > it@@ _@@ l = fin@@ der@@ _@@ t@@ f . find ( ctxt . f@@ Lea@@ f , SV@@ DB@@ Item@@ Type . Task , SV@@ DB@@ Item@@ Type . Function , SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Stmt , SV@@ DB@@ Item@@ Type . Package@@ Decl , SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) ; for ( int i = 0 ; i < it@@ _@@ l . size ( ) ; i ++ ) { if ( it@@ _@@ l . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Function || it@@ _@@ l . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Task ) { SV@@ DB@@ Task t@@ f = ( SV@@ DB@@ Task ) it@@ _@@ l . get ( i ) ; if ( ( t@@ f . get@@ Attr ( ) & I@@ Field@@ Item@@ Attr . Field@@ Attr@@ _@@ Ex@@ tern ) == 0 && t@@ f . getName ( ) . contains ( ":@@ :" ) ) { it@@ _@@ l . remove ( i ) ; i -- ; } IS@@ V@@ DB@@ Item@@ Base s@@ cop@@ e_@@ t = t@@ f ; while ( s@@ cop@@ e_@@ t != null && s@@ cop@@ e_@@ t . getType ( ) != SV@@ DB@@ Item@@ Type . Class@@ Decl && s@@ cop@@ e_@@ t . getType ( ) != SV@@ DB@@ Item@@ Type . Module@@ Decl ) { s@@ cop@@ e_@@ t = ( ( IS@@ V@@ DB@@ Child@@ Item ) s@@ cop@@ e_@@ t ) . getParent ( ) ; } if ( s@@ cop@@ e_@@ t != null && ( s@@ cop@@ e_@@ t . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl || s@@ cop@@ e_@@ t . getType ( ) == SV@@ DB@@ Item@@ Type . Module@@ Decl ) ) { it@@ _@@ l . remove ( i ) ; i -- ; } } } if ( it@@ _@@ l != null && it@@ _@@ l . size ( ) > 0 ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\" retur@@ ned@@ :" ) ; for ( IS@@ V@@ DB@@ Item@@ Base it : it@@ _@@ l ) { f@@ Log . debug ( " " + it . getType ( ) + " " + ( ( IS@@ V@@ DB@@ Named@@ Item ) it ) . getName ( ) ) ; } for ( IS@@ V@@ DB@@ Item@@ Base it : it@@ _@@ l ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "" ) ; } } } private boolean is@@ Same@@ Scope@@ Var@@ Decl ( IS@@ V@@ DB@@ Child@@ Item src@@ _@@ scope , IS@@ V@@ DB@@ Item@@ Base pro@@ pos@@ al ) { if ( pro@@ pos@@ al instanceof SV@@ DB@@ Var@@ Decl@@ Item ) { SV@@ DB@@ Var@@ Decl@@ Item v = ( SV@@ DB@@ Var@@ Decl@@ Item ) pro@@ pos@@ al ; if ( v . getParent ( ) != null && v . getParent ( ) . getParent ( ) != null ) { return ( v . getParent ( ) . getParent ( ) == src@@ _@@ scope ) ; } } return false ; } private void find@@ M@@ ac@@ ro@@ Items ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it ) { SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; if ( ctxt . f@@ Root != null && ctxt . f@@ Root . equals ( "@@ include@@ " ) ) { SV@@ DB@@ Find@@ Inclu@@ ded@@ File fin@@ der = new SV@@ DB@@ Find@@ Inclu@@ ded@@ File ( index@@ _@@ it , matcher ) ; List < SV@@ DB@@ File > it@@ _@@ l = fin@@ der . find ( ctxt . f@@ Lea@@ f ) ; if ( it@@ _@@ l . size ( ) > 0 ) { add@@ Propos@@ al ( it@@ _@@ l . get ( 0 ) , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { List < SV@@ DB@@ Decl@@ Cache@@ Item > result = index@@ _@@ it . find@@ Global@@ Scope@@ Decl ( new Null@@ ProgressMonitor ( ) , ctxt . f@@ Lea@@ f , new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( SV@@ DB@@ Item@@ Type . M@@ ac@@ ro@@ Def ) ) ; for ( SV@@ DB@@ Decl@@ Cache@@ Item i : result ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "M@@ ac@@ ro@@ : " + i . getName ( ) ) ; add@@ Propos@@ al ( i . getS@@ V@@ DB@@ Item ( ) , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } private IS@@ V@@ DB@@ Item@@ Base getItem@@ Type ( IS@@ V@@ DB@@ Item@@ Base item ) { SV@@ DB@@ TypeInfo t@@ i = null ; if ( item . getType ( ) == SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Stmt ) { t@@ i = ( ( SV@@ DB@@ Var@@ Decl@@ Stmt ) item ) . getType@@ Info ( ) ; } else if ( item . getType ( ) == SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Item ) { SV@@ DB@@ Var@@ Decl@@ Item v@@ i = ( SV@@ DB@@ Var@@ Decl@@ Item ) item ; if ( v@@ i . getParent ( ) != null ) { t@@ i = v@@ i . getParent ( ) . getType@@ Info ( ) ; } } if ( t@@ i != null ) { IS@@ V@@ DB@@ Item@@ Base target = resolve@@ Type ( t@@ i ) ; if ( target != null ) { return target ; } } return t@@ i ; } private IS@@ V@@ DB@@ Item@@ Base resolve@@ Type ( SV@@ DB@@ TypeInfo t@@ i ) { IS@@ V@@ DB@@ Item@@ Base target = null ; if ( t@@ i . getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ User@@ Def ) { SV@@ DB@@ Find@@ ByName fin@@ der = new SV@@ DB@@ Find@@ ByName ( getIndex@@ Iterator ( ) ) ; List < IS@@ V@@ DB@@ Item@@ Base > ret = fin@@ der . find ( t@@ i . getName ( ) ) ; if ( ret . size ( ) > 0 ) { target = ret . get ( 0 ) ; } } else if ( t@@ i . getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ Struct ) { } else { } if ( target != null ) { if ( target . getType ( ) == SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) { target = resolve@@ Type ( ( ( SV@@ DB@@ Typed@@ ef@@ Stmt ) target ) . getType@@ Info ( ) ) ; } } return target ; } protected boolean is@@ Prefix ( String pr@@ e , SV@@ DB@@ Item it ) { return it . getName ( ) . toLowerCase ( ) . startsWith ( pr@@ e . toLowerCase ( ) ) ; } private void order@@ _@@ pro@@ pos@@ als ( String prefix , List < SV@@ CompletionPropos@@ al > pro@@ pos@@ als ) { synchronized ( pro@@ pos@@ als ) { for ( int i = 0 ; i < pro@@ pos@@ als . size ( ) ; i ++ ) { SV@@ CompletionPropos@@ al p = pro@@ pos@@ als . get ( i ) ; if ( p . getItem ( ) != null && SV@@ DB@@ Stmt . is@@ Type ( p . getItem ( ) , SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) ) { boolean found = false ; for ( SV@@ CompletionPropos@@ al p_@@ t : pro@@ pos@@ als ) { if ( p_@@ t != p && p_@@ t . getItem ( ) != null && SV@@ DB@@ Item . getName ( p_@@ t . getItem ( ) ) . equals ( SV@@ DB@@ Item . getName ( p . getItem ( ) ) ) ) { found = true ; break ; } } if ( found ) { pro@@ pos@@ als . remove ( i ) ; i -- ; } } } for ( int i = 0 ; i < pro@@ pos@@ als . size ( ) ; i ++ ) { SV@@ CompletionPropos@@ al p_@@ i = pro@@ pos@@ als . get ( i ) ; for ( int j = i + 1 ; j < pro@@ pos@@ als . size ( ) ; j ++ ) { SV@@ CompletionPropos@@ al p_@@ j = pro@@ pos@@ als . get ( j ) ; String s_@@ i , s_@@ j ; if ( p_@@ i . getItem ( ) != null ) { s_@@ i = SV@@ DB@@ Item . getName ( p_@@ i . getItem ( ) ) ; } else { s_@@ i = p_@@ i . get@@ Repl@@ acement ( ) ; } if ( p_@@ j . getItem ( ) != null ) { s_@@ j = SV@@ DB@@ Item . getName ( p_@@ j . getItem ( ) ) ; } else { s_@@ j = p_@@ j . get@@ Repl@@ acement ( ) ; } if ( s_@@ i . compareTo ( s_@@ j ) > 0 ) { pro@@ pos@@ als . set ( i , p_@@ j ) ; pro@@ pos@@ als . set ( j , p_@@ i ) ; p_@@ i = p_@@ j ; } } } for ( int i = 0 ; i < pro@@ pos@@ als . size ( ) ; i ++ ) { SV@@ CompletionPropos@@ al p_@@ i = pro@@ pos@@ als . get ( i ) ; for ( int j = i + 1 ; j < pro@@ pos@@ als . size ( ) ; j ++ ) { SV@@ CompletionPropos@@ al p_@@ j = pro@@ pos@@ als . get ( j ) ; String s_@@ i , s_@@ j ; if ( p_@@ i . getItem ( ) != null ) { s_@@ i = SV@@ DB@@ Item . getName ( p_@@ i . getItem ( ) ) ; } else { s_@@ i = p_@@ i . get@@ Repl@@ acement ( ) ; } if ( p_@@ j . getItem ( ) != null ) { s_@@ j = SV@@ DB@@ Item . getName ( p_@@ j . getItem ( ) ) ; } else { s_@@ j = p_@@ j . get@@ Repl@@ acement ( ) ; } if ( prefix . compareTo ( s_@@ i ) < prefix . compareTo ( s_@@ j ) ) { pro@@ pos@@ als . set ( i , p_@@ j ) ; pro@@ pos@@ als . set ( j , p_@@ i ) ; p_@@ i = p_@@ j ; } } } } } protected void add@@ Propos@@ al ( IS@@ V@@ DB@@ Item@@ Base it , String prefix , int repl@@ ac@@ ement@@ Offset , int repl@@ ac@@ ement@@ Length ) { add@@ Propos@@ al ( it , prefix , false , repl@@ ac@@ ement@@ Offset , repl@@ ac@@ ement@@ Length ) ; } protected void add@@ Propos@@ al ( IS@@ V@@ DB@@ Item@@ Base it , String prefix , boolean name@@ _b@@ as@@ ed@@ _@@ check , int repl@@ ac@@ ement@@ Offset , int repl@@ ac@@ ement@@ Length ) { boolean found = false ; synchronized ( f@@ CompletionPropos@@ als ) { for ( SV@@ CompletionPropos@@ al p : f@@ CompletionPropos@@ als ) { if ( p . getItem ( ) != null ) { if ( p . getItem ( ) == it ) { found = true ; break ; } else if ( name@@ _b@@ as@@ ed@@ _@@ check ) { if ( p . getItem ( ) instanceof IS@@ V@@ DB@@ Named@@ Item && it instanceof IS@@ V@@ DB@@ Named@@ Item ) { IS@@ V@@ DB@@ Named@@ Item i1 = ( IS@@ V@@ DB@@ Named@@ Item ) p . getItem ( ) ; IS@@ V@@ DB@@ Named@@ Item i2 = ( IS@@ V@@ DB@@ Named@@ Item ) it ; if ( i1 . getName ( ) == null || i1 . getName ( ) == null ) { if ( i1 . getName ( ) == i2 . getName ( ) ) { found = true ; break ; } } else if ( i1 . getName ( ) . equals ( i2 . getName ( ) ) ) { found = true ; break ; } } } } } if ( ! found ) { debug ( "" + SV@@ DB@@ Item . getName ( it ) + " " + it . getType ( ) ) ; add@@ Propos@@ al ( new SV@@ CompletionPropos@@ al ( it , prefix , repl@@ ac@@ ement@@ Offset , repl@@ ac@@ ement@@ Length ) ) ; } } } protected void debug ( String msg ) { f@@ Log . debug ( msg ) ; } } </s>
<s> package net . sf . sv@@ editor . core . content@@ _@@ assist ; import java . util . ArrayList ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ If@@ c@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Task ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Param@@ Port@@ Decl ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Var@@ Decl@@ Item ; public class SV@@ CompletionPropos@@ al@@ Utils { private int f@@ T@@ F@@ Max@@ Char@@ sPer@@ Line = 80 ; private int f@@ T@@ F@@ Port@@ sPer@@ Line = 0 ; private boolean f@@ T@@ F@@ Named@@ Port@@ s = true ; private int f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line = 80 ; private int f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line = 1 ; private boolean f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s = true ; public SV@@ CompletionPropos@@ al@@ Utils ( ) { } public void setT@@ F@@ Max@@ Char@@ sPer@@ Line ( int max ) { f@@ T@@ F@@ Max@@ Char@@ sPer@@ Line = max ; } public void setT@@ F@@ Port@@ sPer@@ Line ( int max ) { f@@ T@@ F@@ Port@@ sPer@@ Line = max ; } public void setT@@ F@@ Named@@ Port@@ s ( boolean nam@@ ed ) { f@@ T@@ F@@ Named@@ Port@@ s = nam@@ ed ; } public void set@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line ( int max ) { f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line = max ; } public void set@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line ( int max ) { f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line = max ; } public void set@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s ( boolean nam@@ ed ) { f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s = nam@@ ed ; } private static String escape@@ Id ( String id ) { StringBuilder sb = new StringBuilder ( id ) ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { if ( sb . charAt ( i ) == '@@ $@@ ' ) { sb . insert ( i , '@@ $@@ ' ) ; i ++ ; } } return sb . toString ( ) ; } public static String getLine@@ Ind@@ ent ( String doc , String ind@@ ent@@ _@@ inc@@ r ) { StringBuilder doc@@ _@@ str = new StringBuilder ( doc ) ; int last@@ _@@ line@@ _@@ idx = doc@@ _@@ str . lastIndexOf ( "n" ) ; String indent = "" ; if ( last@@ _@@ line@@ _@@ idx != - 1 ) { int end@@ _@@ line@@ _@@ idx = last@@ _@@ line@@ _@@ idx ; while ( end@@ _@@ line@@ _@@ idx < doc@@ _@@ str . length ( ) && Character . is@@ Whit@@ espace ( doc@@ _@@ str . charAt ( end@@ _@@ line@@ _@@ idx ) ) ) { end@@ _@@ line@@ _@@ idx ++ ; } indent = doc@@ _@@ str . substring ( last@@ _@@ line@@ _@@ idx + 1 , end@@ _@@ line@@ _@@ idx ) ; } return indent ; } public String create@@ T@@ F@@ Template ( SV@@ DB@@ Task t@@ f , String sub@@ se@@ q_@@ line@@ _@@ indent , int first@@ _@@ line@@ _@@ pos , int sub@@ se@@ q_@@ line@@ _@@ pos ) { String new@@ line = "n" + sub@@ se@@ q_@@ line@@ _@@ indent ; StringBuilder r = new StringBuilder ( ) ; int curr@@ _@@ pos = first@@ _@@ line@@ _@@ pos ; int long@@ est@@ _@@ string = 0 ; int port@@ _@@ length = 0 ; int port@@ _@@ count = 0 ; ArrayList < String > all@@ _@@ port@@ s = new ArrayList < String > ( ) ; ArrayList < String > all@@ _@@ types = new ArrayList < String > ( ) ; for ( int i = 0 ; i < t@@ f . getPar@@ ams ( ) . size ( ) ; i ++ ) { SV@@ DB@@ Param@@ Port@@ Decl param = t@@ f . getPar@@ ams ( ) . get ( i ) ; for ( IS@@ V@@ DB@@ Child@@ Item c : param . getChildren ( ) ) { SV@@ DB@@ Var@@ Decl@@ Item v@@ i = ( SV@@ DB@@ Var@@ Decl@@ Item ) c ; all@@ _@@ port@@ s . add ( v@@ i . getName ( ) ) ; all@@ _@@ types . add ( param . getType@@ Name ( ) ) ; port@@ _@@ count ++ ; port@@ _@@ length += v@@ i . getName ( ) . length ( ) ; if ( v@@ i . getName ( ) . length ( ) > long@@ est@@ _@@ string ) { long@@ est@@ _@@ string = v@@ i . getName ( ) . length ( ) ; } } } boolean multi@@ _@@ line@@ _@@ instan@@ ti@@ ation = false ; int multi@@ pli@@ er = f@@ T@@ F@@ Named@@ Port@@ s ? 2 : 1 ; if ( ( ( f@@ T@@ F@@ Max@@ Char@@ sPer@@ Line != 0 ) && ( ( first@@ _@@ line@@ _@@ pos + ( port@@ _@@ length * multi@@ pli@@ er ) + ( 2 * multi@@ pli@@ er ) ) > ( ( f@@ T@@ F@@ Max@@ Char@@ sPer@@ Line * 7 ) / 8 ) ) ) || ( ( f@@ T@@ F@@ Port@@ sPer@@ Line != 0 ) && ( port@@ _@@ count > f@@ T@@ F@@ Port@@ sPer@@ Line ) ) ) { multi@@ _@@ line@@ _@@ instan@@ ti@@ ation = true ; curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; } else { new@@ line = "" ; } r . append ( escape@@ Id ( SV@@ DB@@ Item . getName ( t@@ f ) ) + "(" + new@@ line ) ; for ( int i = 0 ; i < port@@ _@@ count ; i ++ ) { StringBuilder padd@@ ing = new StringBuilder ( "" ) ; String name@@ _@@ str = all@@ _@@ port@@ s . get ( i ) ; if ( multi@@ _@@ line@@ _@@ instan@@ ti@@ ation ) { for ( int cnt = name@@ _@@ str . length ( ) ; cnt < long@@ est@@ _@@ string + 1 ; cnt ++ ) { padd@@ ing . append ( " " ) ; } } if ( f@@ T@@ F@@ Named@@ Port@@ s == true ) { r . append ( "." ) ; r . append ( name@@ _@@ str + padd@@ ing . toString ( ) ) ; r . append ( " (" ) ; curr@@ _@@ pos += 3 + name@@ _@@ str . length ( ) + padd@@ ing . toString ( ) . length ( ) ; } r . append ( "$@@ {@@ " + all@@ _@@ port@@ s . get ( i ) + "}" + padd@@ ing . toString ( ) ) ; curr@@ _@@ pos += 3 + all@@ _@@ port@@ s . get ( i ) . length ( ) + padd@@ ing . toString ( ) . length ( ) ; if ( f@@ T@@ F@@ Named@@ Port@@ s == true ) { r . append ( ")" ) ; curr@@ _@@ pos ++ ; } if ( i + 1 < port@@ _@@ count ) { r . append ( ", " ) ; curr@@ _@@ pos += 2 ; if ( ( f@@ T@@ F@@ Port@@ sPer@@ Line != 0 && multi@@ _@@ line@@ _@@ instan@@ ti@@ ation && ( ( ( i + 1 ) % f@@ T@@ F@@ Port@@ sPer@@ Line ) == 0 ) ) || ( curr@@ _@@ pos > ( 7 * f@@ T@@ F@@ Max@@ Char@@ sPer@@ Line ) / 8 ) ) { r . append ( new@@ line ) ; curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; } } } r . append ( ")" ) ; return r . toString ( ) ; } public String create@@ Module@@ Template ( SV@@ DB@@ Mod@@ If@@ c@@ Decl t@@ f , String sub@@ se@@ q_@@ line@@ _@@ indent , int first@@ _@@ line@@ _@@ pos , int sub@@ se@@ q_@@ line@@ _@@ pos ) { String new@@ line = "n" + sub@@ se@@ q_@@ line@@ _@@ indent ; StringBuilder r = new StringBuilder ( ) ; int curr@@ _@@ pos = first@@ _@@ line@@ _@@ pos ; int long@@ est@@ _@@ string = 0 ; int port@@ _@@ len = 0 ; int param@@ _@@ len = 0 ; int port@@ _@@ count = 0 ; int param@@ _@@ count = 0 ; ArrayList < String > all@@ _@@ port@@ s = new ArrayList < String > ( ) ; ArrayList < String > all@@ _@@ types = new ArrayList < String > ( ) ; ArrayList < String > all@@ _@@ params = new ArrayList < String > ( ) ; for ( int i = 0 ; i < t@@ f . getParameters ( ) . size ( ) ; i ++ ) { String param@@ _name = t@@ f . getParameters ( ) . get ( i ) . getName ( ) ; all@@ _@@ params . add ( param@@ _name ) ; param@@ _@@ count ++ ; int len = param@@ _name . length ( ) ; param@@ _@@ len += len ; if ( len > long@@ est@@ _@@ string ) { long@@ est@@ _@@ string = len ; } } for ( int i = 0 ; i < t@@ f . getPort@@ s ( ) . size ( ) ; i ++ ) { SV@@ DB@@ Param@@ Port@@ Decl param = t@@ f . getPort@@ s ( ) . get ( i ) ; for ( IS@@ V@@ DB@@ Child@@ Item c : param . getChildren ( ) ) { SV@@ DB@@ Var@@ Decl@@ Item v@@ i = ( SV@@ DB@@ Var@@ Decl@@ Item ) c ; all@@ _@@ port@@ s . add ( v@@ i . getName ( ) ) ; all@@ _@@ types . add ( param . getType@@ Name ( ) ) ; port@@ _@@ count ++ ; int len = v@@ i . getName ( ) . length ( ) ; port@@ _@@ len += len ; if ( len > long@@ est@@ _@@ string ) { long@@ est@@ _@@ string = len ; } } } boolean multi@@ _@@ line@@ _@@ instan@@ ti@@ ation = false ; int multi@@ pli@@ er = f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s ? 2 : 1 ; if ( ( ( f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line != 0 ) && ( ( first@@ _@@ line@@ _@@ pos + ( ( port@@ _@@ len + param@@ _@@ len ) * multi@@ pli@@ er ) + ( 2 * multi@@ pli@@ er ) ) > ( ( f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line * 7 ) / 8 ) ) ) || ( ( f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line != 0 ) && ( ( port@@ _@@ count > f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line ) || ( param@@ _@@ count > f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line ) ) ) ) { multi@@ _@@ line@@ _@@ instan@@ ti@@ ation = true ; curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; } else { new@@ line = "" ; } r . append ( escape@@ Id ( SV@@ DB@@ Item . getName ( t@@ f ) ) ) ; if ( param@@ _@@ count != 0 ) { r . append ( " #@@ (" + new@@ line ) ; for ( int i = 0 ; i < param@@ _@@ count ; i ++ ) { StringBuilder padd@@ ing = new StringBuilder ( "" ) ; String name@@ _@@ str = all@@ _@@ params . get ( i ) ; if ( multi@@ _@@ line@@ _@@ instan@@ ti@@ ation ) { for ( int cnt = name@@ _@@ str . length ( ) ; cnt < long@@ est@@ _@@ string + 1 ; cnt ++ ) { padd@@ ing . append ( " " ) ; } } if ( f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s == true ) { r . append ( "." ) ; r . append ( name@@ _@@ str + padd@@ ing . toString ( ) ) ; r . append ( " (" ) ; curr@@ _@@ pos += 3 + name@@ _@@ str . length ( ) + padd@@ ing . toString ( ) . length ( ) ; } r . append ( "$@@ {@@ " + name@@ _@@ str + "}" + padd@@ ing . toString ( ) ) ; curr@@ _@@ pos += 3 + name@@ _@@ str . length ( ) + padd@@ ing . toString ( ) . length ( ) ; if ( f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s == true ) { r . append ( ")" ) ; curr@@ _@@ pos ++ ; } if ( i + 1 < param@@ _@@ count ) { r . append ( ", " ) ; curr@@ _@@ pos += 2 ; if ( ( f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line != 0 && multi@@ _@@ line@@ _@@ instan@@ ti@@ ation && ( ( ( i + 1 ) % f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line ) == 0 ) ) || ( curr@@ _@@ pos > ( 7 * f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line ) / 8 ) ) { r . append ( new@@ line ) ; curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; } } } r . append ( escape@@ Id ( new@@ line + ")" ) ) ; } r . append ( " $@@ {@@ " + escape@@ Id ( SV@@ DB@@ Item . getName ( t@@ f ) ) + "}" + " (" + new@@ line ) ; if ( ! new@@ line . isEmpty ( ) ) curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; for ( int i = 0 ; i < port@@ _@@ count ; i ++ ) { StringBuilder padd@@ ing = new StringBuilder ( "" ) ; String name@@ _@@ str = all@@ _@@ port@@ s . get ( i ) ; if ( multi@@ _@@ line@@ _@@ instan@@ ti@@ ation ) { for ( int cnt = name@@ _@@ str . length ( ) ; cnt < long@@ est@@ _@@ string + 1 ; cnt ++ ) { padd@@ ing . append ( " " ) ; } } if ( f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s == true ) { r . append ( "." ) ; r . append ( name@@ _@@ str + padd@@ ing . toString ( ) ) ; r . append ( " (" ) ; curr@@ _@@ pos += 3 + name@@ _@@ str . length ( ) + padd@@ ing . toString ( ) . length ( ) ; } r . append ( "$@@ {@@ " + all@@ _@@ port@@ s . get ( i ) + "}" + padd@@ ing . toString ( ) ) ; curr@@ _@@ pos += 3 + all@@ _@@ port@@ s . get ( i ) . length ( ) + padd@@ ing . toString ( ) . length ( ) ; if ( f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s == true ) { r . append ( ")" ) ; curr@@ _@@ pos ++ ; } if ( i + 1 < port@@ _@@ count ) { r . append ( ", " ) ; curr@@ _@@ pos += 2 ; if ( ( f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line != 0 && multi@@ _@@ line@@ _@@ instan@@ ti@@ ation && ( ( ( i + 1 ) % f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line ) == 0 ) ) || ( curr@@ _@@ pos > ( 7 * f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line ) / 8 ) ) { r . append ( new@@ line ) ; curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; } } } r . append ( ")@@ ;" ) ; return r . toString ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . content@@ _@@ assist ; public enum SV@@ CompletionPropos@@ al@@ Type { SV@@ Object , Keyword , Un@@ known } </s>
<s> package net . sf . sv@@ editor . core . indent ; import java . util . List ; public class SV@@ Ind@@ ent@@ Stmt { protected List < SV@@ Ind@@ ent@@ Stmt > f@@ St@@ mt@@ List ; protected SV@@ Ind@@ ent@@ St@@ mt@@ Type f@@ Type ; public SV@@ Ind@@ ent@@ Stmt ( SV@@ Ind@@ ent@@ St@@ mt@@ Type type ) { f@@ Type = type ; } public SV@@ Ind@@ ent@@ St@@ mt@@ Type getType ( ) { return f@@ Type ; } } </s>
<s> package net . sf . sv@@ editor . core . indent ; public class SV@@ Ind@@ ent@@ Token { protected SV@@ Ind@@ ent@@ TokenType f@@ Type ; protected String f@@ Le@@ ad@@ ing@@ WS ; protected String f@@ Tr@@ ail@@ ing@@ WS = "" ; protected String f@@ Image ; protected boolean f@@ End@@ Line ; protected boolean f@@ Start@@ Line ; protected boolean f@@ Do@@ I@@ t ; protected int f@@ Pos ; protected int f@@ Lin@@ en@@ o ; public SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType type , String le@@ ad@@ ing_@@ ws , String image ) { f@@ Type = type ; f@@ Le@@ ad@@ ing@@ WS = le@@ ad@@ ing_@@ ws ; f@@ Tr@@ ail@@ ing@@ WS = "" ; f@@ Image = image ; f@@ Do@@ I@@ t = true ; } protected SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType type , String le@@ ad@@ ing_@@ ws ) { f@@ Type = type ; f@@ Le@@ ad@@ ing@@ WS = le@@ ad@@ ing_@@ ws ; f@@ Tr@@ ail@@ ing@@ WS = "" ; f@@ Image = "" ; f@@ Do@@ I@@ t = true ; } public boolean is@@ Id ( String s ) { return ( getType ( ) == SV@@ Ind@@ ent@@ TokenType . Identifier && get@@ Image ( ) . equals ( s ) ) ; } public boolean is@@ Op ( String ... s ) { if ( getType ( ) == SV@@ Ind@@ ent@@ TokenType . Operator ) { if ( s . length == 0 ) { return true ; } else { for ( String s_@@ i : s ) { if ( get@@ Image ( ) . equals ( s_@@ i ) ) { return true ; } } } } return false ; } public boolean is@@ Pre@@ Pro@@ c ( ) { return ( getType ( ) == SV@@ Ind@@ ent@@ TokenType . Identifier && get@@ Image ( ) . startsWith ( "@@ `@@ " ) ) ; } public void set@@ Pos ( int pos ) { f@@ Pos = pos ; } public int get@@ Pos ( ) { return f@@ Pos ; } public void set@@ Lin@@ en@@ o ( int lin@@ en@@ o ) { f@@ Lin@@ en@@ o = lin@@ en@@ o ; } public int get@@ Lin@@ en@@ o ( ) { return f@@ Lin@@ en@@ o ; } public SV@@ Ind@@ ent@@ TokenType getType ( ) { return f@@ Type ; } public void set@@ Tr@@ ail@@ ing@@ WS ( String tr@@ ail@@ ing_@@ ws ) { f@@ Tr@@ ail@@ ing@@ WS = tr@@ ail@@ ing_@@ ws ; } public String get@@ Tr@@ ail@@ ing@@ WS ( ) { return f@@ Tr@@ ail@@ ing@@ WS ; } public boolean is@@ End@@ Line ( ) { return f@@ End@@ Line ; } public void set@@ Is@@ End@@ Line ( boolean end ) { f@@ End@@ Line = end ; } public boolean is@@ Start@@ Line ( ) { return f@@ Start@@ Line ; } public void set@@ Is@@ Start@@ Line ( boolean start ) { f@@ Start@@ Line = start ; } public String getLe@@ ad@@ ing@@ WS ( ) { return f@@ Le@@ ad@@ ing@@ WS ; } public void set@@ Le@@ ad@@ ing@@ WS ( String le@@ ad@@ ing_@@ ws ) { f@@ Le@@ ad@@ ing@@ WS = le@@ ad@@ ing_@@ ws ; } public String get@@ Image ( ) { return f@@ Image ; } public void set@@ Image ( String image ) { f@@ Image = image ; } public boolean get@@ Do@@ I@@ t ( ) { return f@@ Do@@ I@@ t ; } public void set@@ Do@@ I@@ t ( boolean do@@ it ) { f@@ Do@@ I@@ t = do@@ it ; } public boolean is@@ Blan@@ k@@ Line ( ) { return ( f@@ Start@@ Line && f@@ End@@ Line && f@@ Image . trim ( ) . equals ( "" ) ) ; } public boolean is@@ Comment ( ) { return ( f@@ Type == SV@@ Ind@@ ent@@ TokenType . Single@@ Line@@ Comment || f@@ Type == SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment ) ; } } </s>
<s> package net . sf . sv@@ editor . core . indent ; import java . util . HashSet ; import java . util . Set ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import net . sf . sv@@ editor . core . scan@@ utils . I@@ Text@@ Scanner ; public class SV@@ Ind@@ ent@@ Scanner implements IS@@ V@@ Ind@@ ent@@ Scanner { private I@@ Text@@ Scanner f@@ Scanner ; private int f@@ Un@@ getC@@ h ; private int f@@ Last@@ C@@ h [ ] = { - 1 , - 1 } ; private int f@@ Last@@ Ch@@ T = - 1 ; private int f@@ Lin@@ en@@ o ; private boolean f@@ Start@@ Line ; private String f@@ Le@@ ad@@ ing@@ WS ; private SV@@ Ind@@ ent@@ Token f@@ Curr@@ ent ; private static Set < String > f@@ Scope@@ Key@@ words ; private static Set < String > f@@ Quali@@ fiers ; private StringBuilder f@@ T@@ mp ; private static final boolean f@@ Debug@@ E@@ n = false ; private static Set < String > f@@ Oper@@ ators ; private Log@@ Handle f@@ Log ; private static final String f@@ Operator@@ List [ ] = { "@@ +" , "-" , "@@ !" , "@@ ~@@ " , "&@@ " , "@@ |" , "@@ ~@@ |" , "@@ ^@@ " , "@@ ~@@ ^@@ " , "@@ ^@@ ~@@ " , "@@ +" , "-" , "*" , "/" , "%" , "@@ =@@ =" , "@@ !@@ =" , "@@ =@@ =@@ =" , "@@ !@@ =@@ =" , "@@ =@@ =@@ ?" , "@@ !@@ =@@ ?" , "&@@ &@@ " , "@@ |@@ |" , "@@ *@@ *" , "<@@ " , "<@@ =" , ">" , "@@ >@@ =" , "&@@ " , "@@ |" , "@@ >@@ >" , "<@@ <@@ " , "@@ >@@ >@@ >" , "<@@ <@@ <@@ " , "@@ +@@ +" , "-@@ -" , "=" , "@@ +@@ =" , "-@@ =" , "@@ *@@ =" , "/@@ =" , "%@@ =" , "&@@ =" , "@@ |@@ =" , "@@ ^@@ =" , "<@@ <@@ =" , "@@ >@@ >@@ =" , "<@@ <@@ <@@ =" , "@@ >@@ >@@ >@@ =" , "@@ !" , "@@ ~@@ " , "&@@ " , "@@ ~@@ &@@ " , "@@ |" , "@@ ~@@ |" , "@@ ^@@ " , "@@ ~@@ ^@@ " , "@@ ^@@ ~@@ " , "@@ =@@ =" , "@@ !@@ =" , "&@@ &@@ " , "@@ |@@ |" , "&@@ " , "@@ |" , "@@ ^@@ " , "@@ ^@@ ~@@ " , "@@ ~@@ ^@@ " , ":" , ":@@ :" , "{@@ " , "}" , "#@@ " , "[" , "]" , "." , "," , "@@@ " , "@@ ?" , "$@@ " , "(" , ")" , "\\@@ " , "-@@ >" , "-@@ >@@ >" } ; static { f@@ Scope@@ Key@@ words = new HashSet < String > ( ) ; f@@ Scope@@ Key@@ words . add ( "@@ class@@ " ) ; f@@ Scope@@ Key@@ words . add ( "@@ function@@ " ) ; f@@ Scope@@ Key@@ words . add ( "@@ task@@ " ) ; f@@ Scope@@ Key@@ words . add ( "@@ cover@@ group@@ " ) ; f@@ Quali@@ fiers = new HashSet < String > ( ) ; f@@ Quali@@ fiers . add ( "@@ vi@@ r@@ tual@@ " ) ; f@@ Quali@@ fiers . add ( "@@ stati@@ c" ) ; f@@ Quali@@ fiers . add ( "@@ publi@@ c" ) ; f@@ Quali@@ fiers . add ( "@@ local@@ " ) ; f@@ Quali@@ fiers . add ( "@@ protec@@ ted@@ " ) ; f@@ Oper@@ ators = new HashSet < String > ( ) ; for ( String op : f@@ Operator@@ List ) { if ( ! f@@ Oper@@ ators . contains ( op ) ) { f@@ Oper@@ ators . add ( op ) ; } } } public SV@@ Ind@@ ent@@ Scanner ( I@@ Text@@ Scanner scanner ) { f@@ T@@ mp = new StringBuilder ( ) ; f@@ Scanner = scanner ; f@@ Un@@ getC@@ h = - 1 ; f@@ Last@@ C@@ h [ 0 ] = - 1 ; f@@ Last@@ C@@ h [ 1 ] = '\n' ; f@@ Lin@@ en@@ o = 1 ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; f@@ Start@@ Line = true ; } public SV@@ Ind@@ ent@@ Token next ( ) { boolean start@@ _@@ line ; int pos = 0 ; SV@@ Ind@@ ent@@ Token token = null ; start@@ _@@ line = f@@ Start@@ Line ; f@@ Start@@ Line = false ; if ( f@@ Le@@ ad@@ ing@@ WS == null ) { pos = ( int ) f@@ Scanner . get@@ Pos ( ) ; f@@ Le@@ ad@@ ing@@ WS = getIn@@ d@@ ent ( ) ; } int c = get_@@ ch ( ) ; int lin@@ en@@ o = f@@ Lin@@ en@@ o ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( char ) c + "\"" ) ; } if ( c == '\n' ) { token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Blan@@ k@@ Line , f@@ Le@@ ad@@ ing@@ WS ) ; f@@ Start@@ Line = true ; token . set@@ Is@@ End@@ Line ( true ) ; } else if ( c == '/' ) { int c2 = get_@@ ch ( ) ; if ( c2 == '/' ) { token = read@@ _@@ single@@ _@@ line@@ _@@ comment ( f@@ Le@@ ad@@ ing@@ WS ) ; token . set@@ Is@@ End@@ Line ( true ) ; } else if ( c2 == '@@ *@@ ' ) { token = read@@ _@@ multi@@ _@@ line@@ _@@ comment ( f@@ Le@@ ad@@ ing@@ WS ) ; } else { un@@ get_@@ ch ( c2 ) ; token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Operator , f@@ Le@@ ad@@ ing@@ WS , "/" ) ; } } else if ( c == '@@ "' ) { int last@@ _@@ c = - 1 ; f@@ T@@ mp . set@@ Length ( 0 ) ; f@@ T@@ mp . append ( ( char ) c ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && ( c != '@@ "' || last@@ _@@ c == '\@@ \@@ ' ) ) { f@@ T@@ mp . append ( ( char ) c ) ; last@@ _@@ c = c ; } f@@ T@@ mp . append ( ( char ) c ) ; token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . String , f@@ Le@@ ad@@ ing@@ WS , f@@ T@@ mp . toString ( ) ) ; } else if ( c == '@@ `@@ ' || c == '@@ $@@ ' || Character . is@@ Java@@ Identifier@@ Start ( c ) ) { boolean is_@@ m@@ ac@@ ro = ( c == '@@ `@@ ' ) ; int tmp@@ _@@ c = c ; if ( is_@@ m@@ ac@@ ro ) { c = get_@@ ch ( ) ; } String id = read@@ Identifier ( c ) ; if ( is_@@ m@@ ac@@ ro ) { id = ( char ) tmp@@ _@@ c + id ; } token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Identifier , f@@ Le@@ ad@@ ing@@ WS , id ) ; } else if ( c == '@@ ;@@ ' ) { token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Operator , f@@ Le@@ ad@@ ing@@ WS , ";" ) ; } else if ( Character . is@@ Digit ( c ) || c == '\@@ '@@ ' ) { f@@ T@@ mp . set@@ Length ( 0 ) ; if ( c == '\@@ '@@ ' ) { int c2 = get_@@ ch ( ) ; if ( ( c2 >= 'a' && c2 <= '@@ o@@ ' ) || ( c2 >= '@@ A@@ ' && c2 <= '@@ O@@ ' ) ) { f@@ T@@ mp . append ( ( char ) c ) ; f@@ T@@ mp . append ( ( char ) c2 ) ; } else { un@@ get_@@ ch ( c2 ) ; token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Operator , f@@ Le@@ ad@@ ing@@ WS , "'" ) ; } } else { f@@ T@@ mp . append ( ( char ) c ) ; } if ( token == null ) { while ( ( c = get_@@ ch ( ) ) != - 1 && ( c == '@@ _@@ ' || Character . is@@ Digit ( c ) || ( c >= 'a' && c <= '@@ f@@ ' ) || ( c >= '@@ A@@ ' && c <= '@@ F@@ ' ) ) ) { f@@ T@@ mp . append ( ( char ) c ) ; } un@@ get_@@ ch ( c ) ; token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Number , f@@ Le@@ ad@@ ing@@ WS , f@@ T@@ mp . toString ( ) ) ; } } else if ( c == - 1 ) { if ( f@@ Debug@@ E@@ n ) { debug ( "@@ End of input@@ " ) ; } token = null ; } else { f@@ T@@ mp . set@@ Length ( 0 ) ; f@@ T@@ mp . append ( ( char ) c ) ; while ( f@@ Oper@@ ators . contains ( f@@ T@@ mp . toString ( ) ) ) { if ( ( c = get_@@ ch ( ) ) == - 1 ) { break ; } f@@ T@@ mp . append ( ( char ) c ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" + f@@ T@@ mp . toString ( ) + "\"" ) ; } if ( ! f@@ Oper@@ ators . contains ( f@@ T@@ mp . toString ( ) ) ) { if ( f@@ T@@ mp . length ( ) > 1 ) { f@@ T@@ mp . set@@ Length ( f@@ T@@ mp . length ( ) - 1 ) ; un@@ get_@@ ch ( c ) ; } else { un@@ get_@@ ch ( c ) ; } } if ( f@@ Oper@@ ators . contains ( f@@ T@@ mp . toString ( ) ) ) { token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Operator , f@@ Le@@ ad@@ ing@@ WS , f@@ T@@ mp . toString ( ) ) ; } else { token = null ; f@@ Log . error ( "" + ( char ) c + "\"" ) ; } } f@@ Le@@ ad@@ ing@@ WS = null ; if ( token != null ) { token . set@@ Lin@@ en@@ o ( lin@@ en@@ o ) ; token . set@@ Pos ( pos ) ; c = get_@@ ch ( ) ; if ( c == '\n' ) { token . set@@ Is@@ End@@ Line ( true ) ; f@@ Start@@ Line = true ; if ( token . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Blan@@ k@@ Line ) { un@@ get_@@ ch ( c ) ; } else { f@@ T@@ mp . set@@ Length ( 0 ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && Character . is@@ Whit@@ espace ( c ) && c != '\n' ) { f@@ T@@ mp . append ( ( char ) c ) ; } un@@ get_@@ ch ( c ) ; f@@ Le@@ ad@@ ing@@ WS = f@@ T@@ mp . toString ( ) ; } } else { if ( token . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Blan@@ k@@ Line ) { un@@ get_@@ ch ( c ) ; } else { f@@ T@@ mp . set@@ Length ( 0 ) ; un@@ get_@@ ch ( c ) ; pos = ( int ) f@@ Scanner . get@@ Pos ( ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && Character . is@@ Whit@@ espace ( c ) && c != '\n' ) { f@@ T@@ mp . append ( ( char ) c ) ; } if ( c == '\n' ) { token . set@@ Is@@ End@@ Line ( true ) ; token . set@@ Tr@@ ail@@ ing@@ WS ( f@@ T@@ mp . toString ( ) ) ; f@@ Start@@ Line = true ; } else { f@@ Le@@ ad@@ ing@@ WS = f@@ T@@ mp . toString ( ) ; un@@ get_@@ ch ( c ) ; } } } token . set@@ Is@@ Start@@ Line ( start@@ _@@ line ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "@@ token \"" + ( ( token . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Identifier || token . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Operator ) ? token . get@@ Image ( ) : token . getType ( ) ) + "\" - line " + token . get@@ Lin@@ en@@ o ( ) ) ; } } else { if ( f@@ Debug@@ E@@ n ) { debug ( "@@ null token@@ " ) ; } } f@@ Curr@@ ent = token ; return token ; } public SV@@ Ind@@ ent@@ Token current ( ) { return f@@ Curr@@ ent ; } private SV@@ Ind@@ ent@@ Token read@@ _@@ single@@ _@@ line@@ _@@ comment ( String le@@ ad@@ ing_@@ ws ) { int c ; f@@ T@@ mp . set@@ Length ( 0 ) ; f@@ T@@ mp . append ( "/@@ /" ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && c != '\n' ) { f@@ T@@ mp . append ( ( char ) c ) ; } un@@ get_@@ ch ( c ) ; return new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Single@@ Line@@ Comment , le@@ ad@@ ing_@@ ws , f@@ T@@ mp . toString ( ) ) ; } private SV@@ Multi@@ Line@@ Ind@@ ent@@ Token read@@ _@@ multi@@ _@@ line@@ _@@ comment ( String le@@ ad@@ ing_@@ ws ) { SV@@ Multi@@ Line@@ Ind@@ ent@@ Token ret = new SV@@ Multi@@ Line@@ Ind@@ ent@@ Token ( le@@ ad@@ ing_@@ ws ) ; int comment [ ] = { - 1 , - 1 } , c ; boolean read@@ _@@ new@@ line = false ; f@@ T@@ mp . set@@ Length ( 0 ) ; f@@ T@@ mp . append ( "/@@ *" ) ; while ( ( c = get_@@ ch ( ) ) != - 1 ) { if ( read@@ _@@ new@@ line ) { if ( Character . is@@ Whit@@ espace ( c ) && c != '\n' ) { f@@ T@@ mp . append ( ( char ) c ) ; } else { le@@ ad@@ ing_@@ ws = f@@ T@@ mp . toString ( ) ; f@@ T@@ mp . set@@ Length ( 0 ) ; read@@ _@@ new@@ line = false ; un@@ get_@@ ch ( c ) ; } } else { if ( c == '\n' ) { SV@@ Ind@@ ent@@ Token to@@ k = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment , le@@ ad@@ ing_@@ ws , f@@ T@@ mp . toString ( ) ) ; to@@ k . set@@ Is@@ End@@ Line ( true ) ; read@@ _@@ new@@ line = true ; ret . add@@ Comment@@ Lines ( to@@ k ) ; f@@ T@@ mp . set@@ Length ( 0 ) ; le@@ ad@@ ing_@@ ws = "" ; } else { comment [ 0 ] = comment [ 1 ] ; comment [ 1 ] = c ; f@@ T@@ mp . append ( ( char ) c ) ; if ( comment [ 0 ] == '@@ *@@ ' && comment [ 1 ] == '/' ) { break ; } } } } if ( f@@ T@@ mp . length ( ) > 0 ) { ret . add@@ Comment@@ Lines ( new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment , le@@ ad@@ ing_@@ ws , f@@ T@@ mp . toString ( ) ) ) ; } if ( c == - 1 ) { return null ; } else { return ret ; } } private String read@@ Identifier ( int c ) { f@@ T@@ mp . set@@ Length ( 0 ) ; f@@ T@@ mp . append ( ( char ) c ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && Character . is@@ Java@@ Identifier@@ Part ( c ) ) { f@@ T@@ mp . append ( ( char ) c ) ; } un@@ get_@@ ch ( c ) ; return f@@ T@@ mp . toString ( ) ; } private String getIn@@ d@@ ent ( ) { int c ; f@@ T@@ mp . set@@ Length ( 0 ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && Character . is@@ Whit@@ espace ( c ) && c != '\n' ) { f@@ T@@ mp . append ( ( char ) c ) ; } if ( c != - 1 ) { un@@ get_@@ ch ( c ) ; } return f@@ T@@ mp . toString ( ) ; } private int get_@@ ch ( ) { int c = - 1 ; if ( f@@ Un@@ getC@@ h != - 1 ) { c = f@@ Un@@ getC@@ h ; f@@ Un@@ getC@@ h = - 1 ; } else { c = f@@ Scanner . get_@@ ch ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "c@@ =\"" + ( char ) c + "\"" ) ; } f@@ Last@@ C@@ h [ 0 ] = f@@ Last@@ C@@ h [ 1 ] ; f@@ Last@@ C@@ h [ 1 ] = c ; if ( f@@ Last@@ Ch@@ T == '\n' ) { f@@ Lin@@ en@@ o ++ ; } f@@ Last@@ Ch@@ T = c ; } return c ; } private void un@@ get_@@ ch ( int ch ) { f@@ Un@@ getC@@ h = ch ; } private void debug ( String msg ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( msg ) ; } } } </s>
<s> package net . sf . sv@@ editor . core . indent ; public interface IS@@ V@@ Ind@@ ent@@ Scanner { SV@@ Ind@@ ent@@ Token next ( ) ; SV@@ Ind@@ ent@@ Token current ( ) ; } </s>
<s> package net . sf . sv@@ editor . core . indent ; public class SV@@ Ind@@ ent@@ L@@ oop@@ Stmt { } </s>
<s> package net . sf . sv@@ editor . core . indent ; import java . util . ArrayList ; import java . util . List ; public class SV@@ Multi@@ Line@@ Ind@@ ent@@ Token extends SV@@ Ind@@ ent@@ Token { private List < SV@@ Ind@@ ent@@ Token > f@@ Comment@@ List ; public SV@@ Multi@@ Line@@ Ind@@ ent@@ Token ( String le@@ ad@@ ing_@@ ws ) { super ( SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment , le@@ ad@@ ing_@@ ws ) ; f@@ Comment@@ List = new ArrayList < SV@@ Ind@@ ent@@ Token > ( ) ; } public List < SV@@ Ind@@ ent@@ Token > get@@ Comment@@ Lines ( ) { return f@@ Comment@@ List ; } public void add@@ Comment@@ Lines ( SV@@ Ind@@ ent@@ Token to@@ k ) { f@@ Comment@@ List . add ( to@@ k ) ; } @ Override public String get@@ Image ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < f@@ Comment@@ List . size ( ) ; i ++ ) { SV@@ Ind@@ ent@@ Token line = f@@ Comment@@ List . get ( i ) ; if ( i != 0 ) { sb . append ( line . getLe@@ ad@@ ing@@ WS ( ) ) ; } sb . append ( line . get@@ Image ( ) ) ; if ( line . is@@ End@@ Line ( ) ) { sb . append ( "n" ) ; } } return sb . toString ( ) ; } @ Override public void set@@ Image ( String image ) { System . out . println ( "" ) ; } } </s>
<s> package net . sf . sv@@ editor . core . indent ; import java . io . ByteArrayOutputStream ; import java . io . PrintStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . Stack ; import java . util . regex . Pattern ; import net . sf . sv@@ editor . core . Tuple ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; public class SV@@ Default@@ Ind@@ enter@@ 2 implements IS@@ V@@ Ind@@ enter { private IS@@ V@@ Ind@@ ent@@ Scanner f@@ Scanner ; private Stack < Tuple < String , Boolean > > f@@ Ind@@ ent@@ Stack ; private List < SV@@ Ind@@ ent@@ Token > f@@ Token@@ List ; private SV@@ Ind@@ ent@@ Token f@@ Curr@@ ent ; private String f@@ Current@@ Ind@@ ent ; private Log@@ Handle f@@ Log ; private int f@@ Quali@@ fiers ; private static final boolean f@@ Debug@@ E@@ n = false ; private int f@@ N@@ Left@@ Par@@ en , f@@ N@@ Right@@ Par@@ en ; private String f@@ Ind@@ ent@@ In@@ cr = "t" ; private Pattern f@@ Tab@@ Repl@@ ace@@ Pattern ; private int f@@ Adap@@ tive@@ Ind@@ ent@@ End ; private boolean f@@ Test@@ Mode ; static private Map < String , Integer > f@@ Quali@@ fier@@ Map ; static private Set < String > f@@ Pre@@ Proc@@ Direc@@ tiv@@ es ; private class Ind@@ ent@@ EO@@ F@@ Exception extends RuntimeException { private static final long serialVersionUID = 1L ; } static { f@@ Quali@@ fier@@ Map = new HashMap < String , Integer > ( ) ; f@@ Quali@@ fier@@ Map . put ( "@@ stati@@ c" , 1 << 0 ) ; f@@ Quali@@ fier@@ Map . put ( "@@ vi@@ r@@ tual@@ " , 1 << 1 ) ; f@@ Quali@@ fier@@ Map . put ( "@@ local@@ " , 1 << 2 ) ; f@@ Quali@@ fier@@ Map . put ( "@@ protec@@ ted@@ " , 1 << 3 ) ; f@@ Quali@@ fier@@ Map . put ( "@@ publi@@ c" , 1 << 4 ) ; f@@ Quali@@ fier@@ Map . put ( "@@ ex@@ ter@@ n" , 1 << 5 ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es = new HashSet < String > ( ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ defin@@ e" ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ un@@ def@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ if@@ def@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ el@@ se@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ if@@ n@@ def@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ end@@ if@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ include@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ tim@@ es@@ c@@ ale@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "" ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "" ) ; } public SV@@ Default@@ Ind@@ enter@@ 2 ( ) { f@@ Ind@@ ent@@ Stack = new Stack < Tuple < String , Boolean > > ( ) ; f@@ Token@@ List = new ArrayList < SV@@ Ind@@ ent@@ Token > ( ) ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; } public void set@@ Adap@@ tive@@ Ind@@ ent ( boolean adap@@ tive ) { } public void setIn@@ d@@ ent@@ In@@ cr ( String inc@@ r ) { f@@ Ind@@ ent@@ In@@ cr = inc@@ r ; if ( f@@ Ind@@ ent@@ In@@ cr . charAt ( 0 ) != '\@@ t' ) { f@@ Tab@@ Repl@@ ace@@ Pattern = Pattern . compile ( "t" ) ; } else { f@@ Tab@@ Repl@@ ace@@ Pattern = null ; } } public void set@@ Adap@@ tive@@ Ind@@ ent@@ End ( int lin@@ en@@ o ) { f@@ Adap@@ tive@@ Ind@@ ent@@ End = lin@@ en@@ o ; } public void setTest@@ Mode ( boolean tm ) { f@@ Test@@ Mode = tm ; } public void init ( IS@@ V@@ Ind@@ ent@@ Scanner scanner ) { f@@ Scanner = scanner ; push@@ _@@ ind@@ ent@@ _@@ stack ( "" , true ) ; } public String indent ( ) { return indent ( - 1 , - 1 ) ; } public String indent ( int start@@ _@@ line , int end@@ _@@ line ) { StringBuilder sb = new StringBuilder ( ) ; SV@@ Ind@@ ent@@ Token to@@ k ; f@@ N@@ Left@@ Par@@ en = f@@ N@@ Right@@ Par@@ en = 1 ; while ( ( to@@ k = next ( ) ) != null ) { try { do { if ( to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Identifier && f@@ Quali@@ fier@@ Map . containsKey ( to@@ k . get@@ Image ( ) ) ) { f@@ Quali@@ fiers |= f@@ Quali@@ fier@@ Map . get ( to@@ k . get@@ Image ( ) ) ; to@@ k = next ( ) ; } else if ( to@@ k . is@@ Id ( "@@ class@@ " ) || to@@ k . is@@ Id ( "@@ module@@ " ) || to@@ k . is@@ Id ( "@@ inter@@ face@@ " ) || to@@ k . is@@ Id ( "@@ program@@ " ) || to@@ k . is@@ Id ( "@@ package@@ " ) || to@@ k . is@@ Id ( "@@ sequence@@ " ) || to@@ k . is@@ Id ( "@@ property@@ " ) ) { to@@ k = ind@@ ent@@ _@@ if@@ c_@@ module@@ _@@ class ( to@@ k . get@@ Image ( ) ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ config@@ " ) ) { to@@ k = ind@@ ent@@ _@@ config ( to@@ k . get@@ Image ( ) ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ cover@@ group@@ " ) ) { to@@ k = ind@@ ent@@ _@@ cover@@ group ( ) ; } else if ( to@@ k . is@@ Id ( "@@ function@@ " ) || to@@ k . is@@ Id ( "@@ task@@ " ) ) { to@@ k = ind@@ ent@@ _@@ task@@ _@@ function ( to@@ k . get@@ Image ( ) ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ typed@@ ef@@ " ) ) { to@@ k = ind@@ ent@@ _@@ typed@@ e@@ f ( ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Op ( ";" ) ) { f@@ Quali@@ fiers = 0 ; to@@ k = next ( ) ; } else { to@@ k = next ( ) ; } } while ( ( to@@ k = current ( ) ) != null ) ; } catch ( Ind@@ ent@@ EO@@ F@@ Exception e ) { break ; } catch ( RuntimeException e ) { if ( f@@ Test@@ Mode ) { throw e ; } } } if ( f@@ Test@@ Mode ) { if ( f@@ Ind@@ ent@@ Stack . size ( ) != 1 ) { throw new RuntimeException ( "" + f@@ Ind@@ ent@@ Stack . size ( ) + "" ) ; } } if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; } for ( SV@@ Ind@@ ent@@ Token t : f@@ Token@@ List ) { if ( ( t . get@@ Lin@@ en@@ o ( ) >= start@@ _@@ line || start@@ _@@ line == - 1 ) && ( t . get@@ Lin@@ en@@ o ( ) <= end@@ _@@ line || end@@ _@@ line == - 1 ) ) { if ( f@@ Debug@@ E@@ n ) { debug ( "@@ to@@ k \"" + t . getType ( ) + "\" line@@ =" + t . get@@ Lin@@ en@@ o ( ) + " image@@ =" + t . get@@ Image ( ) ) ; } String le@@ ad@@ ing_@@ ws = t . getLe@@ ad@@ ing@@ WS ( ) ; if ( t . is@@ Start@@ Line ( ) && f@@ Tab@@ Repl@@ ace@@ Pattern != null ) { le@@ ad@@ ing_@@ ws = f@@ Tab@@ Repl@@ ace@@ Pattern . matcher ( le@@ ad@@ ing_@@ ws ) . replaceAll ( f@@ Ind@@ ent@@ In@@ cr ) ; } sb . append ( le@@ ad@@ ing_@@ ws + t . get@@ Image ( ) + t . get@@ Tr@@ ail@@ ing@@ WS ( ) + ( ( t . is@@ End@@ Line ( ) ) ? "n" : "" ) ) ; } } return sb . toString ( ) ; } public String getLine@@ Ind@@ ent ( int lin@@ en@@ o ) { String ret = null ; for ( SV@@ Ind@@ ent@@ Token t : f@@ Token@@ List ) { if ( t . get@@ Lin@@ en@@ o ( ) == lin@@ en@@ o ) { ret = t . getLe@@ ad@@ ing@@ WS ( ) ; if ( t . is@@ Start@@ Line ( ) && f@@ Tab@@ Repl@@ ace@@ Pattern != null ) { ret = f@@ Tab@@ Repl@@ ace@@ Pattern . matcher ( ret ) . replaceAll ( f@@ Ind@@ ent@@ In@@ cr ) ; } break ; } } return ret ; } public boolean is@@ Quali@@ fier@@ Set ( String key ) { return ( ( f@@ Quali@@ fier@@ Map . get ( key ) & f@@ Quali@@ fiers ) != 0 ) ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ if ( boolean is_@@ el@@ se@@ _@@ if ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + to@@ k . get@@ Image ( ) ) ; } start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Op ( "(" ) ) { to@@ k = consum@@ e_@@ expression ( ) ; } else { return to@@ k ; } to@@ k = ind@@ ent@@ _@@ if@@ _@@ st@@ m@@ ts ( null ) ; if ( to@@ k . is@@ Id ( "@@ el@@ se@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Id ( "@@ if@@ " ) ) { to@@ k = ind@@ ent@@ _@@ if ( true ) ; } else { start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = ind@@ ent@@ _@@ if@@ _@@ st@@ m@@ ts ( null ) ; } } if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ if@@ _@@ st@@ m@@ ts ( String parent ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; if ( to@@ k . is@@ Id ( "@@ begin@@ " ) ) { parent = "@@ begin@@ " ; boolean begin@@ _@@ is_@@ start@@ _@@ line = to@@ k . is@@ Start@@ Line ( ) ; if ( begin@@ _@@ is_@@ start@@ _@@ line ) { enter@@ _@@ scope ( to@@ k ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; } to@@ k = next@@ _@@ s ( ) ; if ( ! begin@@ _@@ is_@@ start@@ _@@ line ) { enter@@ _@@ scope ( to@@ k ) ; } else { enter@@ _@@ scope ( to@@ k ) ; } while ( to@@ k != null ) { if ( f@@ Debug@@ E@@ n ) { debug ( "" + to@@ k . getType ( ) + " " + to@@ k . get@@ Image ( ) ) ; } if ( to@@ k . is@@ Id ( "@@ end@@ " ) ) { le@@ ave@@ _@@ scope ( to@@ k ) ; if ( begin@@ _@@ is_@@ start@@ _@@ line ) { le@@ ave@@ _@@ scope ( ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } to@@ k = next@@ _@@ s ( ) ; if ( begin@@ _@@ is_@@ start@@ _@@ line ) { set_@@ indent ( to@@ k , false ) ; } to@@ k = consum@@ e_@@ lab@@ ele@@ d_@@ block ( to@@ k ) ; break ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( parent , true ) ; } } } else { enter@@ _@@ scope ( to@@ k ) ; to@@ k = ind@@ ent@@ _@@ stmt ( parent ) ; le@@ ave@@ _@@ scope ( to@@ k ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ for@@ k ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( to@@ k != null && ! to@@ k . is@@ Id ( "@@ join@@ " ) && ! to@@ k . is@@ Id ( "@@ jo@@ in_@@ n@@ one" ) && ! to@@ k . is@@ Id ( "@@ jo@@ in_@@ an@@ y" ) ) { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( "@@ for@@ k" , true ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ loop@@ _@@ stmt ( ) { SV@@ Ind@@ ent@@ Token to@@ k , first ; to@@ k = first = current ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + to@@ k . get@@ Image ( ) ) ; } if ( ! to@@ k . is@@ Id ( "@@ do@@ " ) && ! to@@ k . is@@ Id ( "@@ fore@@ ver@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Op ( "(" ) ) { to@@ k = consum@@ e_@@ expression ( ) ; } else { return to@@ k ; } } else { to@@ k = next@@ _@@ s ( ) ; } to@@ k = ind@@ ent@@ _@@ if@@ _@@ st@@ m@@ ts ( null ) ; if ( first . is@@ Id ( "@@ do@@ " ) ) { while ( ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ typed@@ e@@ f ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; boolean enum@@ _@@ struct = false ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; } to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Id ( "@@ enum@@ " ) || to@@ k . is@@ Id ( "@@ struc@@ t" ) || to@@ k . is@@ Id ( "un@@ ion@@ " ) ) { to@@ k = ind@@ ent@@ _@@ struc@@ t_@@ un@@ ion@@ _@@ enum ( "@@ typed@@ ef@@ " ) ; enum@@ _@@ struct = true ; } while ( ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; } if ( ! enum@@ _@@ struct ) { le@@ ave@@ _@@ scope ( to@@ k ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ struc@@ t_@@ un@@ ion@@ _@@ enum ( String parent ) { SV@@ Ind@@ ent@@ Token to@@ k = next@@ _@@ s ( ) ; if ( ! parent . equals ( "@@ typed@@ ef@@ " ) ) { start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; } while ( ! to@@ k . is@@ Op ( "{@@ " , ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } if ( to@@ k . is@@ Op ( "{@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; if ( ! to@@ k . is@@ Op ( "}" ) ) { enter@@ _@@ scope ( to@@ k ) ; } while ( ! to@@ k . is@@ Op ( "}" ) ) { to@@ k = next@@ _@@ s ( ) ; } } le@@ ave@@ _@@ scope ( to@@ k ) ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ if@@ c_@@ module@@ _@@ class ( String item ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; String end = get_@@ end@@ _@@ k@@ w ( item ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + ")" ) ; } start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; while ( ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; f@@ Quali@@ fiers = 0 ; while ( to@@ k != null ) { if ( to@@ k . is@@ Id ( end ) ) { break ; } else if ( to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Identifier && f@@ Quali@@ fier@@ Map . containsKey ( to@@ k . get@@ Image ( ) ) ) { f@@ Quali@@ fiers |= f@@ Quali@@ fier@@ Map . get ( to@@ k . get@@ Image ( ) ) ; to@@ k = next@@ _@@ s ( ) ; } else if ( to@@ k . is@@ Id ( "@@ function@@ " ) || to@@ k . is@@ Id ( "@@ task@@ " ) ) { to@@ k = ind@@ ent@@ _@@ task@@ _@@ function ( to@@ k . get@@ Image ( ) ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ class@@ " ) || to@@ k . is@@ Id ( "@@ module@@ " ) || to@@ k . is@@ Id ( "@@ inter@@ face@@ " ) || to@@ k . is@@ Id ( "@@ property@@ " ) || to@@ k . is@@ Id ( "@@ sequence@@ " ) ) { to@@ k = ind@@ ent@@ _@@ if@@ c_@@ module@@ _@@ class ( to@@ k . get@@ Image ( ) ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ struc@@ t" ) || to@@ k . is@@ Id ( "un@@ ion@@ " ) || to@@ k . is@@ Id ( "@@ enum@@ " ) ) { to@@ k = ind@@ ent@@ _@@ struc@@ t_@@ un@@ ion@@ _@@ enum ( "" ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ initial@@ " ) || is_@@ al@@ way@@ s ( to@@ k ) || to@@ k . is@@ Id ( "@@ final@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Op ( "@@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; to@@ k = consum@@ e_@@ expression ( ) ; } if ( current ( ) . get@@ Image ( ) . equals ( "@@ begin@@ " ) ) { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( null , false ) ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( null , false ) ; } f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ cover@@ group@@ " ) ) { to@@ k = ind@@ ent@@ _@@ cover@@ group ( ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ constra@@ int@@ " ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int ( ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Pre@@ Pro@@ c ( ) && to@@ k . is@@ Start@@ Line ( ) ) { while ( ! to@@ k . is@@ End@@ Line ( ) && ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; f@@ Quali@@ fiers = 0 ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( item , true ) ; } } le@@ ave@@ _@@ scope ( to@@ k ) ; end@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = consum@@ e_@@ lab@@ ele@@ d_@@ block ( next@@ _@@ s ( ) ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + "@@ ) next@@ =" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ config ( String item ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; String end = "@@ end@@ config@@ " ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + ")" ) ; } start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; while ( ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; f@@ Quali@@ fiers = 0 ; while ( to@@ k != null ) { if ( to@@ k . is@@ Id ( end ) ) { break ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( item , true ) ; } } le@@ ave@@ _@@ scope ( to@@ k ) ; end@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = consum@@ e_@@ lab@@ ele@@ d_@@ block ( next@@ _@@ s ( ) ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + "@@ ) next@@ =" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private static boolean is_@@ al@@ way@@ s ( SV@@ Ind@@ ent@@ Token to@@ k ) { return ( to@@ k . is@@ Id ( "@@ al@@ way@@ s" ) || to@@ k . is@@ Id ( "@@ al@@ way@@ s_@@ co@@ mb@@ " ) || to@@ k . is@@ Id ( "@@ al@@ way@@ s_@@ l@@ atch@@ " ) || to@@ k . is@@ Id ( "@@ al@@ way@@ s_@@ ff@@ " ) ) ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ cover@@ group ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; } start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; while ( to@@ k != null && ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } le@@ ave@@ _@@ scope ( ) ; to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( to@@ k != null ) { if ( to@@ k . is@@ Id ( "@@ end@@ group@@ " ) ) { le@@ ave@@ _@@ scope ( to@@ k ) ; break ; } else { to@@ k = ind@@ ent@@ _@@ cover@@ group@@ _@@ item ( ) ; } } to@@ k = next@@ _@@ s ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ constra@@ int ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; to@@ k = next@@ _@@ s ( ) ; if ( ! to@@ k . is@@ Op ( "{@@ " ) ) { return to@@ k ; } to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( ! to@@ k . is@@ Op ( "}" ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ stmt ( ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ cover@@ group@@ _@@ item ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; to@@ k = next@@ _@@ s ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; enter@@ _@@ scope ( to@@ k ) ; while ( ! to@@ k . is@@ Op ( ";" ) && ! to@@ k . is@@ Op ( "{@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; if ( to@@ k . is@@ Op ( "{@@ " ) ) { boolean do@@ _@@ indent = true ; int l@@ b_@@ count = 1 , r@@ b_@@ count = 0 ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; do { to@@ k = next@@ _@@ s ( ) ; if ( do@@ _@@ indent ) { enter@@ _@@ scope ( to@@ k ) ; do@@ _@@ indent = false ; } if ( to@@ k . is@@ Op ( "{@@ " ) ) { l@@ b_@@ count ++ ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; do@@ _@@ indent = true ; } else if ( to@@ k . is@@ Op ( "}" ) ) { r@@ b_@@ count ++ ; le@@ ave@@ _@@ scope ( to@@ k ) ; } } while ( l@@ b_@@ count != r@@ b_@@ count ) ; } to@@ k = next@@ _@@ s ( ) ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ task@@ _@@ function ( String item ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; String end = get_@@ end@@ _@@ k@@ w ( item ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + ")" ) ; } while ( to@@ k != null && ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } if ( ! is@@ Quali@@ fier@@ Set ( "@@ ex@@ ter@@ n" ) ) { enter@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; while ( to@@ k != null ) { if ( to@@ k . is@@ Id ( end ) ) { break ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( item , true ) ; } } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = consum@@ e_@@ lab@@ ele@@ d_@@ block ( next@@ _@@ s ( ) ) ; } else { le@@ ave@@ _@@ scope ( ) ; to@@ k = next@@ _@@ s ( ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + "@@ ) " + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } end@@ _@@ o@@ f_@@ scope ( ) ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( String parent , boolean parent@@ _@@ is_@@ block ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + parent@@ _@@ is_@@ block + " to@@ k@@ =" + to@@ k . get@@ Image ( ) ) ; } if ( to@@ k . is@@ Id ( "@@ begin@@ " ) ) { parent = "@@ begin@@ " ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( to@@ k != null ) { if ( f@@ Debug@@ E@@ n ) { debug ( "" + to@@ k . getType ( ) + " " + to@@ k . get@@ Image ( ) ) ; } if ( to@@ k . is@@ Id ( "@@ end@@ " ) ) { le@@ ave@@ _@@ scope ( to@@ k ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } to@@ k = next@@ _@@ s ( ) ; to@@ k = consum@@ e_@@ lab@@ ele@@ d_@@ block ( to@@ k ) ; break ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( parent , true ) ; } } } else { if ( ! parent@@ _@@ is_@@ block ) { start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; enter@@ _@@ scope ( to@@ k ) ; } to@@ k = ind@@ ent@@ _@@ stmt ( parent ) ; if ( ! parent@@ _@@ is_@@ block ) { le@@ ave@@ _@@ scope ( to@@ k ) ; } } if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) + " parent@@ =" + parent ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ stmt ( String parent ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + parent + " to@@ k@@ =" + to@@ k . get@@ Image ( ) ) ; } if ( to@@ k . is@@ Id ( "@@ if@@ " ) ) { to@@ k = ind@@ ent@@ _@@ if ( false ) ; } else if ( to@@ k . is@@ Id ( "@@ for@@ k" ) ) { to@@ k = ind@@ ent@@ _@@ for@@ k ( ) ; } else if ( to@@ k . is@@ Id ( "c@@ ase@@ " ) || to@@ k . is@@ Id ( "@@ rand@@ case@@ " ) ) { to@@ k = ind@@ ent@@ _@@ case ( ) ; } else if ( is_@@ al@@ way@@ s ( to@@ k ) || to@@ k . is@@ Id ( "@@ initial@@ " ) || to@@ k . is@@ Id ( "@@ final@@ " ) ) { enter@@ _@@ scope ( to@@ k ) ; if ( ( to@@ k = next@@ _@@ s ( ) ) . is@@ Op ( "@@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; to@@ k = next@@ _@@ s ( ) ; ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( null , false ) ; } le@@ ave@@ _@@ scope ( ) ; } else if ( to@@ k . is@@ Id ( "@@ typed@@ ef@@ " ) ) { to@@ k = ind@@ ent@@ _@@ typed@@ e@@ f ( ) ; } else if ( to@@ k . is@@ Id ( "@@ whi@@ le@@ " ) || to@@ k . is@@ Id ( "@@ do@@ " ) || to@@ k . is@@ Id ( "@@ repeat@@ " ) || to@@ k . is@@ Id ( "@@ fore@@ ver@@ " ) || to@@ k . is@@ Id ( "@@ for@@ " ) || to@@ k . is@@ Id ( "@@ fore@@ ach@@ " ) ) { to@@ k = ind@@ ent@@ _@@ loop@@ _@@ stmt ( ) ; } else { boolean do@@ _@@ next = true ; while ( ! to@@ k . is@@ Op ( ";" ) ) { if ( parent != null ) { if ( ( parent . equals ( "@@ begin@@ " ) && to@@ k . is@@ Id ( "@@ end@@ " ) ) || to@@ k . is@@ Id ( "@@ end@@ " + parent ) ) { do@@ _@@ next = false ; break ; } else if ( parent . equals ( "@@ for@@ k" ) && ( to@@ k . is@@ Id ( "@@ join@@ " ) || to@@ k . is@@ Id ( "@@ jo@@ in_@@ an@@ y" ) || to@@ k . is@@ Id ( "@@ jo@@ in_@@ n@@ one" ) ) ) { do@@ _@@ next = false ; break ; } } if ( to@@ k . is@@ Op ( "(" ) ) { start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; } else if ( to@@ k . is@@ Op ( ")" ) ) { le@@ ave@@ _@@ scope ( ) ; } to@@ k = next@@ _@@ s ( ) ; } if ( do@@ _@@ next ) { to@@ k = next@@ _@@ s ( ) ; } } if ( f@@ Debug@@ E@@ n ) { debug ( "" + parent + " to@@ k@@ =" + to@@ k . get@@ Image ( ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ constra@@ int@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; if ( to@@ k . is@@ Op ( "{@@ " ) ) { start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( ! to@@ k . is@@ Op ( "}" ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; } else { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ stmt ( ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ constra@@ int@@ _@@ if@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; if ( to@@ k . is@@ Op ( "{@@ " ) ) { boolean begin@@ _@@ is_@@ start@@ _@@ line = to@@ k . is@@ Start@@ Line ( ) ; if ( begin@@ _@@ is_@@ start@@ _@@ line ) { enter@@ _@@ scope ( to@@ k ) ; } to@@ k = next@@ _@@ s ( ) ; if ( ! begin@@ _@@ is_@@ start@@ _@@ line ) { enter@@ _@@ scope ( to@@ k ) ; } while ( ! to@@ k . is@@ Op ( "}" ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; } else { enter@@ _@@ scope ( to@@ k ) ; to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ stmt ( ) ; le@@ ave@@ _@@ scope ( to@@ k ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ constra@@ int@@ _@@ stmt ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; if ( to@@ k . is@@ Id ( "@@ if@@ " ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ if ( false ) ; } else if ( to@@ k . is@@ Op ( "(" ) ) { to@@ k = consum@@ e_@@ expression ( ) ; if ( to@@ k . is@@ Op ( "-@@ >" ) || to@@ k . is@@ Op ( "-@@ >@@ >" ) ) { to@@ k = next@@ _@@ s ( ) ; to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) ; } } else { while ( ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ constra@@ int@@ _@@ if ( boolean is_@@ el@@ se@@ _@@ if ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + to@@ k . get@@ Image ( ) ) ; } start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Op ( "(" ) ) { to@@ k = consum@@ e_@@ expression ( ) ; } else { return to@@ k ; } enter@@ _@@ scope ( to@@ k ) ; to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ if@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) ; if ( to@@ k . is@@ Id ( "@@ el@@ se@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Id ( "@@ if@@ " ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ if ( true ) ; } else { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) ; } } if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ case ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; String type = to@@ k . get@@ Image ( ) ; enter@@ _@@ scope ( to@@ k ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; if ( type . equals ( "c@@ ase@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( ! to@@ k . is@@ Id ( "@@ end@@ case@@ " ) ) { while ( ! to@@ k . is@@ Op ( ":" ) && ! to@@ k . is@@ Id ( "@@ end@@ case@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; } if ( to@@ k . is@@ Op ( ":" ) ) { to@@ k = next@@ _@@ s ( ) ; to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( "c@@ ase@@ " , false ) ; } } le@@ ave@@ _@@ scope ( ) ; if ( to@@ k . is@@ Id ( "@@ end@@ case@@ " ) ) { set_@@ indent ( to@@ k , false ) ; } to@@ k = next@@ _@@ s ( ) ; return to@@ k ; } private void start@@ _@@ o@@ f_@@ scope ( SV@@ Ind@@ ent@@ Token to@@ k ) { inc@@ r_@@ indent ( true ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } } private void end@@ _@@ o@@ f_@@ scope ( ) { end@@ _@@ o@@ f_@@ scope ( null ) ; } private void end@@ _@@ o@@ f_@@ scope ( SV@@ Ind@@ ent@@ Token to@@ k ) { } private void enter@@ _@@ scope ( SV@@ Ind@@ ent@@ Token to@@ k ) { set_@@ indent ( to@@ k , false ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } } private void le@@ ave@@ _@@ scope ( ) { le@@ ave@@ _@@ scope ( null ) ; } private void le@@ ave@@ _@@ scope ( SV@@ Ind@@ ent@@ Token to@@ k ) { po@@ p_@@ indent ( to@@ k ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } } private void push@@ _@@ ind@@ ent@@ _@@ stack ( String indent , boolean pro@@ visi@@ on@@ al ) { if ( f@@ Debug@@ E@@ n ) { debug ( "[" + ( f@@ Ind@@ ent@@ Stack . size ( ) + 1 ) + "" + indent + "" + pro@@ visi@@ on@@ al ) ; } f@@ Ind@@ ent@@ Stack . push ( new Tuple < String , Boolean > ( indent , pro@@ visi@@ on@@ al ) ) ; } private String pe@@ ek@@ _@@ indent ( ) { return f@@ Ind@@ ent@@ Stack . peek ( ) . first ( ) ; } private void inc@@ r_@@ indent ( boolean pro@@ visi@@ on@@ al ) { push@@ _@@ ind@@ ent@@ _@@ stack ( f@@ Ind@@ ent@@ Stack . peek ( ) . first ( ) + f@@ Ind@@ ent@@ In@@ cr , pro@@ visi@@ on@@ al ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + pro@@ visi@@ on@@ al + "@@ ) - " + "@@ ind@@ ent@@ =\"" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } } private void po@@ p_@@ indent ( SV@@ Ind@@ ent@@ Token to@@ k ) { if ( f@@ Debug@@ E@@ n ) { String img = ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "" ; debug ( "[" + ( f@@ Ind@@ ent@@ Stack . size ( ) - 1 ) + "" + img + ")" ) ; } if ( f@@ Ind@@ ent@@ Stack . size ( ) > 1 ) { f@@ Ind@@ ent@@ Stack . pop ( ) ; } else { if ( f@@ Test@@ Mode ) { throw new RuntimeException ( "" ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; ByteArrayOutputStream bo@@ s = new ByteArrayOutputStream ( ) ; PrintStream ps = new PrintStream ( bo@@ s ) ; try { throw new Exception ( ) ; } catch ( Exception e ) { e . printStackTrace ( ps ) ; } ps . flush ( ) ; debug ( bo@@ s . toString ( ) ) ; } } if ( to@@ k != null ) { set_@@ indent ( to@@ k , false ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } } private void set_@@ indent ( SV@@ Ind@@ ent@@ Token to@@ k , boolean imp@@ lic@@ it ) { if ( to@@ k . is@@ Start@@ Line ( ) ) { if ( is@@ Adap@@ tive@@ Train@@ ing ( to@@ k ) && f@@ Ind@@ ent@@ Stack . peek ( ) . second ( ) && ! to@@ k . is@@ Blan@@ k@@ Line ( ) && ! to@@ k . is@@ Comment ( ) ) { if ( f@@ Debug@@ E@@ n ) { debug ( "" + f@@ Ind@@ ent@@ Stack . peek ( ) . first ( ) + "\" to \"" + f@@ Current@@ Ind@@ ent + "\" to@@ k@@ =\"" + to@@ k . get@@ Image ( ) + "\"" ) ; } f@@ Ind@@ ent@@ Stack . peek ( ) . set@@ First ( f@@ Current@@ Ind@@ ent ) ; } debug ( "" + imp@@ lic@@ it + " \"" + to@@ k . get@@ Image ( ) + "\" \"" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; to@@ k . set@@ Le@@ ad@@ ing@@ WS ( pe@@ ek@@ _@@ indent ( ) ) ; } } private void ind@@ ent@@ _@@ multi@@ _@@ line@@ _@@ comment ( SV@@ Ind@@ ent@@ Token to@@ k ) { SV@@ Multi@@ Line@@ Ind@@ ent@@ Token ml_@@ comment = ( SV@@ Multi@@ Line@@ Ind@@ ent@@ Token ) to@@ k ; if ( to@@ k . is@@ Start@@ Line ( ) ) { set_@@ indent ( to@@ k , false ) ; for ( SV@@ Ind@@ ent@@ Token line : ml_@@ comment . get@@ Comment@@ Lines ( ) ) { if ( line . get@@ Image ( ) . startsWith ( "*" ) ) { line . set@@ Le@@ ad@@ ing@@ WS ( pe@@ ek@@ _@@ indent ( ) + " " ) ; } } } else { if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; } } } private SV@@ Ind@@ ent@@ Token consum@@ e_@@ lab@@ ele@@ d_@@ block ( SV@@ Ind@@ ent@@ Token to@@ k ) { if ( to@@ k . is@@ Op ( ":" ) ) { to@@ k = next@@ _@@ s ( ) ; to@@ k = next@@ _@@ s ( ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token consum@@ e_@@ expression ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; int n@@ _@@ l@@ br@@ ace = 0 , n@@ _r@@ br@@ ace = 0 ; do { if ( to@@ k . is@@ Op ( "(" ) ) { n@@ _@@ l@@ br@@ ace ++ ; } else if ( to@@ k . is@@ Op ( ")" ) ) { n@@ _r@@ br@@ ace ++ ; } to@@ k = next@@ _@@ s ( ) ; } while ( n@@ _@@ l@@ br@@ ace != n@@ _r@@ br@@ ace ) ; return to@@ k ; } private boolean is@@ Adap@@ tive@@ Train@@ ing ( SV@@ Ind@@ ent@@ Token to@@ k ) { return ( f@@ Adap@@ tive@@ Ind@@ ent@@ End != - 1 && to@@ k . get@@ Lin@@ en@@ o ( ) <= f@@ Adap@@ tive@@ Ind@@ ent@@ End ) ; } private SV@@ Ind@@ ent@@ Token next ( ) { SV@@ Ind@@ ent@@ Token to@@ k = null ; while ( ( to@@ k = f@@ Scanner . next ( ) ) != null && ( to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Blan@@ k@@ Line || to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment || to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Single@@ Line@@ Comment || ( to@@ k . is@@ Pre@@ Pro@@ c ( ) && f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . contains ( to@@ k . get@@ Image ( ) ) ) ) ) { if ( to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Single@@ Line@@ Comment ) { set_@@ indent ( to@@ k , true ) ; f@@ Token@@ List . add ( to@@ k ) ; } else if ( to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment ) { ind@@ ent@@ _@@ multi@@ _@@ line@@ _@@ comment ( to@@ k ) ; f@@ Token@@ List . add ( to@@ k ) ; } else if ( to@@ k . is@@ Pre@@ Pro@@ c ( ) && ! to@@ k . get@@ Image ( ) . equals ( "@@ `@@ include@@ " ) ) { Stack < Tuple < String , Boolean > > stack = f@@ Ind@@ ent@@ Stack ; f@@ Ind@@ ent@@ Stack = new Stack < Tuple < String , Boolean > > ( ) ; push@@ _@@ ind@@ ent@@ _@@ stack ( "" , false ) ; set_@@ indent ( to@@ k , true ) ; while ( to@@ k != null && ! to@@ k . is@@ End@@ Line ( ) ) { f@@ Token@@ List . add ( to@@ k ) ; to@@ k = f@@ Scanner . next ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } } if ( to@@ k != null ) { f@@ Token@@ List . add ( to@@ k ) ; } f@@ Ind@@ ent@@ Stack = stack ; } else { f@@ Token@@ List . add ( to@@ k ) ; } } if ( to@@ k != null ) { if ( to@@ k . is@@ Op ( "(" ) ) { if ( f@@ N@@ Left@@ Par@@ en == f@@ N@@ Right@@ Par@@ en ) { } f@@ N@@ Left@@ Par@@ en ++ ; } else if ( to@@ k . is@@ Op ( ")" ) ) { f@@ N@@ Right@@ Par@@ en ++ ; if ( f@@ N@@ Left@@ Par@@ en == f@@ N@@ Right@@ Par@@ en ) { f@@ N@@ Left@@ Par@@ en = f@@ N@@ Right@@ Par@@ en = 0 ; } } if ( to@@ k . is@@ Start@@ Line ( ) ) { f@@ Current@@ Ind@@ ent = to@@ k . getLe@@ ad@@ ing@@ WS ( ) ; set_@@ indent ( to@@ k , true ) ; } f@@ Token@@ List . add ( to@@ k ) ; } f@@ Curr@@ ent = to@@ k ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token current ( ) { return f@@ Curr@@ ent ; } private SV@@ Ind@@ ent@@ Token current_@@ s ( ) { if ( current ( ) == null ) { throw new RuntimeException ( ) ; } return current ( ) ; } private SV@@ Ind@@ ent@@ Token next@@ _@@ s ( ) { SV@@ Ind@@ ent@@ Token ret = next ( ) ; if ( f@@ Debug@@ E@@ n ) { if ( ret != null ) { debug ( "@@ next@@ _@@ s@@ : " + ret . get@@ Image ( ) ) ; } else { debug ( "@@ next@@ _@@ s@@ : null@@ " ) ; } } if ( ret == null ) { throw new Ind@@ ent@@ EO@@ F@@ Exception ( ) ; } return ret ; } private static String get_@@ end@@ _@@ k@@ w ( String k@@ w ) { if ( k@@ w . equals ( "@@ cover@@ group@@ " ) ) { return "@@ end@@ group@@ " ; } else { return "@@ end@@ " + k@@ w ; } } private void debug ( String msg ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( msg ) ; } } } </s>
<s> package net . sf . sv@@ editor . core . indent ; import java . util . ArrayList ; import java . util . List ; public class SV@@ Ind@@ ent@@ Expr@@ Token extends SV@@ Ind@@ ent@@ Token { protected List < SV@@ Ind@@ ent@@ Token > f@@ Expr@@ Elem@@ s ; public SV@@ Ind@@ ent@@ Expr@@ Token ( String le@@ ad@@ ing_@@ ws ) { super ( SV@@ Ind@@ ent@@ TokenType . Expression , le@@ ad@@ ing_@@ ws ) ; f@@ Expr@@ Elem@@ s = new ArrayList < SV@@ Ind@@ ent@@ Token > ( ) ; } public List < SV@@ Ind@@ ent@@ Token > get@@ Expr@@ Elem@@ s ( ) { return f@@ Expr@@ Elem@@ s ; } public void add@@ Expr@@ E@@ le@@ m ( SV@@ Ind@@ ent@@ Token elem ) { f@@ Expr@@ Elem@@ s . add ( elem ) ; } @ Override public String get@@ Image ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < f@@ Expr@@ Elem@@ s . size ( ) ; i ++ ) { SV@@ Ind@@ ent@@ Token to@@ k = f@@ Expr@@ Elem@@ s . get ( i ) ; if ( i > 0 ) { sb . append ( to@@ k . getLe@@ ad@@ ing@@ WS ( ) ) ; } sb . append ( to@@ k . get@@ Image ( ) ) ; } return sb . toString ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . indent ; public interface IS@@ V@@ Ind@@ enter { void setIn@@ d@@ ent@@ In@@ cr ( String inc@@ r ) ; void init ( IS@@ V@@ Ind@@ ent@@ Scanner scanner ) ; String indent ( ) ; String indent ( int start , int end ) ; String getLine@@ Ind@@ ent ( int lin@@ en@@ o ) ; void set@@ Adap@@ tive@@ Ind@@ ent ( boolean en ) ; void set@@ Adap@@ tive@@ Ind@@ ent@@ End ( int lin@@ en@@ o ) ; void setTest@@ Mode ( boolean tm ) ; } </s>
<s> package net . sf . sv@@ editor . core . indent ; public enum SV@@ Ind@@ ent@@ St@@ mt@@ Type { Block , L@@ oop , If , Case } </s>
<s> package net . sf . sv@@ editor . core . indent ; public enum SV@@ Ind@@ ent@@ TokenType { Identifier , Operator , Expression , Multi@@ Line@@ Comment , Single@@ Line@@ Comment , Number , Blan@@ k@@ Line , String } </s>
<s> package net . sf . sv@@ editor . core . log ; import java . lang . ref . W@@ eak@@ Reference ; import java . util . ArrayList ; import java . util . List ; public class Log@@ Category { private String f@@ Category ; private int f@@ Log@@ Level ; private List < W@@ eak@@ Reference < I@@ Log@@ Handle > > f@@ Log@@ Hand@@ les ; public Log@@ Category ( String category , int level ) { f@@ Category = category ; f@@ Log@@ Level = level ; f@@ Log@@ Hand@@ les = new ArrayList < W@@ eak@@ Reference < I@@ Log@@ Handle > > ( ) ; } public String getC@@ ateg@@ ory ( ) { return f@@ Category ; } public void set@@ Log@@ Level ( int level ) { f@@ Log@@ Level = level ; for ( int i = 0 ; i < f@@ Log@@ Hand@@ les . size ( ) ; i ++ ) { W@@ eak@@ Reference < I@@ Log@@ Handle > lr = f@@ Log@@ Hand@@ les . get ( i ) ; if ( lr . get ( ) == null ) { f@@ Log@@ Hand@@ les . remove ( i ) ; i -- ; } else { lr . get ( ) . set@@ Debug@@ Level ( level ) ; } } } public int get@@ Log@@ Level ( ) { return f@@ Log@@ Level ; } public void add@@ Log@@ Handle ( I@@ Log@@ Handle handle ) { handle . set@@ Debug@@ Level ( f@@ Log@@ Level ) ; f@@ Log@@ Hand@@ les . add ( new W@@ eak@@ Reference < I@@ Log@@ Handle > ( handle ) ) ; } public void remove@@ Log@@ Handle ( I@@ Log@@ Handle handle ) { f@@ Log@@ Hand@@ les . remove ( handle ) ; } } </s>
<s> package net . sf . sv@@ editor . core . log ; public interface I@@ Log@@ Listener { int Type@@ _@@ Info = 1 ; int Type@@ _@@ Debug = 2 ; int Type@@ _@@ Error = 4 ; void message ( I@@ Log@@ Handle handle , int type , int level , String message ) ; } </s>
<s> package net . sf . sv@@ editor . core . log ; import java . lang . ref . W@@ eak@@ Reference ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; public class LogFactory implements I@@ Log@@ Listener { private static LogFactory f@@ Default ; private Map < String , Log@@ Handle > f@@ Log@@ Handle@@ Map ; private int f@@ Log@@ Level = 0 ; private Map < String , Log@@ Category > f@@ Log@@ Handle@@ Category@@ Map ; private List < W@@ eak@@ Reference < I@@ Log@@ Listener > > f@@ Log@@ Listeners ; public LogFactory ( ) { f@@ Log@@ Handle@@ Map = new HashMap < String , Log@@ Handle > ( ) ; f@@ Log@@ Handle@@ Category@@ Map = new HashMap < String , Log@@ Category > ( ) ; f@@ Log@@ Listeners = new ArrayList < W@@ eak@@ Reference < I@@ Log@@ Listener > > ( ) ; } public synchronized static LogFactory getDefault ( ) { if ( f@@ Default == null ) { f@@ Default = new LogFactory ( ) ; } return f@@ Default ; } public static synchronized Log@@ Handle get@@ Log@@ Handle ( String name ) { return get@@ Log@@ Handle ( name , I@@ Log@@ Handle . LOG_@@ C@@ AT_@@ DEFAULT ) ; } public void set@@ Log@@ Level ( String category , int level ) { if ( category == null ) { f@@ Log@@ Level = level ; for ( Entry < String , Log@@ Category > e : f@@ Log@@ Handle@@ Category@@ Map . entrySet ( ) ) { e . getValue ( ) . set@@ Log@@ Level ( level ) ; } } else { Log@@ Category cat ; if ( f@@ Log@@ Handle@@ Category@@ Map . containsKey ( category ) ) { cat = new Log@@ Category ( category , level ) ; f@@ Log@@ Handle@@ Category@@ Map . put ( category , cat ) ; } else { cat = f@@ Log@@ Handle@@ Category@@ Map . get ( category ) ; } cat . set@@ Log@@ Level ( level ) ; } } public static synchronized Log@@ Handle get@@ Log@@ Handle ( String name , String category ) { LogFactory f = getDefault ( ) ; boolean create@@ d = false ; Log@@ Handle handle = null ; synchronized ( f . f@@ Log@@ Handle@@ Map ) { if ( ! f . f@@ Log@@ Handle@@ Map . containsKey ( name ) ) { handle = new Log@@ Handle ( name , category ) ; handle . init ( f ) ; f . f@@ Log@@ Handle@@ Map . put ( name , handle ) ; create@@ d = true ; } else { handle = f . f@@ Log@@ Handle@@ Map . get ( name ) ; } } if ( create@@ d ) { synchronized ( f . f@@ Log@@ Handle@@ Category@@ Map ) { Log@@ Category cat ; if ( ! f . f@@ Log@@ Handle@@ Category@@ Map . containsKey ( handle . getC@@ ateg@@ ory ( ) ) ) { cat = new Log@@ Category ( handle . getC@@ ateg@@ ory ( ) , f . f@@ Log@@ Level ) ; f . f@@ Log@@ Handle@@ Category@@ Map . put ( handle . getC@@ ateg@@ ory ( ) , cat ) ; } else { cat = f . f@@ Log@@ Handle@@ Category@@ Map . get ( handle . getC@@ ateg@@ ory ( ) ) ; } cat . add@@ Log@@ Handle ( handle ) ; } } return handle ; } public static void remove@@ Log@@ Handle ( Log@@ Handle log ) { LogFactory f = getDefault ( ) ; synchronized ( f . f@@ Log@@ Handle@@ Map ) { f . f@@ Log@@ Handle@@ Map . remove ( log . getName ( ) ) ; } synchronized ( f . f@@ Log@@ Handle@@ Category@@ Map ) { f . f@@ Log@@ Handle@@ Category@@ Map . get ( log . getC@@ ateg@@ ory ( ) ) . remove@@ Log@@ Handle ( log ) ; } } public void add@@ Log@@ Listener ( I@@ Log@@ Listener l ) { synchronized ( f@@ Log@@ Listeners ) { f@@ Log@@ Listeners . add ( new W@@ eak@@ Reference < I@@ Log@@ Listener > ( l ) ) ; } } public void remove@@ Log@@ Listener ( I@@ Log@@ Listener l ) { synchronized ( f@@ Log@@ Listeners ) { for ( int i = 0 ; i < f@@ Log@@ Listeners . size ( ) ; i ++ ) { if ( f@@ Log@@ Listeners . get ( i ) . get ( ) == l ) { f@@ Log@@ Listeners . remove ( i ) ; } } } } public void message ( I@@ Log@@ Handle handle , int type , int level , String message ) { synchronized ( f@@ Log@@ Listeners ) { for ( int i = 0 ; i < f@@ Log@@ Listeners . size ( ) ; i ++ ) { W@@ eak@@ Reference < I@@ Log@@ Listener > lr = f@@ Log@@ Listeners . get ( i ) ; if ( lr . get ( ) == null ) { f@@ Log@@ Listeners . remove ( i ) ; i -- ; } else { lr . get ( ) . message ( handle , type , level , message ) ; } } } } } </s>
<s> package net . sf . sv@@ editor . core . log ; public interface I@@ Log@@ Handle extends I@@ Log@@ Level { String LOG_@@ C@@ AT_@@ DEFAULT = "@@ DEFAUL@@ T" ; String LOG_@@ C@@ AT_@@ PAR@@ SE@@ R = "@@ Parser@@ " ; String getName ( ) ; void init ( I@@ Log@@ Listener parent ) ; void print ( int type , int level , String msg ) ; void println ( int type , int level , String msg ) ; boolean isEnabled ( ) ; int get@@ Debug@@ Level ( ) ; void set@@ Debug@@ Level ( int level ) ; void add@@ Log@@ Level@@ Listener ( I@@ Log@@ Level@@ Listener l ) ; } </s>
<s> package net . sf . sv@@ editor . core . log ; import java . lang . ref . W@@ eak@@ Reference ; import java . util . ArrayList ; import java . util . List ; public class Log@@ Handle implements I@@ Log@@ Handle { private String f@@ Name ; private String f@@ Category ; private I@@ Log@@ Listener f@@ Listener ; private int f@@ Debug@@ Level = 1 ; private int f@@ Ind@@ ent ; private List < W@@ eak@@ Reference < I@@ Log@@ Level@@ Listener > > f@@ Log@@ Level@@ Listeners ; public Log@@ Handle ( String name ) { this ( name , LOG_@@ C@@ AT_@@ DEFAULT ) ; } public Log@@ Handle ( String name , String category ) { f@@ Name = name ; f@@ Category = category ; f@@ Log@@ Level@@ Listeners = new ArrayList < W@@ eak@@ Reference < I@@ Log@@ Level@@ Listener > > ( ) ; } public void init ( I@@ Log@@ Listener parent ) { f@@ Listener = parent ; } public String getName ( ) { return f@@ Name ; } public String getC@@ ateg@@ ory ( ) { return f@@ Category ; } public void add@@ Log@@ Level@@ Listener ( I@@ Log@@ Level@@ Listener l ) { f@@ Log@@ Level@@ Listeners . add ( new W@@ eak@@ Reference < I@@ Log@@ Level@@ Listener > ( l ) ) ; } public void set@@ Debug@@ Level ( int level ) { if ( f@@ Debug@@ Level != level ) { f@@ Debug@@ Level = level ; for ( int i = 0 ; i < f@@ Log@@ Level@@ Listeners . size ( ) ; i ++ ) { W@@ eak@@ Reference < I@@ Log@@ Level@@ Listener > l = f@@ Log@@ Level@@ Listeners . get ( i ) ; if ( l == null || l . get ( ) == null ) { f@@ Log@@ Level@@ Listeners . remove ( i ) ; i -- ; } else { l . get ( ) . log@@ Level@@ Changed ( this ) ; } } } f@@ Debug@@ Level = level ; } public int get@@ Debug@@ Level ( ) { return f@@ Debug@@ Level ; } public boolean isEnabled ( ) { return ( f@@ Debug@@ Level > 0 ) ; } public boolean isEnabled ( int level ) { return ( f@@ Debug@@ Level > level ) ; } public void print ( int type , int level , String msg ) { } public void println ( int type , int level , String msg ) { f@@ Listener . message ( this , type , level , msg ) ; } public void not@@ e ( String msg ) { println ( I@@ Log@@ Listener . Type@@ _@@ Info , 0 , msg ) ; } public void debug ( String msg ) { println ( I@@ Log@@ Listener . Type@@ _@@ Debug , 3 , ( f@@ Ind@@ ent > 0 ) ? ( indent ( f@@ Ind@@ ent ) + msg ) : msg ) ; } public void debug ( String msg , Exception e ) { int level = I@@ Log@@ Listener . Type@@ _@@ Error + I@@ Log@@ Listener . Type@@ _@@ Debug ; println ( level , 3 , msg ) ; println ( level , 3 , e . getMessage ( ) ) ; for ( Stack@@ Trace@@ Element s_@@ e : e . get@@ StackTrace ( ) ) { String m = " at " + s_@@ e . getClass@@ Name ( ) + "." + s_@@ e . get@@ MethodName ( ) + "(" + s_@@ e . get@@ FileName ( ) + ":" + s_@@ e . getLine@@ Number ( ) + ")" ; println ( level , 3 , m ) ; } } public void debug ( int level , String msg ) { println ( I@@ Log@@ Listener . Type@@ _@@ Debug , level , ( f@@ Ind@@ ent > 0 ) ? ( indent ( f@@ Ind@@ ent ) + msg ) : msg ) ; } public void debug ( int level , String msg , Exception e ) { int type = I@@ Log@@ Listener . Type@@ _@@ Error + I@@ Log@@ Listener . Type@@ _@@ Debug ; println ( type , level , msg ) ; println ( type , level , e . getMessage ( ) ) ; for ( Stack@@ Trace@@ Element s_@@ e : e . get@@ StackTrace ( ) ) { String m = " at " + s_@@ e . getClass@@ Name ( ) + "." + s_@@ e . get@@ MethodName ( ) + "(" + s_@@ e . get@@ FileName ( ) + ":" + s_@@ e . getLine@@ Number ( ) + ")" ; println ( type , level , m ) ; } } public void enter ( String msg ) { debug ( msg ) ; f@@ Ind@@ ent ++ ; } public void le@@ ave ( String msg ) { if ( f@@ Ind@@ ent > 0 ) { f@@ Ind@@ ent -- ; } debug ( msg ) ; } public void error ( String msg ) { println ( I@@ Log@@ Listener . Type@@ _@@ Error , f@@ Debug@@ Level , msg ) ; } public void error ( String msg , Exception e ) { println ( I@@ Log@@ Listener . Type@@ _@@ Error , f@@ Debug@@ Level , msg ) ; println ( I@@ Log@@ Listener . Type@@ _@@ Error , f@@ Debug@@ Level , e . getMessage ( ) ) ; for ( Stack@@ Trace@@ Element s_@@ e : e . get@@ StackTrace ( ) ) { println ( I@@ Log@@ Listener . Type@@ _@@ Error , f@@ Debug@@ Level , " at " + s_@@ e . getClass@@ Name ( ) + "." + s_@@ e . get@@ MethodName ( ) + "(" + s_@@ e . get@@ FileName ( ) + ":" + s_@@ e . getLine@@ Number ( ) + ")" ) ; } } private String indent ( int ind ) { String ret = "" ; while ( ind -- > 0 ) { ret += " " ; } return ret ; } } </s>
<s> package net . sf . sv@@ editor . core . log ; public interface I@@ Log@@ Level@@ Listener extends I@@ Log@@ Level { void log@@ Level@@ Changed ( I@@ Log@@ Handle handle ) ; } </s>
<s> package net . sf . sv@@ editor . core . log ; public interface I@@ Log@@ Level { int LE@@ VE@@ L_@@ O@@ FF = 0 ; int LE@@ VE@@ L_@@ MI@@ N = 1 ; int LE@@ VE@@ L_@@ M@@ ID = 2 ; int LE@@ VE@@ L_@@ MA@@ X = 3 ; } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; public class Job@@ M@@ gr@@ Worker@@ Thread extends Thread { public enum Thread@@ State { Wait@@ ing , Work@@ ing } ; private Thread@@ State f@@ State ; private int f@@ Id@@ le@@ Timeout = 1000 ; private Job@@ Mgr f@@ Job@@ Mgr ; public Job@@ M@@ gr@@ Worker@@ Thread ( Job@@ Mgr m@@ gr ) { super ( "" ) ; f@@ Job@@ Mgr = m@@ gr ; } public synchronized Thread@@ State get@@ Thread@@ State ( ) { return f@@ State ; } @ Override public void run ( ) { while ( true ) { I@@ Job job = f@@ Job@@ Mgr . de@@ queue@@ Job ( f@@ Id@@ le@@ Timeout ) ; if ( job != null ) { try { job . run ( new Null@@ ProgressMonitor ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } f@@ Job@@ Mgr . job@@ En@@ ded ( job ) ; } else { if ( f@@ Job@@ Mgr . try@@ To@@ Ex@@ it ( this ) ) { break ; } } } } } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; public interface I@@ Job@@ Mgr { I@@ Job create@@ Job ( ) ; void queue@@ Job ( I@@ Job job ) ; void add@@ Job@@ Listener ( I@@ Job@@ Listener l ) ; void remove@@ Job@@ Listener ( I@@ Job@@ Listener l ) ; void dispose ( ) ; } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; public interface I@@ Job@@ Listener { void job@@ Started ( I@@ Job job ) ; void job@@ En@@ ded ( I@@ Job job ) ; } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public interface I@@ Job { void init ( String name , Runnable runn@@ able ) ; String getName ( ) ; void set@@ Priority ( int p ) ; int getPri@@ ority ( ) ; void run ( I@@ ProgressMonitor monitor ) ; void addListener ( I@@ Job@@ Listener l ) ; void remove@@ Listener ( I@@ Job@@ Listener l ) ; void clear@@ Listeners ( ) ; void join ( ) ; boolean join ( int wait@@ _@@ ms ) ; } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . job@@ _@@ m@@ gr . Job@@ M@@ gr@@ Worker@@ Thread . Thread@@ State ; public class Job@@ Mgr implements I@@ Job@@ Mgr { private List < I@@ Job@@ Listener > f@@ Job@@ Listeners ; private List < Job@@ M@@ gr@@ Worker@@ Thread > f@@ Thread@@ Pool ; private List < I@@ Job > f@@ Job@@ Queue ; private int f@@ Max@@ Threads ; private boolean f@@ Dis@@ po@@ sed ; public Job@@ Mgr ( ) { f@@ Job@@ Listeners = new ArrayList < I@@ Job@@ Listener > ( ) ; f@@ Thread@@ Pool = new ArrayList < Job@@ M@@ gr@@ Worker@@ Thread > ( ) ; f@@ Job@@ Queue = new ArrayList < I@@ Job > ( ) ; f@@ Max@@ Threads = 4 ; } public void dispose ( ) { f@@ Dis@@ po@@ sed = true ; synchronized ( f@@ Thread@@ Pool ) { while ( f@@ Thread@@ Pool . size ( ) > 0 ) { try { f@@ Thread@@ Pool . wait ( ) ; } catch ( InterruptedException e ) { break ; } } } } public void add@@ Job@@ Listener ( I@@ Job@@ Listener l ) { synchronized ( f@@ Job@@ Listeners ) { f@@ Job@@ Listeners . add ( l ) ; } } public void remove@@ Job@@ Listener ( I@@ Job@@ Listener l ) { synchronized ( f@@ Job@@ Listeners ) { f@@ Job@@ Listeners . remove ( l ) ; } } public I@@ Job create@@ Job ( ) { return new Job@@ M@@ gr@@ Job ( ) ; } public void queue@@ Job ( I@@ Job job ) { check@@ Worker@@ Threads ( ) ; synchronized ( f@@ Job@@ Queue ) { if ( f@@ Job@@ Queue . size ( ) == 0 || f@@ Job@@ Queue . get ( f@@ Job@@ Queue . size ( ) - 1 ) . getPri@@ ority ( ) <= job . getPri@@ ority ( ) ) { f@@ Job@@ Queue . add ( job ) ; } else { boolean ad@@ ded = false ; for ( int i = 0 ; i < f@@ Job@@ Queue . size ( ) ; i ++ ) { if ( f@@ Job@@ Queue . get ( i ) . getPri@@ ority ( ) > job . getPri@@ ority ( ) ) { f@@ Job@@ Queue . add ( i , job ) ; ad@@ ded = true ; break ; } } if ( ! ad@@ ded ) { f@@ Job@@ Queue . add ( job ) ; } } f@@ Job@@ Queue . notify@@ All ( ) ; } } private void check@@ Worker@@ Threads ( ) { synchronized ( f@@ Thread@@ Pool ) { boolean all@@ _@@ bu@@ s@@ y = true ; for ( Job@@ M@@ gr@@ Worker@@ Thread t : f@@ Thread@@ Pool ) { if ( t . get@@ Thread@@ State ( ) == Thread@@ State . Wait@@ ing ) { all@@ _@@ bu@@ s@@ y = false ; } } if ( all@@ _@@ bu@@ s@@ y && f@@ Thread@@ Pool . size ( ) < f@@ Max@@ Threads ) { Job@@ M@@ gr@@ Worker@@ Thread t = new Job@@ M@@ gr@@ Worker@@ Thread ( this ) ; f@@ Thread@@ Pool . add ( t ) ; t . start ( ) ; } } } public I@@ Job de@@ queue@@ Job ( int id@@ le@@ _@@ timeout ) { I@@ Job job = null ; for ( int i = 0 ; i < 2 ; i ++ ) { synchronized ( f@@ Job@@ Queue ) { if ( f@@ Job@@ Queue . size ( ) > 0 ) { job = f@@ Job@@ Queue . remove ( 0 ) ; break ; } else if ( i == 0 ) { try { f@@ Job@@ Queue . wait ( id@@ le@@ _@@ timeout ) ; } catch ( InterruptedException e ) { } } } } if ( job != null ) { job@@ Started ( job ) ; } return job ; } private void job@@ Started ( I@@ Job job ) { synchronized ( f@@ Job@@ Listeners ) { for ( I@@ Job@@ Listener l : f@@ Job@@ Listeners ) { l . job@@ Started ( job ) ; } } } void job@@ En@@ ded ( I@@ Job job ) { synchronized ( f@@ Job@@ Listeners ) { for ( I@@ Job@@ Listener l : f@@ Job@@ Listeners ) { l . job@@ En@@ ded ( job ) ; } } } public boolean try@@ To@@ Ex@@ it ( Job@@ M@@ gr@@ Worker@@ Thread t ) { boolean can@@ _@@ exit = true ; synchronized ( f@@ Thread@@ Pool ) { can@@ _@@ exit = ( f@@ Thread@@ Pool . size ( ) > 1 || f@@ Dis@@ po@@ sed ) ; if ( can@@ _@@ exit ) { f@@ Thread@@ Pool . remove ( t ) ; f@@ Thread@@ Pool . notify@@ All ( ) ; } } return can@@ _@@ exit ; } } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public class Job@@ M@@ gr@@ Job implements I@@ Job { private List < I@@ Job@@ Listener > f@@ Job@@ Listeners ; private String f@@ Name ; private Runnable f@@ Runnable ; private Object f@@ Job@@ D@@ one@@ M@@ ute@@ x ; private boolean f@@ Job@@ Done ; private int f@@ Priority = 5 ; public Job@@ M@@ gr@@ Job ( ) { f@@ Job@@ Listeners = new ArrayList < I@@ Job@@ Listener > ( ) ; f@@ Job@@ D@@ one@@ M@@ ute@@ x = new Object ( ) ; } public void init ( String name , Runnable runn@@ able ) { f@@ Name = name ; f@@ Runnable = runn@@ able ; f@@ Job@@ Done = false ; } public String getName ( ) { return f@@ Name ; } public void set@@ Priority ( int p ) { f@@ Priority = p ; } public int getPri@@ ority ( ) { return f@@ Priority ; } public void run ( I@@ ProgressMonitor monitor ) { try { job@@ Started ( ) ; f@@ Runnable . run ( ) ; } finally { job@@ En@@ ded ( ) ; } } private void job@@ Started ( ) { synchronized ( f@@ Job@@ D@@ one@@ M@@ ute@@ x ) { f@@ Job@@ Done = false ; } synchronized ( f@@ Job@@ Listeners ) { for ( I@@ Job@@ Listener l : f@@ Job@@ Listeners ) { l . job@@ Started ( this ) ; } } } private void job@@ En@@ ded ( ) { synchronized ( f@@ Job@@ D@@ one@@ M@@ ute@@ x ) { f@@ Job@@ Done = true ; f@@ Job@@ D@@ one@@ M@@ ute@@ x . notify@@ All ( ) ; } synchronized ( f@@ Job@@ Listeners ) { for ( I@@ Job@@ Listener l : f@@ Job@@ Listeners ) { l . job@@ En@@ ded ( this ) ; } } } public void addListener ( I@@ Job@@ Listener l ) { synchronized ( f@@ Job@@ Listeners ) { f@@ Job@@ Listeners . add ( l ) ; } } public void remove@@ Listener ( I@@ Job@@ Listener l ) { synchronized ( f@@ Job@@ Listeners ) { f@@ Job@@ Listeners . remove ( l ) ; } } public void clear@@ Listeners ( ) { synchronized ( f@@ Job@@ Listeners ) { f@@ Job@@ Listeners . clear ( ) ; } } public void join ( ) { synchronized ( f@@ Job@@ D@@ one@@ M@@ ute@@ x ) { while ( ! f@@ Job@@ Done ) { try { f@@ Job@@ D@@ one@@ M@@ ute@@ x . wait ( ) ; } catch ( InterruptedException e ) { break ; } } } } public boolean join ( int wait@@ _@@ ms ) { boolean job@@ _d@@ one = false ; synchronized ( f@@ Job@@ D@@ one@@ M@@ ute@@ x ) { if ( ! f@@ Job@@ Done ) { try { f@@ Job@@ D@@ one@@ M@@ ute@@ x . wait ( wait@@ _@@ ms ) ; } catch ( InterruptedException e ) { } } job@@ _d@@ one = f@@ Job@@ Done ; } return job@@ _d@@ one ; } } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; public class SV@@ Job@@ Exception extends Exception { private static final long serialVersionUID = 1L ; public SV@@ Job@@ Exception ( String msg ) { super ( msg ) ; } } </s>
<s> package net . sf . sv@@ editor . core . dir@@ tree ; import java . util . ArrayList ; import java . util . List ; public class SV@@ DB@@ Dir@@ TreeNode { private String f@@ Name ; private boolean f@@ Is@@ Dir ; private SV@@ DB@@ Dir@@ TreeNode f@@ Parent ; private List < SV@@ DB@@ Dir@@ TreeNode > f@@ Children ; public SV@@ DB@@ Dir@@ TreeNode ( SV@@ DB@@ Dir@@ TreeNode parent , String name , boolean is_@@ dir ) { f@@ Parent = parent ; f@@ Name = name ; f@@ Is@@ Dir = is_@@ dir ; f@@ Children = new ArrayList < SV@@ DB@@ Dir@@ TreeNode > ( ) ; } public void addChild ( SV@@ DB@@ Dir@@ TreeNode node ) { f@@ Children . add ( node ) ; } public List < SV@@ DB@@ Dir@@ TreeNode > getChildren ( ) { return f@@ Children ; } public boolean is@@ Dir ( ) { return f@@ Is@@ Dir ; } public String getName ( ) { return f@@ Name ; } public SV@@ DB@@ Dir@@ TreeNode getParent ( ) { return f@@ Parent ; } public SV@@ DB@@ Dir@@ TreeNode find@@ Child ( String name ) { for ( SV@@ DB@@ Dir@@ TreeNode n : f@@ Children ) { if ( n . getName ( ) . equals ( name ) ) { return n ; } } return null ; } @ Override public int hashCode ( ) { return f@@ Name . hashCode ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . dir@@ tree ; import net . sf . sv@@ editor . core . SV@@ FileUtils ; public class SV@@ DB@@ Dir@@ Tree@@ Factory { private SV@@ DB@@ Dir@@ TreeNode f@@ Root ; public SV@@ DB@@ Dir@@ Tree@@ Factory ( ) { f@@ Root = new SV@@ DB@@ Dir@@ TreeNode ( null , "" , true ) ; } public void add@@ Path ( String path , boolean is_@@ dir ) { path = SV@@ FileUtils . normali@@ ze ( path ) ; String path@@ _@@ s [ ] = path . split ( "/" ) ; add@@ Path ( f@@ Root , path@@ _@@ s , 0 , is_@@ dir ) ; } private void add@@ Path ( SV@@ DB@@ Dir@@ TreeNode parent , String path@@ _@@ s [ ] , int path@@ _@@ idx , boolean is_@@ dir ) { String elem = path@@ _@@ s [ path@@ _@@ idx ] ; SV@@ DB@@ Dir@@ TreeNode child ; if ( ( child = parent . find@@ Child ( elem ) ) == null ) { child = new SV@@ DB@@ Dir@@ TreeNode ( parent , elem , ( is_@@ dir || path@@ _@@ idx + 1 != path@@ _@@ s . length ) ) ; parent . addChild ( child ) ; } if ( path@@ _@@ idx + 1 < path@@ _@@ s . length ) { add@@ Path ( child , path@@ _@@ s , path@@ _@@ idx + 1 , is_@@ dir ) ; } } public SV@@ DB@@ Dir@@ TreeNode build@@ Tree ( ) { return f@@ Root ; } } </s>
<s> package net . sf . sv@@ editor . core ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . security . Message@@ Digest ; import java . util . regex . Pattern ; import org . eclipse . core . resources . I@@ Container ; import org . eclipse . core . resources . I@@ File ; import org . eclipse . core . resources . I@@ Project ; import org . eclipse . core . resources . I@@ Resource ; import org . eclipse . core . resources . I@@ Work@@ space@@ Root ; import org . eclipse . core . resources . Resources@@ Plugin ; import org . eclipse . core . runtime . Path ; public class SV@@ FileUtils { private static Pattern f@@ W@@ in@@ Path@@ Pattern ; public static boolean f@@ I@@ sW@@ in@@ P@@ latform ; static { f@@ W@@ in@@ Path@@ Pattern = Pattern . compile ( "\@@ \\@@ \@@ " ) ; } public static String getPath@@ Parent ( String path ) { String parent = new File ( path ) . getParent ( ) ; if ( parent == null ) { parent = path ; } return f@@ W@@ in@@ Path@@ Pattern . matcher ( parent ) . replaceAll ( "/" ) ; } public static String getPath@@ Lea@@ f ( String path ) { String le@@ af = new File ( path ) . getName ( ) ; return le@@ af ; } public static String normali@@ ze ( String path ) { if ( path . indexOf ( '\@@ \@@ ' ) != - 1 ) { path = f@@ W@@ in@@ Path@@ Pattern . matcher ( path ) . replaceAll ( "/" ) ; if ( path . length ( ) >= 3 && path . charAt ( 0 ) == '/' && Character . is@@ L@@ et@@ ter ( path . charAt ( 1 ) ) && path . charAt ( 2 ) == ':' ) { path = path . substring ( 1 ) ; } } return path ; } public static I@@ Container get@@ Work@@ space@@ Folder ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ Resource r = null ; I@@ Project p = null ; path = normali@@ ze ( path ) ; try { if ( ( r = root . get@@ Folder ( new Path ( path ) ) ) != null && r . exists ( ) ) { return ( I@@ Container ) r ; } } catch ( IllegalArgumentException e ) { } String p@@ name = path ; if ( p@@ name . startsWith ( "/" ) ) { p@@ name = p@@ name . substring ( 1 ) ; } if ( p@@ name . endsWith ( "/" ) ) { p@@ name = p@@ name . substring ( 0 , p@@ name . length ( ) - 1 ) ; } for ( I@@ Project p_@@ t : root . get@@ Projec@@ ts ( ) ) { if ( p_@@ t . getName ( ) . equals ( p@@ name ) ) { p = p_@@ t ; break ; } } return p ; } public static I@@ File get@@ Work@@ space@@ File ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ File f = null ; path = normali@@ ze ( path ) ; f = root . getFile ( new Path ( path ) ) ; if ( ! f . exists ( ) ) { f = null ; } return f ; } public static I@@ File find@@ Work@@ space@@ File ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ File f = root . getFile@@ For@@ Location ( new Path ( path ) ) ; return f ; } public static I@@ Container find@@ Work@@ space@@ Folder ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ Container c = root . get@@ Container@@ For@@ Location ( new Path ( path ) ) ; return c ; } private static String convertTo@@ Hex ( byte [ ] data ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < data . length ; i ++ ) { int h@@ alf@@ byte = ( data [ i ] >>> 4 ) & 0x0@@ F ; int tw@@ o@@ _h@@ al@@ fs = 0 ; do { if ( ( 0 <= h@@ alf@@ byte ) && ( h@@ alf@@ byte <= 9 ) ) buf . append ( ( char ) ( '0' + h@@ alf@@ byte ) ) ; else buf . append ( ( char ) ( 'a' + ( h@@ alf@@ byte - 10 ) ) ) ; h@@ alf@@ byte = data [ i ] & 0x0@@ F ; } while ( tw@@ o@@ _h@@ al@@ fs ++ < 1 ) ; } return buf . toString ( ) ; } public static String compute@@ MD@@ 5 ( String text ) { try { Message@@ Digest md ; md = Message@@ Digest . getInstance ( "M@@ D@@ 5" ) ; byte [ ] md@@ 5@@ hash = new byte [ 32 ] ; md . update ( text . getBytes ( "@@ is@@ o@@ -@@ 88@@ 59@@ -@@ 1" ) , 0 , text . length ( ) ) ; md@@ 5@@ hash = md . digest ( ) ; return convertTo@@ Hex ( md@@ 5@@ hash ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return "@@ UN@@ SUP@@ POR@@ TE@@ D" ; } public static void write@@ To@@ File ( File file , String content ) { try { PrintWriter out = new PrintWriter ( new FileWriter ( file . toString ( ) ) ) ; out . print ( content ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void delete ( File file ) { if ( ! file . exists ( ) ) { return ; } if ( file . isDirectory ( ) ) { for ( File f : file . list@@ Files ( ) ) { delete ( f ) ; } } file . delete ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db ; public class SV@@ DB@@ Gener@@ ate@@ Block extends SV@@ DB@@ Scope@@ Item { public SV@@ DB@@ Gener@@ ate@@ Block ( ) { super ( "" , SV@@ DB@@ Item@@ Type . Gener@@ ate@@ Block ) ; } public SV@@ DB@@ Gener@@ ate@@ Block ( String name ) { super ( name , SV@@ DB@@ Item@@ Type . Gener@@ ate@@ Block ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db ; import java . util . Iterator ; public class SV@@ DB@@ Util { public static int getChild@@ ren@@ Size ( IS@@ V@@ DB@@ Child@@ Parent p ) { int count = 0 ; Iterator < IS@@ V@@ DB@@ Child@@ Item > it = p . getChildren ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { count ++ ; it . next ( ) ; } return count ; } public static IS@@ V@@ DB@@ Child@@ Item getFirst@@ Child@@ Item ( IS@@ V@@ DB@@ Child@@ Parent p ) { Iterator < IS@@ V@@ DB@@ Child@@ Item > it = p . getChildren ( ) . iterator ( ) ; if ( it . hasNext ( ) ) { return it . next ( ) ; } else { return null ; } } public static void add@@ All@@ Children ( IS@@ V@@ DB@@ Child@@ Parent dest , IS@@ V@@ DB@@ Child@@ Parent src ) { for ( IS@@ V@@ DB@@ Child@@ Item c : src . getChildren ( ) ) { dest . add@@ Child@@ Item ( c ) ; } } } </s>
<s> package net . sf . sv@@ editor . core . db ; public interface IS@@ V@@ DB@@ Child@@ Parent extends IS@@ V@@ DB@@ Child@@ Item , IS@@ V@@ DB@@ Add@@ Child@@ Item { Iterable < IS@@ V@@ DB@@ Child@@ Item > getChildren ( ) ; } </s>
<s> package net . sf . sv@@ editor . core . db ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param extends SV@@ DB@@ Item { public SV@@ DB@@ Expr f@@ Default ; public SV@@ DB@@ TypeInfo f@@ Default@@ Type ; public SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param ( ) { super ( "" , SV@@ DB@@ Item@@ Type . Mod@@ If@@ c@@ Class@@ Param ) ; } public SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param ( String name ) { super ( name , SV@@ DB@@ Item@@ Type . Mod@@ If@@ c@@ Class@@ Param ) ; } public SV@@ DB@@ Expr getDefault ( ) { return f@@ Default ; } public void set@@ Default ( SV@@ DB@@ Expr d@@ fl@@ t ) { f@@ Default = d@@ fl@@ t ; } public SV@@ DB@@ TypeInfo getDefault@@ Type ( ) { return f@@ Default@@ Type ; } public void setDefault@@ Type ( SV@@ DB@@ TypeInfo type ) { f@@ Default@@ Type = type ; } public SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param ) super . d@@ uplic@@ ate ( ) ; } public void init ( SV@@ DB@@ Item@@ Base other ) { super . init ( other ) ; f@@ Default = ( ( SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param ) other ) . f@@ Default ; } } </s>
<s> package net . sf . sv@@ editor . core . db ; import java . util . ArrayList ; import java . util . List ; public class SV@@ DB@@ Class@@ Decl extends SV@@ DB@@ Scope@@ Item { public List < SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param > f@@ Params ; public SV@@ DB@@ Type@@ Info@@ Class@@ Type f@@ Class@@ Type ; public SV@@ DB@@ Type@@ Info@@ Class@@ Type f@@ Super@@ Class ; public SV@@ DB@@ Class@@ Decl ( ) { this ( "" ) ; } public SV@@ DB@@ Class@@ Decl ( String name ) { super ( name , SV@@ DB@@ Item@@ Type . Class@@ Decl ) ; } public List < SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param > getParameters ( ) { return f@@ Params ; } public void add@@ Parameters ( List < SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param > params ) { if ( f@@ Params == null ) { f@@ Params = new ArrayList < SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param > ( ) ; } f@@ Params . addAll ( params ) ; } public SV@@ DB@@ Type@@ Info@@ Class@@ Type getClass@@ Type ( ) { return f@@ Class@@ Type ; } public void set@@ Class@@ Type ( SV@@ DB@@ Type@@ Info@@ Class@@ Type cl@@ s_@@ type ) { f@@ Class@@ Type = cl@@ s_@@ type ; } public SV@@ DB@@ Type@@ Info@@ Class@@ Type getSu@@ per@@ Class ( ) { return f@@ Super@@ Class ; } public void set@@ Super@@ Class ( SV@@ DB@@ Type@@ Info@@ Class@@ Type super@@ _@@ class ) { f@@ Super@@ Class = super@@ _@@ class ; } public SV@@ DB@@ Class@@ Decl d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Class@@ Decl ) SV@@ DB@@ Item@@ Utils . d@@ uplic@@ ate ( this ) ; } public void init ( SV@@ DB@@ Item@@ Base other ) { super . init ( other ) ; SV@@ DB@@ Class@@ Decl o = ( SV@@ DB@@ Class@@ Decl ) other ; if ( o . f@@ Params != null ) { f@@ Params = new ArrayList < SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param > ( ) ; for ( SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param p : o . f@@ Params ) { f@@ Params . add ( p ) ; } } else { f@@ Params = null ; } set@@ Super@@ Class ( o . getSu@@ per@@ Class ( ) ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Param@@ Port@@ Decl ; public class SV@@ DB@@ Task extends SV@@ DB@@ Scope@@ Item implements I@@ Field@@ Item@@ Attr { public List < SV@@ DB@@ Param@@ Port@@ Decl > f@@ Params ; public int f@@ Attr ; public SV@@ DB@@ Task ( ) { super ( "" , SV@@ DB@@ Item@@ Type . Task ) ; } public SV@@ DB@@ Task ( String name , SV@@ DB@@ Item@@ Type type ) { super ( name , type ) ; f@@ Params = new ArrayList < SV@@ DB@@ Param@@ Port@@ Decl > ( ) ; } public void set@@ Attr ( int attr ) { f@@ Attr = attr ; } public int get@@ Attr ( ) { return f@@ Attr ; } public void add@@ Param ( SV@@ DB@@ Param@@ Port@@ Decl p ) { p . set@@ Parent ( this ) ; f@@ Params . add ( p ) ; } public List < SV@@ DB@@ Param@@ Port@@ Decl > getPar@@ ams ( ) { return f@@ Params ; } public void set@@ Params ( List < SV@@ DB@@ Param@@ Port@@ Decl > params ) { f@@ Params = params ; for ( SV@@ DB@@ Param@@ Port@@ Decl p : params ) { p . set@@ Parent ( this ) ; } } public void init ( SV@@ DB@@ Item@@ Base other ) { super . init ( other ) ; f@@ Attr = ( ( SV@@ DB@@ Task ) other ) . f@@ Attr ; f@@ Params . clear ( ) ; for ( SV@@ DB@@ Param@@ Port@@ Decl p : ( ( SV@@ DB@@ Task ) other ) . f@@ Params ) { f@@ Params . add ( ( SV@@ DB@@ Param@@ Port@@ Decl ) p . d@@ uplic@@ ate ( ) ) ; } } @ Override public boolean equals ( Object obj ) { if ( obj instanceof SV@@ DB@@ Task ) { boolean ret = super . equals ( obj ) ; SV@@ DB@@ Task o = ( SV@@ DB@@ Task ) obj ; if ( o . f@@ Name == null || f@@ Name == null ) { ret &@@ = ( o . f@@ Name == f@@ Name ) ; } else { ret &@@ = o . f@@ Name . equals ( f@@ Name ) ; } return ret ; } return false ; } } </s>
<s> package net . sf . sv@@ editor . core . db ; public class SV@@ DB@@ Location { public int f@@ Line ; public int f@@ Pos ; public SV@@ DB@@ Location ( int line , int pos ) { f@@ Line = line ; f@@ Pos = pos ; } public SV@@ DB@@ Location ( SV@@ DB@@ Location other ) { f@@ Line = other . f@@ Line ; f@@ Pos = other . f@@ Pos ; } public int getL@@ ine ( ) { return f@@ Line ; } public int get@@ Pos ( ) { return f@@ Pos ; } public void init ( SV@@ DB@@ Location other ) { f@@ Line = other . f@@ Line ; f@@ Pos = other . f@@ Pos ; } public SV@@ DB@@ Location d@@ uplic@@ ate ( ) { return new SV@@ DB@@ Location ( this ) ; } public boolean equals ( Object other ) { if ( other instanceof SV@@ DB@@ Location ) { boolean ret = true ; SV@@ DB@@ Location o = ( SV@@ DB@@ Location ) other ; ret &@@ = ( o . f@@ Line == f@@ Line && o . f@@ Pos == f@@ Pos ) ; return ret ; } return false ; } public String toString ( ) { return ":" + f@@ Line ; } } </s>
<s> package net . sf . sv@@ editor . core . db ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Identifier@@ Expr ; public class SV@@ DB@@ Co@@ ver@@ Cross@@ Bin@@ s@@ S@@ el extends SV@@ DB@@ Item { public SV@@ DB@@ Expr f@@ Select@@ Expr ; public SV@@ DB@@ Co@@ ver@@ Cross@@ Bin@@ s@@ S@@ el ( ) { super ( "" , SV@@ DB@@ Item@@ Type . Co@@ ver@@ Cross@@ Bin@@ s@@ S@@ el ) ; } public SV@@ DB@@ Co@@ ver@@ Cross@@ Bin@@ s@@ S@@ el ( SV@@ DB@@ Identifier@@ Expr id ) { super ( id , SV@@ DB@@ Item@@ Type . Co@@ ver@@ Cross@@ Bin@@ s@@ S@@ el ) ; } public void set@@ Select@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Select@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Select@@ Expr ( ) { return f@@ Select@@ Expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db ; public interface IS@@ V@@ DB@@ Item@@ Base { SV@@ DB@@ Item@@ Type getType ( ) ; SV@@ DB@@ Location getLocation ( ) ; void setLocation ( SV@@ DB@@ Location location ) ; IS@@ V@@ DB@@ Item@@ Base d@@ uplic@@ ate ( ) ; void init ( IS@@ V@@ DB@@ Item@@ Base other ) ; boolean equals ( IS@@ V@@ DB@@ Item@@ Base other , boolean re@@ cur@@ se ) ; } </s>
<s> package net . sf . sv@@ editor . core . db ; public interface I@@ Member@@ Attr { int LOC@@ AL = ( 1 << 0 ) ; } </s>
<s> package net . sf . sv@@ editor . core . db ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Param@@ Port@@ Decl ; public class SV@@ DB@@ Mod@@ If@@ c@@ Decl extends SV@@ DB@@ Scope@@ Item { public List < SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param > f@@ Params ; public List < SV@@ DB@@ Param@@ Port@@ Decl > f@@ Port@@ s ; protected SV@@ DB@@ Mod@@ If@@ c@@ Decl ( String name , SV@@ DB@@ Item@@ Type type ) { super ( name , type ) ; f@@ Params = new ArrayList < SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param > ( ) ; f@@ Port@@ s = new ArrayList < SV@@ DB@@ Param@@ Port@@ Decl > ( ) ; } public List < SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param > getParameters ( ) { return f@@ Params ; } public List < SV@@ DB@@ Param@@ Port@@ Decl > getPort@@ s ( ) { return f@@ Port@@ s ; } public boolean is@@ Parameter@@ iz@@ ed ( ) { return ( f@@ Params != null && f@@ Params . size ( ) > 0 ) ; } public SV@@ DB@@ Mod@@ If@@ c@@ Decl d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Mod@@ If@@ c@@ Decl ) super . d@@ uplic@@ ate ( ) ; } public void init ( SV@@ DB@@ Item@@ Base other ) { super . init ( other ) ; SV@@ DB@@ Mod@@ If@@ c@@ Decl o = ( SV@@ DB@@ Mod@@ If@@ c@@ Decl ) other ; if ( o . f@@ Params != null ) { f@@ Params . clear ( ) ; for ( SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param p : o . f@@ Params ) { f@@ Params . add ( ( SV@@ DB@@ Mod@@ If@@ c@@ Class@@ Param ) p . d@@ uplic@@ ate ( ) ) ; } } else { f@@ Params = null ; } f@@ Port@@ s . clear ( ) ; f@@ Port@@ s . addAll ( o . f@@ Port@@ s ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Bin@@ d extends SV@@ DB@@ Child@@ Item implements IS@@ V@@ DB@@ Add@@ Child@@ Item , IS@@ V@@ DB@@ Named@@ Item { public SV@@ DB@@ Expr f@@ Target@@ Type@@ Name ; public List < SV@@ DB@@ Expr > f@@ Tar@@ getIn@@ st@@ Name@@ List ; public SV@@ DB@@ Mod@@ If@@ c@@ In@@ st f@@ Bind@@ In@@ st ; public SV@@ DB@@ Bin@@ d ( ) { super ( SV@@ DB@@ Item@@ Type . Bin@@ d ) ; f@@ Tar@@ getIn@@ st@@ Name@@ List = new ArrayList < SV@@ DB@@ Expr > ( ) ; } public String getName ( ) { return f@@ Target@@ Type@@ Name . toString ( ) ; } public void set@@ Target@@ Type@@ Name ( SV@@ DB@@ Expr name ) { f@@ Target@@ Type@@ Name = name ; } public SV@@ DB@@ Expr get@@ Target@@ Type@@ Name ( ) { return f@@ Target@@ Type@@ Name ; } public List < SV@@ DB@@ Expr > get@@ Tar@@ getIn@@ st@@ Name@@ List ( ) { return f@@ Tar@@ getIn@@ st@@ Name@@ List ; } public void add@@ Tar@@ getIn@@ st@@ Name ( SV@@ DB@@ Expr name ) { f@@ Tar@@ getIn@@ st@@ Name@@ List . add ( name ) ; } public void set@@ Bind@@ In@@ st ( SV@@ DB@@ Mod@@ If@@ c@@ In@@ st inst ) { f@@ Bind@@ In@@ st = inst ; } public SV@@ DB@@ Mod@@ If@@ c@@ In@@ st get@@ Bind@@ In@@ st ( ) { return f@@ Bind@@ In@@ st ; } public void add@@ Child@@ Item ( IS@@ V@@ DB@@ Child@@ Item item ) { if ( item instanceof SV@@ DB@@ Mod@@ If@@ c@@ In@@ st ) { f@@ Bind@@ In@@ st = ( SV@@ DB@@ Mod@@ If@@ c@@ In@@ st ) item ; } else { f@@ Bind@@ In@@ st = null ; } } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Config@@ Des@@ ign@@ Stmt extends SV@@ DB@@ Stmt { public List < SV@@ DB@@ Expr > f@@ Cell@@ Identi@@ fiers ; public SV@@ DB@@ Config@@ Des@@ ign@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Config@@ Des@@ ign@@ Stmt ) ; f@@ Cell@@ Identi@@ fiers = new ArrayList < SV@@ DB@@ Expr > ( ) ; } public void add@@ Cell@@ Identifier ( SV@@ DB@@ Expr id ) { f@@ Cell@@ Identi@@ fiers . add ( id ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Lab@@ e@@ led@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public String f@@ Label ; public SV@@ DB@@ Lab@@ e@@ led@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Lab@@ e@@ led@@ Stmt ) ; } public String get@@ Label ( ) { return f@@ Label ; } public void set@@ Label ( String label ) { f@@ Label = label ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Constraint@@ Sol@@ ve@@ Before@@ Stmt extends SV@@ DB@@ Stmt { public List < SV@@ DB@@ Expr > f@@ Sol@@ ve@@ Before@@ List ; public List < SV@@ DB@@ Expr > f@@ Sol@@ ve@@ After@@ List ; public SV@@ DB@@ Constraint@@ Sol@@ ve@@ Before@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Constraint@@ Sol@@ ve@@ Before@@ Stmt ) ; f@@ Sol@@ ve@@ Before@@ List = new ArrayList < SV@@ DB@@ Expr > ( ) ; f@@ Sol@@ ve@@ After@@ List = new ArrayList < SV@@ DB@@ Expr > ( ) ; } public List < SV@@ DB@@ Expr > getS@@ ol@@ ve@@ Before@@ List ( ) { return f@@ Sol@@ ve@@ Before@@ List ; } public void add@@ Sol@@ ve@@ Before ( SV@@ DB@@ Expr expr ) { f@@ Sol@@ ve@@ Before@@ List . add ( expr ) ; } public List < SV@@ DB@@ Expr > getS@@ ol@@ ve@@ After@@ List ( ) { return f@@ Sol@@ ve@@ After@@ List ; } public void add@@ Sol@@ ve@@ After ( SV@@ DB@@ Expr expr ) { f@@ Sol@@ ve@@ After@@ List . add ( expr ) ; } public SV@@ DB@@ Constraint@@ Sol@@ ve@@ Before@@ Stmt d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Constraint@@ Sol@@ ve@@ Before@@ Stmt ) super . d@@ uplic@@ ate ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Delay@@ Control@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Expr f@@ Expr ; public SV@@ DB@@ Delay@@ Control@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Delay@@ Control@@ Stmt ) ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Def@@ Param@@ Item extends SV@@ DB@@ Stmt { public SV@@ DB@@ Expr f@@ Target ; public SV@@ DB@@ Expr f@@ Expr ; public SV@@ DB@@ Def@@ Param@@ Item ( ) { super ( SV@@ DB@@ Item@@ Type . Def@@ Param@@ Item ) ; } public void set@@ Target ( SV@@ DB@@ Expr expr ) { f@@ Target = expr ; } public SV@@ DB@@ Expr get@@ Target ( ) { return f@@ Target ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Add@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . attr . SV@@ DB@@ Do@@ Not@@ Save@@ Attr ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ If@@ Stmt extends SV@@ DB@@ Stmt implements IS@@ V@@ DB@@ Add@@ Child@@ Item { public SV@@ DB@@ Expr f@@ Con@@ d@@ Expr ; @ SV@@ DB@@ Do@@ Not@@ Save@@ Attr private int f@@ Add@@ Idx ; public SV@@ DB@@ Stmt f@@ If@@ Stmt ; public SV@@ DB@@ Stmt f@@ El@@ se@@ Stmt ; public SV@@ DB@@ If@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . If@@ Stmt ) ; } public SV@@ DB@@ If@@ Stmt ( SV@@ DB@@ Expr expr ) { super ( SV@@ DB@@ Item@@ Type . If@@ Stmt ) ; f@@ Con@@ d@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Con@@ d ( ) { return f@@ Con@@ d@@ Expr ; } public SV@@ DB@@ Stmt get@@ If@@ Stmt ( ) { return f@@ If@@ Stmt ; } public void set@@ If@@ Stmt ( SV@@ DB@@ Stmt stmt ) { f@@ If@@ Stmt = stmt ; } public SV@@ DB@@ Stmt getE@@ l@@ se@@ Stmt ( ) { return f@@ El@@ se@@ Stmt ; } public void set@@ El@@ se@@ Stmt ( SV@@ DB@@ Stmt stmt ) { f@@ El@@ se@@ Stmt = stmt ; } public void add@@ Child@@ Item ( IS@@ V@@ DB@@ Child@@ Item item ) { if ( f@@ Add@@ Idx ++ == 0 ) { f@@ If@@ Stmt = ( SV@@ DB@@ Stmt ) item ; } else if ( f@@ Add@@ Idx ++ == 1 ) { f@@ El@@ se@@ Stmt = ( SV@@ DB@@ Stmt ) item ; } if ( item != null ) { item . set@@ Parent ( this ) ; } } @ Override public void init ( IS@@ V@@ DB@@ Item@@ Base other ) { SV@@ DB@@ If@@ Stmt o = ( SV@@ DB@@ If@@ Stmt ) other ; if ( o . f@@ Con@@ d@@ Expr != null ) { f@@ Con@@ d@@ Expr = o . f@@ Con@@ d@@ Expr . d@@ uplic@@ ate ( ) ; } else { f@@ Con@@ d@@ Expr = null ; } if ( o . f@@ If@@ Stmt != null ) { f@@ If@@ Stmt = o . f@@ If@@ Stmt . d@@ uplic@@ ate ( ) ; } else { f@@ If@@ Stmt = null ; } if ( o . f@@ El@@ se@@ Stmt != null ) { f@@ El@@ se@@ Stmt = o . f@@ El@@ se@@ Stmt . d@@ uplic@@ ate ( ) ; } else { f@@ El@@ se@@ Stmt = null ; } super . init ( other ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import net . sf . sv@@ editor . core . db . I@@ Field@@ Item@@ Attr ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Parent ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ TypeInfo ; public class SV@@ DB@@ Var@@ Decl@@ Stmt extends SV@@ DB@@ Stmt implements I@@ Field@@ Item@@ Attr , IS@@ V@@ DB@@ Child@@ Parent { public SV@@ DB@@ TypeInfo f@@ TypeInfo ; public int f@@ Field@@ Attr ; public List < SV@@ DB@@ Var@@ Decl@@ Item > f@@ Var@@ List ; public SV@@ DB@@ Var@@ Decl@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Stmt ) ; } public SV@@ DB@@ Var@@ Decl@@ Stmt ( SV@@ DB@@ TypeInfo type , int attr ) { this ( SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Stmt , type , attr ) ; } public SV@@ DB@@ Var@@ Decl@@ Stmt ( SV@@ DB@@ Item@@ Type st@@ m@@ t_@@ type , SV@@ DB@@ TypeInfo type , int attr ) { super ( st@@ m@@ t_@@ type ) ; f@@ TypeInfo = type ; f@@ Var@@ List = new ArrayList < SV@@ DB@@ Var@@ Decl@@ Item > ( ) ; } public static String getName ( SV@@ DB@@ Var@@ Decl@@ Stmt stmt ) { StringBuilder sb = new StringBuilder ( ) ; for ( IS@@ V@@ DB@@ Child@@ Item v@@ i : stmt . getChildren ( ) ) { sb . append ( SV@@ DB@@ Item . getName ( v@@ i ) ) ; sb . append ( ", " ) ; } if ( sb . length ( ) > 2 ) { sb . set@@ Length ( sb . length ( ) - 2 ) ; } return sb . toString ( ) ; } public String getType@@ Name ( ) { if ( f@@ TypeInfo != null ) { return f@@ TypeInfo . getName ( ) ; } else { return null ; } } public void set@@ TypeInfo ( SV@@ DB@@ TypeInfo t@@ i ) { f@@ TypeInfo = t@@ i ; } public SV@@ DB@@ TypeInfo getType@@ Info ( ) { return f@@ TypeInfo ; } public int get@@ Attr ( ) { return f@@ Field@@ Attr ; } public void set@@ Attr ( int attr ) { f@@ Field@@ Attr |= attr ; } public void reset@@ Attr ( int attr ) { f@@ Field@@ Attr = attr ; } public void add@@ Child@@ Item ( IS@@ V@@ DB@@ Child@@ Item item ) { item . set@@ Parent ( this ) ; f@@ Var@@ List . add ( ( SV@@ DB@@ Var@@ Decl@@ Item ) item ) ; } @ SuppressWarnings ( { "unchecked" , "raw@@ types" } ) public Iterable < IS@@ V@@ DB@@ Child@@ Item > getChildren ( ) { return new Iterable < IS@@ V@@ DB@@ Child@@ Item > ( ) { public Iterator < IS@@ V@@ DB@@ Child@@ Item > iterator ( ) { return ( Iterator ) f@@ Var@@ List . iterator ( ) ; } } ; } public SV@@ DB@@ Var@@ Decl@@ Stmt d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Var@@ Decl@@ Stmt ) super . d@@ uplic@@ ate ( ) ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof SV@@ DB@@ Var@@ Decl@@ Stmt ) { SV@@ DB@@ Var@@ Decl@@ Stmt o = ( SV@@ DB@@ Var@@ Decl@@ Stmt ) obj ; if ( f@@ Field@@ Attr != o . f@@ Field@@ Attr ) { return false ; } if ( f@@ TypeInfo == null || o . f@@ TypeInfo == null ) { if ( f@@ TypeInfo != o . f@@ TypeInfo ) { return false ; } } else if ( ! f@@ TypeInfo . equals ( o . f@@ TypeInfo ) ) { return false ; } return super . equals ( obj ) ; } return false ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Config@@ In@@ st@@ C@@ la@@ use@@ Stmt extends SV@@ DB@@ Config@@ Rule@@ St@@ mt@@ Base { public SV@@ DB@@ Expr f@@ In@@ st@@ Name ; public SV@@ DB@@ Config@@ In@@ st@@ C@@ la@@ use@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Config@@ In@@ st@@ C@@ la@@ use@@ Stmt ) ; } public void setIn@@ st@@ Name ( SV@@ DB@@ Expr inst ) { f@@ In@@ st@@ Name = inst ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Null@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Null@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Null@@ Stmt ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ C@@ lock@@ ing@@ Event@@ Expr ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ C@@ lock@@ ing@@ Event@@ Expr . C@@ lock@@ ing@@ EventType ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Al@@ way@@ s@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public enum Al@@ way@@ s@@ Type { Al@@ way@@ s , Al@@ way@@ s@@ Com@@ b , Al@@ way@@ s@@ Latch , Al@@ way@@ s@@ FF } ; public Al@@ way@@ s@@ Type f@@ Al@@ way@@ s@@ Type ; public SV@@ DB@@ C@@ lock@@ ing@@ Event@@ Expr f@@ Al@@ way@@ s@@ Event@@ Expr@@ Type ; public SV@@ DB@@ Al@@ way@@ s@@ Stmt ( ) { this ( Al@@ way@@ s@@ Type . Al@@ way@@ s ) ; f@@ Al@@ way@@ s@@ Event@@ Expr@@ Type = new SV@@ DB@@ C@@ lock@@ ing@@ Event@@ Expr ( ) ; } public SV@@ DB@@ Al@@ way@@ s@@ Stmt ( Al@@ way@@ s@@ Type type ) { super ( SV@@ DB@@ Item@@ Type . Al@@ way@@ s@@ Stmt ) ; f@@ Al@@ way@@ s@@ Type = type ; f@@ Al@@ way@@ s@@ Event@@ Expr@@ Type = new SV@@ DB@@ C@@ lock@@ ing@@ Event@@ Expr ( ) ; } public Al@@ way@@ s@@ Type get@@ Al@@ way@@ s@@ Type ( ) { return f@@ Al@@ way@@ s@@ Type ; } public C@@ lock@@ ing@@ EventType get@@ Al@@ way@@ s@@ EventType ( ) { return f@@ Al@@ way@@ s@@ Event@@ Expr@@ Type . getC@@ lock@@ ing@@ EventType ( ) ; } public void set@@ Al@@ way@@ s@@ EventType ( C@@ lock@@ ing@@ EventType type ) { f@@ Al@@ way@@ s@@ Event@@ Expr@@ Type . setC@@ lock@@ ing@@ EventType ( type ) ; } public SV@@ DB@@ Expr getEvent@@ Expr ( ) { return f@@ Al@@ way@@ s@@ Event@@ Expr@@ Type . get@@ Expr ( ) ; } public void set@@ Event@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Al@@ way@@ s@@ Event@@ Expr@@ Type . set@@ Expr ( expr ) ; } public SV@@ DB@@ C@@ lock@@ ing@@ Event@@ Expr getC@@ B@@ Event@@ Expr ( ) { return f@@ Al@@ way@@ s@@ Event@@ Expr@@ Type ; } public void setC@@ B@@ Event@@ Expr ( SV@@ DB@@ C@@ lock@@ ing@@ Event@@ Expr cb@@ Expr ) { f@@ Al@@ way@@ s@@ Event@@ Expr@@ Type = cb@@ Expr ; } @ Override public SV@@ DB@@ Al@@ way@@ s@@ Stmt d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Al@@ way@@ s@@ Stmt ) super . d@@ uplic@@ ate ( ) ; } @ Override public void init ( IS@@ V@@ DB@@ Item@@ Base other ) { super . init ( other ) ; f@@ Al@@ way@@ s@@ Type = ( ( SV@@ DB@@ Al@@ way@@ s@@ Stmt ) other ) . f@@ Al@@ way@@ s@@ Type ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof SV@@ DB@@ Al@@ way@@ s@@ Stmt ) { boolean ret = true ; ret &@@ = ( ( SV@@ DB@@ Al@@ way@@ s@@ Stmt ) obj ) . f@@ Al@@ way@@ s@@ Type . equals ( f@@ Al@@ way@@ s@@ Type ) ; ret &@@ = super . equals ( obj ) ; return ret ; } return false ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Named@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Co@@ ver@@ age@@ Option@@ Stmt extends SV@@ DB@@ Stmt implements IS@@ V@@ DB@@ Named@@ Item { public boolean f@@ Is@@ Type@@ Option ; public String f@@ Name ; public SV@@ DB@@ Expr f@@ Expr ; public SV@@ DB@@ Co@@ ver@@ age@@ Option@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Co@@ ver@@ age@@ Option@@ Stmt ) ; } public SV@@ DB@@ Co@@ ver@@ age@@ Option@@ Stmt ( String name , boolean is_@@ type@@ _@@ option ) { super ( SV@@ DB@@ Item@@ Type . Co@@ ver@@ age@@ Option@@ Stmt ) ; f@@ Name = name ; f@@ Is@@ Type@@ Option = is_@@ type@@ _@@ option ; } public boolean is@@ Type@@ Option ( ) { return f@@ Is@@ Type@@ Option ; } public void setName ( String name ) { f@@ Name = name ; } public String getName ( ) { return f@@ Name ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Wait@@ For@@ k@@ Stmt extends SV@@ DB@@ Wait@@ Stmt { public SV@@ DB@@ Wait@@ For@@ k@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Wait@@ For@@ k@@ Stmt ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Item extends SV@@ DB@@ Stmt { public SV@@ DB@@ Expr f@@ L@@ H@@ S ; public SV@@ DB@@ Expr f@@ R@@ H@@ S ; public boolean f@@ Is@@ Dist ; public SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Item ( ) { super ( SV@@ DB@@ Item@@ Type . Constraint@@ D@@ ist@@ List@@ Item ) ; } public void set@@ L@@ H@@ S ( SV@@ DB@@ Expr l@@ hs ) { f@@ L@@ H@@ S = l@@ hs ; } public SV@@ DB@@ Expr getL@@ H@@ S ( ) { return f@@ L@@ H@@ S ; } public void setR@@ H@@ S ( SV@@ DB@@ Expr r@@ hs ) { f@@ R@@ H@@ S = r@@ hs ; } public SV@@ DB@@ Expr getR@@ H@@ S ( ) { return f@@ R@@ H@@ S ; } public boolean is@@ Dist ( ) { return f@@ Is@@ Dist ; } public void set@@ Is@@ Dist ( boolean is_@@ dist ) { f@@ Is@@ Dist = is_@@ dist ; } public SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Item d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Item ) super . d@@ uplic@@ ate ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Constraint@@ Set@@ Stmt extends SV@@ DB@@ Stmt { public List < SV@@ DB@@ Stmt > f@@ Constraint@@ List ; public SV@@ DB@@ Constraint@@ Set@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Constraint@@ Set@@ Stmt ) ; f@@ Constraint@@ List = new ArrayList < SV@@ DB@@ Stmt > ( ) ; } public List < SV@@ DB@@ Stmt > get@@ Constraint@@ List ( ) { return f@@ Constraint@@ List ; } public void add@@ Constraint@@ Stmt ( SV@@ DB@@ Stmt stmt ) { f@@ Constraint@@ List . add ( stmt ) ; } public SV@@ DB@@ Constraint@@ Set@@ Stmt d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Constraint@@ Set@@ Stmt ) super . d@@ uplic@@ ate ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Fore@@ ach@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Expr f@@ Con@@ d ; public SV@@ DB@@ Fore@@ ach@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Fore@@ ach@@ Stmt ) ; } public void set@@ Con@@ d ( SV@@ DB@@ Expr con@@ d ) { f@@ Con@@ d = con@@ d ; } public SV@@ DB@@ Expr get@@ Con@@ d ( ) { return f@@ Con@@ d ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Parent ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Import@@ Stmt extends SV@@ DB@@ Stmt implements IS@@ V@@ DB@@ Child@@ Parent { public List < SV@@ DB@@ Import@@ Item > f@@ Import@@ List ; public SV@@ DB@@ Import@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Import@@ Stmt ) ; f@@ Import@@ List = new ArrayList < SV@@ DB@@ Import@@ Item > ( ) ; } public void add@@ Child@@ Item ( IS@@ V@@ DB@@ Child@@ Item item ) { item . set@@ Parent ( this ) ; f@@ Import@@ List . add ( ( SV@@ DB@@ Import@@ Item ) item ) ; } @ SuppressWarnings ( { "unchecked" , "raw@@ types" } ) public Iterable < IS@@ V@@ DB@@ Child@@ Item > getChildren ( ) { return new Iterable < IS@@ V@@ DB@@ Child@@ Item > ( ) { public Iterator < IS@@ V@@ DB@@ Child@@ Item > iterator ( ) { return ( Iterator ) f@@ Import@@ List . iterator ( ) ; } } ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Wait@@ Order@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Wait@@ Order@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Wait@@ Order@@ Stmt ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Named@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ TypeInfo ; public class SV@@ DB@@ Typed@@ ef@@ Stmt extends SV@@ DB@@ Stmt implements IS@@ V@@ DB@@ Named@@ Item { public SV@@ DB@@ TypeInfo f@@ TypeInfo ; public String f@@ Name ; public SV@@ DB@@ Typed@@ ef@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) ; } public SV@@ DB@@ Typed@@ ef@@ Stmt ( SV@@ DB@@ TypeInfo type ) { super ( SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) ; f@@ TypeInfo = type ; } public SV@@ DB@@ Typed@@ ef@@ Stmt ( SV@@ DB@@ TypeInfo type , String name ) { this ( type ) ; f@@ Name = name ; } public String getName ( ) { return f@@ Name ; } public void setName ( String name ) { f@@ Name = name ; } public SV@@ DB@@ TypeInfo getType@@ Info ( ) { return f@@ TypeInfo ; } @ Override public SV@@ DB@@ Typed@@ ef@@ Stmt d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Typed@@ ef@@ Stmt ) super . d@@ uplic@@ ate ( ) ; } @ Override public void init ( IS@@ V@@ DB@@ Item@@ Base other ) { super . init ( other ) ; SV@@ DB@@ Typed@@ ef@@ Stmt ot = ( SV@@ DB@@ Typed@@ ef@@ Stmt ) other ; f@@ TypeInfo = ot . f@@ TypeInfo . d@@ uplic@@ ate ( ) ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof SV@@ DB@@ Typed@@ ef@@ Stmt ) { SV@@ DB@@ Typed@@ ef@@ Stmt o = ( SV@@ DB@@ Typed@@ ef@@ Stmt ) obj ; if ( ! o . f@@ TypeInfo . equals ( f@@ TypeInfo ) ) { return false ; } return super . equals ( obj ) ; } return false ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ As@@ sert@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Expr f@@ Expr ; public SV@@ DB@@ Expr f@@ Delay ; public SV@@ DB@@ Action@@ Block@@ Stmt f@@ Action@@ Block ; public SV@@ DB@@ As@@ sert@@ Stmt ( ) { this ( SV@@ DB@@ Item@@ Type . As@@ sert@@ Stmt ) ; } protected SV@@ DB@@ As@@ sert@@ Stmt ( SV@@ DB@@ Item@@ Type type ) { super ( type ) ; } public void set@@ Delay ( SV@@ DB@@ Expr delay ) { f@@ Delay = delay ; } public SV@@ DB@@ Expr getD@@ el@@ ay ( ) { return f@@ Delay ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } public void set@@ Action@@ Block ( SV@@ DB@@ Action@@ Block@@ Stmt stmt ) { f@@ Action@@ Block = stmt ; } public SV@@ DB@@ Action@@ Block@@ Stmt getAction@@ Block ( ) { return f@@ Action@@ Block ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Dis@@ able@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Expr f@@ Hierarch@@ ical@@ Id ; public SV@@ DB@@ Dis@@ able@@ Stmt ( ) { this ( SV@@ DB@@ Item@@ Type . Dis@@ able@@ Stmt ) ; } protected SV@@ DB@@ Dis@@ able@@ Stmt ( SV@@ DB@@ Item@@ Type type ) { super ( type ) ; } public void set@@ Hierarch@@ ical@@ Id ( SV@@ DB@@ Expr expr ) { f@@ Hierarch@@ ical@@ Id = expr ; } public SV@@ DB@@ Expr getH@@ i@@ erarch@@ ical@@ Id ( ) { return f@@ Hierarch@@ ical@@ Id ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Pro@@ ced@@ ural@@ Cont@@ Assign@@ Stmt extends SV@@ DB@@ Stmt { public enum Assign@@ Type { As@@ sign , De@@ as@@ sign , For@@ ce , Rele@@ ase } ; public Assign@@ Type f@@ Assign@@ Type ; public SV@@ DB@@ Expr f@@ Expr ; public SV@@ DB@@ Pro@@ ced@@ ural@@ Cont@@ Assign@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Pro@@ ced@@ ural@@ Cont@@ Assign@@ Stmt ) ; } public SV@@ DB@@ Pro@@ ced@@ ural@@ Cont@@ Assign@@ Stmt ( Assign@@ Type type ) { super ( SV@@ DB@@ Item@@ Type . Pro@@ ced@@ ural@@ Cont@@ Assign@@ Stmt ) ; f@@ Assign@@ Type = type ; } public Assign@@ Type get@@ Assign@@ Type ( ) { return f@@ Assign@@ Type ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; public interface IS@@ V@@ DB@@ Body@@ Stmt extends IS@@ V@@ DB@@ Child@@ Item { SV@@ DB@@ Stmt getBod@@ y ( ) ; void set@@ Body ( SV@@ DB@@ Stmt stmt ) ; } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Contin@@ ue@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Contin@@ ue@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Contin@@ ue@@ Stmt ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Config@@ Cell@@ C@@ la@@ use@@ Stmt extends SV@@ DB@@ Config@@ Rule@@ St@@ mt@@ Base { public SV@@ DB@@ Expr f@@ Cell@@ Id ; public SV@@ DB@@ Config@@ Cell@@ C@@ la@@ use@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Config@@ Cell@@ C@@ la@@ use@@ Stmt ) ; } public void setCell@@ Id ( SV@@ DB@@ Expr id ) { f@@ Cell@@ Id = id ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Event@@ Control@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Expr f@@ Expr ; public SV@@ DB@@ Event@@ Control@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Event@@ Control@@ Stmt ) ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ For@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Stmt f@@ Init@@ Expr ; public SV@@ DB@@ Stmt f@@ Test@@ Stmt ; public SV@@ DB@@ Stmt f@@ In@@ cr@@ Stmt ; public SV@@ DB@@ For@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . For@@ Stmt ) ; } public SV@@ DB@@ Stmt getIn@@ it@@ Expr ( ) { return f@@ Init@@ Expr ; } public void set@@ Init@@ Stmt ( SV@@ DB@@ Stmt stmt ) { f@@ Init@@ Expr = stmt ; } public SV@@ DB@@ Stmt getTest@@ Expr ( ) { return f@@ Test@@ Stmt ; } public void setTest@@ Stmt ( SV@@ DB@@ Stmt stmt ) { f@@ Test@@ Stmt = stmt ; } public SV@@ DB@@ Stmt getIn@@ cr@@ Stmt ( ) { return f@@ In@@ cr@@ Stmt ; } public void setIn@@ cr@@ stmt ( SV@@ DB@@ Stmt stmt ) { f@@ In@@ cr@@ Stmt = stmt ; } public SV@@ DB@@ For@@ Stmt d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ For@@ Stmt ) super . d@@ uplic@@ ate ( ) ; } public void init ( IS@@ V@@ DB@@ Item@@ Base other ) { super . init ( other ) ; SV@@ DB@@ For@@ Stmt o = ( SV@@ DB@@ For@@ Stmt ) other ; if ( o . f@@ In@@ cr@@ Stmt != null ) { f@@ In@@ cr@@ Stmt = o . f@@ In@@ cr@@ Stmt . d@@ uplic@@ ate ( ) ; } else { f@@ In@@ cr@@ Stmt = null ; } if ( o . f@@ Test@@ Stmt != null ) { f@@ Test@@ Stmt = o . f@@ Test@@ Stmt . d@@ uplic@@ ate ( ) ; } else { f@@ Test@@ Stmt = null ; } if ( o . f@@ Init@@ Expr != null ) { f@@ Init@@ Expr = o . f@@ Init@@ Expr . d@@ uplic@@ ate ( ) ; } else { f@@ Init@@ Expr = null ; } } @ Override public boolean equals ( IS@@ V@@ DB@@ Item@@ Base obj , boolean f@@ ull ) { if ( ! super . equals ( obj , f@@ ull ) ) { return false ; } if ( ! ( obj instanceof SV@@ DB@@ For@@ Stmt ) ) { return false ; } SV@@ DB@@ For@@ Stmt o = ( SV@@ DB@@ For@@ Stmt ) obj ; boolean ret = true ; if ( f@@ ull ) { if ( f@@ Init@@ Expr == null || o . f@@ Init@@ Expr == null ) { ret &@@ = ( f@@ Init@@ Expr == o . f@@ Init@@ Expr ) ; } else { ret &@@ = f@@ Init@@ Expr . equals ( o . f@@ Init@@ Expr ) ; } if ( f@@ Test@@ Stmt == null || o . getTest@@ Expr ( ) == null ) { ret &@@ = ( f@@ Test@@ Stmt == o . getTest@@ Expr ( ) ) ; } else { ret &@@ = f@@ Test@@ Stmt . equals ( o . getTest@@ Expr ( ) ) ; } if ( f@@ In@@ cr@@ Stmt == null || o . getIn@@ cr@@ Stmt ( ) == null ) { ret &@@ = ( f@@ In@@ cr@@ Stmt == o . getIn@@ cr@@ Stmt ( ) ) ; } else { ret &@@ = f@@ In@@ cr@@ Stmt . equals ( o . getIn@@ cr@@ Stmt ( ) ) ; } } return ret ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Constraint@@ Fore@@ ach@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Expr f@@ Expr ; public SV@@ DB@@ Stmt f@@ Stmt ; public SV@@ DB@@ Constraint@@ Fore@@ ach@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Constraint@@ Fore@@ ach@@ Stmt ) ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } public void set@@ Stmt ( SV@@ DB@@ Stmt stmt ) { f@@ Stmt = stmt ; } public SV@@ DB@@ Stmt get@@ Stmt ( ) { return f@@ Stmt ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ As@@ sum@@ e@@ Stmt extends SV@@ DB@@ As@@ sert@@ Stmt { public SV@@ DB@@ As@@ sum@@ e@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . As@@ sum@@ e@@ Stmt ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Case@@ Item extends SV@@ DB@@ Body@@ Stmt { public List < SV@@ DB@@ Expr > f@@ Case@@ Expr@@ List ; public SV@@ DB@@ Case@@ Item ( ) { super ( SV@@ DB@@ Item@@ Type . Case@@ Item ) ; f@@ Case@@ Expr@@ List = new ArrayList < SV@@ DB@@ Expr > ( ) ; } public List < SV@@ DB@@ Expr > get@@ Expr@@ List ( ) { return f@@ Case@@ Expr@@ List ; } public void add@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Case@@ Expr@@ List . add ( expr ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Parent ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Export@@ Stmt extends SV@@ DB@@ Stmt implements IS@@ V@@ DB@@ Child@@ Parent { public List < SV@@ DB@@ Export@@ Item > f@@ Export@@ List ; public SV@@ DB@@ Export@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Export@@ Stmt ) ; f@@ Export@@ List = new ArrayList < SV@@ DB@@ Export@@ Item > ( ) ; } public void add@@ Child@@ Item ( IS@@ V@@ DB@@ Child@@ Item item ) { item . set@@ Parent ( this ) ; f@@ Export@@ List . add ( ( SV@@ DB@@ Export@@ Item ) item ) ; } @ SuppressWarnings ( { "unchecked" , "raw@@ types" } ) public Iterable < IS@@ V@@ DB@@ Child@@ Item > getChildren ( ) { return new Iterable < IS@@ V@@ DB@@ Child@@ Item > ( ) { public Iterator < IS@@ V@@ DB@@ Child@@ Item > iterator ( ) { return ( Iterator ) f@@ Export@@ List . iterator ( ) ; } } ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Repeat@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Expr f@@ Repeat@@ Expr ; public SV@@ DB@@ Repeat@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Repeat@@ Stmt ) ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Repeat@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Repeat@@ Expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Add@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Parent ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . attr . SV@@ DB@@ Do@@ Not@@ Save@@ Attr ; import net . sf . sv@@ editor . core . db . utils . SV@@ DB@@ Single@@ Item@@ Iterable ; public class SV@@ DB@@ Body@@ Stmt extends SV@@ DB@@ Stmt implements IS@@ V@@ DB@@ Body@@ Stmt , IS@@ V@@ DB@@ Add@@ Child@@ Item , IS@@ V@@ DB@@ Child@@ Parent { public SV@@ DB@@ Stmt f@@ Body ; @ SV@@ DB@@ Do@@ Not@@ Save@@ Attr private int f@@ Add@@ Idx ; protected SV@@ DB@@ Body@@ Stmt ( SV@@ DB@@ Item@@ Type st@@ m@@ t_@@ type ) { super ( st@@ m@@ t_@@ type ) ; } public void set@@ Body ( SV@@ DB@@ Stmt stmt ) { f@@ Body = stmt ; } public SV@@ DB@@ Stmt getBod@@ y ( ) { return f@@ Body ; } public Iterable < IS@@ V@@ DB@@ Child@@ Item > getChildren ( ) { return new SV@@ DB@@ Single@@ Item@@ Iterable < IS@@ V@@ DB@@ Child@@ Item > ( f@@ Body ) ; } public void add@@ Child@@ Item ( IS@@ V@@ DB@@ Child@@ Item item ) { if ( f@@ Add@@ Idx ++ == 0 ) { f@@ Body = ( SV@@ DB@@ Stmt ) item ; if ( f@@ Body != null ) { f@@ Body . set@@ Parent ( this ) ; } } } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Co@@ ver@@ Stmt extends SV@@ DB@@ As@@ sert@@ Stmt { public SV@@ DB@@ Co@@ ver@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Co@@ ver@@ Stmt ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Co@@ ver@@ age@@ Cross@@ Bin@@ s@@ Select@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Co@@ ver@@ age@@ Bin@@ s@@ Type f@@ Bin@@ s@@ Type ; public SV@@ DB@@ Expr f@@ Bin@@ s@@ Name ; public SV@@ DB@@ Expr f@@ Select@@ Condition ; public SV@@ DB@@ Expr f@@ I@@ ff@@ Expr ; public SV@@ DB@@ Co@@ ver@@ age@@ Cross@@ Bin@@ s@@ Select@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Co@@ ver@@ age@@ Cross@@ Bin@@ s@@ Select@@ Stmt ) ; } public SV@@ DB@@ Co@@ ver@@ age@@ Bin@@ s@@ Type get@@ Bin@@ s@@ Type ( ) { return f@@ Bin@@ s@@ Type ; } public void set@@ Bin@@ s@@ Type ( SV@@ DB@@ Co@@ ver@@ age@@ Bin@@ s@@ Type type ) { f@@ Bin@@ s@@ Type = type ; } public void set@@ Bin@@ s@@ Type ( String type ) { if ( type . equals ( "@@ ignore@@ _@@ bin@@ s" ) ) { f@@ Bin@@ s@@ Type = SV@@ DB@@ Co@@ ver@@ age@@ Bin@@ s@@ Type . Ignore@@ Bin@@ s ; } else if ( type . equals ( "@@ il@@ legal@@ _@@ bin@@ s" ) ) { f@@ Bin@@ s@@ Type = SV@@ DB@@ Co@@ ver@@ age@@ Bin@@ s@@ Type . Illegal@@ Bin@@ s ; } else { f@@ Bin@@ s@@ Type = SV@@ DB@@ Co@@ ver@@ age@@ Bin@@ s@@ Type . Bin@@ s ; } } public SV@@ DB@@ Expr get@@ Bin@@ s@@ Name ( ) { return f@@ Bin@@ s@@ Name ; } public void set@@ Bin@@ s@@ Name ( SV@@ DB@@ Expr name ) { f@@ Bin@@ s@@ Name = name ; } public SV@@ DB@@ Expr get@@ Select@@ Condition ( ) { return f@@ Select@@ Condition ; } public void set@@ Select@@ Condition ( SV@@ DB@@ Expr expr ) { f@@ Select@@ Condition = expr ; } public SV@@ DB@@ Expr get@@ I@@ ff@@ Expr ( ) { return f@@ I@@ ff@@ Expr ; } public void set@@ I@@ ff@@ Expr ( SV@@ DB@@ Expr if@@ f ) { f@@ I@@ ff@@ Expr = if@@ f ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Initial@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Initial@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Initial@@ Stmt ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Stmt extends SV@@ DB@@ Stmt { public List < SV@@ DB@@ Expr > f@@ L@@ H@@ S ; public List < SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Item > f@@ D@@ ist@@ Items ; public SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Constraint@@ D@@ ist@@ List@@ Stmt ) ; f@@ L@@ H@@ S = new ArrayList < SV@@ DB@@ Expr > ( ) ; f@@ D@@ ist@@ Items = new ArrayList < SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Item > ( ) ; } public void add@@ L@@ H@@ S ( SV@@ DB@@ Expr l@@ hs ) { f@@ L@@ H@@ S . add ( l@@ hs ) ; } public List < SV@@ DB@@ Expr > getL@@ H@@ S ( ) { return f@@ L@@ H@@ S ; } public List < SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Item > getD@@ ist@@ Items ( ) { return f@@ D@@ ist@@ Items ; } public void add@@ D@@ ist@@ Item ( SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Item item ) { f@@ D@@ ist@@ Items . add ( item ) ; } public SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Stmt d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Constraint@@ D@@ ist@@ List@@ Stmt ) super . d@@ uplic@@ ate ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Export@@ Item extends SV@@ DB@@ Stmt { public String f@@ Ex@@ port ; public SV@@ DB@@ Export@@ Item ( ) { super ( SV@@ DB@@ Item@@ Type . Export@@ Item ) ; } public String getEx@@ port ( ) { return f@@ Ex@@ port ; } public void set@@ Ex@@ port ( String exp ) { f@@ Ex@@ port = exp ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Constraint@@ Impl@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Expr f@@ Expr ; public SV@@ DB@@ Stmt f@@ Constraint ; public SV@@ DB@@ Constraint@@ Impl@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Constraint@@ Impl@@ Stmt ) ; } public SV@@ DB@@ Constraint@@ Impl@@ Stmt ( SV@@ DB@@ Expr expr , SV@@ DB@@ Stmt constra@@ int ) { super ( SV@@ DB@@ Item@@ Type . Constraint@@ Impl@@ Stmt ) ; f@@ Expr = expr ; f@@ Constraint = constra@@ int ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } public SV@@ DB@@ Stmt get@@ Constraint@@ Set ( ) { return f@@ Constraint ; } public SV@@ DB@@ Constraint@@ Impl@@ Stmt d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Constraint@@ Impl@@ Stmt ) super . d@@ uplic@@ ate ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Expr@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Expr f@@ Expr ; public SV@@ DB@@ Expr@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Expr@@ Stmt ) ; } public SV@@ DB@@ Expr@@ Stmt ( SV@@ DB@@ Expr expr ) { super ( SV@@ DB@@ Item@@ Type . Expr@@ Stmt ) ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Expr = expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Scope@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Location ; import net . sf . sv@@ editor . core . db . attr . SV@@ DB@@ Parent@@ Attr ; public class SV@@ DB@@ Block@@ Stmt extends SV@@ DB@@ Stmt implements IS@@ V@@ DB@@ Scope@@ Item { @ SV@@ DB@@ Parent@@ Attr public IS@@ V@@ DB@@ Child@@ Item f@@ Parent ; public List < IS@@ V@@ DB@@ Item@@ Base > f@@ Items ; public SV@@ DB@@ Location f@@ End@@ Location ; public String f@@ Block@@ Name ; public SV@@ DB@@ Block@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Block@@ Stmt ) ; f@@ Block@@ Name = "" ; f@@ Items = new ArrayList < IS@@ V@@ DB@@ Item@@ Base > ( ) ; } public SV@@ DB@@ Block@@ Stmt ( SV@@ DB@@ Item@@ Type type ) { super ( type ) ; f@@ Block@@ Name = "" ; f@@ Items = new ArrayList < IS@@ V@@ DB@@ Item@@ Base > ( ) ; } public void add@@ Child@@ Item ( IS@@ V@@ DB@@ Child@@ Item item ) { f@@ Items . add ( item ) ; if ( item != null ) { item . set@@ Parent ( this ) ; } } @ SuppressWarnings ( { "unchecked" , "raw@@ types" } ) public Iterable < IS@@ V@@ DB@@ Child@@ Item > getChildren ( ) { return new Iterable < IS@@ V@@ DB@@ Child@@ Item > ( ) { public Iterator < IS@@ V@@ DB@@ Child@@ Item > iterator ( ) { return ( Iterator ) f@@ Items . iterator ( ) ; } } ; } public void add@@ Item ( IS@@ V@@ DB@@ Item@@ Base item ) { f@@ Items . add ( item ) ; if ( item != null && item instanceof IS@@ V@@ DB@@ Child@@ Item ) { ( ( IS@@ V@@ DB@@ Child@@ Item ) item ) . set@@ Parent ( this ) ; } } public String getBlock@@ Name ( ) { return f@@ Block@@ Name ; } public void set@@ Block@@ Name ( String name ) { f@@ Block@@ Name = name ; } public IS@@ V@@ DB@@ Child@@ Item getParent ( ) { return f@@ Parent ; } public void set@@ Parent ( IS@@ V@@ DB@@ Child@@ Item parent ) { f@@ Parent = parent ; } public SV@@ DB@@ Location getEnd@@ Location ( ) { return f@@ End@@ Location ; } public void set@@ End@@ Location ( SV@@ DB@@ Location loc ) { f@@ End@@ Location = loc ; } public List < IS@@ V@@ DB@@ Item@@ Base > get@@ Items ( ) { return f@@ Items ; } @ Override public SV@@ DB@@ Block@@ Stmt d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Block@@ Stmt ) super . d@@ uplic@@ ate ( ) ; } @ Override public void init ( IS@@ V@@ DB@@ Item@@ Base other ) { SV@@ DB@@ Block@@ Stmt o = ( SV@@ DB@@ Block@@ Stmt ) other ; super . init ( other ) ; f@@ Block@@ Name = o . getBlock@@ Name ( ) ; if ( o . getEnd@@ Location ( ) == null ) { f@@ End@@ Location = null ; } else { f@@ End@@ Location = o . getEnd@@ Location ( ) . d@@ uplic@@ ate ( ) ; } f@@ Items . clear ( ) ; for ( IS@@ V@@ DB@@ Item@@ Base i : o . get@@ Items ( ) ) { f@@ Items . add ( i . d@@ uplic@@ ate ( ) ) ; } f@@ Parent = o . getParent ( ) ; } @ Override public boolean equals ( IS@@ V@@ DB@@ Item@@ Base obj , boolean f@@ ull ) { if ( ! super . equals ( obj , f@@ ull ) ) { return false ; } boolean ret = true ; return ret ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ TypeInfo ; public class SV@@ DB@@ Param@@ Port@@ Decl extends SV@@ DB@@ Var@@ Decl@@ Stmt { public static final int Direc@@ tion@@ _@@ Ref = ( 1 << 19 ) ; public static final int Direc@@ tion@@ _@@ Con@@ st = ( 1 << 20 ) ; public static final int Direc@@ tion@@ _@@ Var = ( 1 << 21 ) ; public static final int Direc@@ tion@@ _@@ Input = ( 1 << 16 ) ; public static final int Direc@@ tion@@ _@@ Output = ( 1 << 17 ) ; public static final int Direc@@ tion@@ _@@ In@@ out = ( 1 << 18 ) ; public static final int W@@ ire@@ Type@@ _@@ Shi@@ ft = 20 ; public static final int W@@ ire@@ Type@@ _n@@ one = ( 0 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int W@@ ire@@ Type@@ _@@ sup@@ pl@@ y@@ 0 = ( 1 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int Direc@@ tion@@ _@@ sup@@ pl@@ y1 = ( 2 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int Direc@@ tion@@ _@@ tr@@ i = ( 3 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int Direc@@ tion@@ _@@ tri@@ and = ( 4 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int Direc@@ tion@@ _@@ tri@@ or = ( 5 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int Direc@@ tion@@ _@@ tri@@ re@@ g = ( 6 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int Direc@@ tion@@ _@@ tri@@ 0 = ( 7 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int Direc@@ tion@@ _@@ tri@@ 1 = ( 8 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int Direc@@ tion@@ _@@ u@@ w@@ ir@@ e = ( 9 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int Direc@@ tion@@ _@@ w@@ ir@@ e = ( 10 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int Direc@@ tion@@ _@@ w@@ and = ( 11 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public static final int Direc@@ tion@@ _@@ w@@ or = ( 12 << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ; public int f@@ Dir ; public SV@@ DB@@ Param@@ Port@@ Decl ( ) { super ( SV@@ DB@@ Item@@ Type . Param@@ Port@@ Decl , null , 0 ) ; } public SV@@ DB@@ Param@@ Port@@ Decl ( SV@@ DB@@ TypeInfo type ) { super ( SV@@ DB@@ Item@@ Type . Param@@ Port@@ Decl , type , 0 ) ; f@@ Dir = Direc@@ tion@@ _@@ Input ; } public void set@@ Dir ( int dir ) { f@@ Dir = dir ; } public int get@@ Dir ( ) { return f@@ Dir ; } public int getW@@ ire@@ Type ( ) { return ( f@@ Dir & ( 0x@@ F << W@@ ire@@ Type@@ _@@ Shi@@ ft ) ) ; } public SV@@ DB@@ Param@@ Port@@ Decl d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Param@@ Port@@ Decl ) super . d@@ uplic@@ ate ( ) ; } public void init ( SV@@ DB@@ Item@@ Base other ) { super . init ( other ) ; f@@ Dir = ( ( SV@@ DB@@ Param@@ Port@@ Decl ) other ) . f@@ Dir ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof SV@@ DB@@ Param@@ Port@@ Decl ) { SV@@ DB@@ Param@@ Port@@ Decl o = ( SV@@ DB@@ Param@@ Port@@ Decl ) obj ; if ( o . f@@ Dir != f@@ Dir ) { return false ; } return super . equals ( obj ) ; } return false ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Assign@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Expr f@@ L@@ H@@ S ; public String f@@ Op ; public SV@@ DB@@ Expr f@@ Delay@@ Expr ; public SV@@ DB@@ Expr f@@ R@@ H@@ S ; public SV@@ DB@@ Assign@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Assign@@ Stmt ) ; } public void set@@ L@@ H@@ S ( SV@@ DB@@ Expr l@@ hs ) { f@@ L@@ H@@ S = l@@ hs ; } public SV@@ DB@@ Expr getL@@ H@@ S ( ) { return f@@ L@@ H@@ S ; } public void set@@ Op ( String op ) { f@@ Op = op ; } public String get@@ Op ( ) { return f@@ Op ; } public void setR@@ H@@ S ( SV@@ DB@@ Expr expr ) { f@@ R@@ H@@ S = expr ; } public SV@@ DB@@ Expr getR@@ H@@ S ( ) { return f@@ R@@ H@@ S ; } public void set@@ Delay@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Delay@@ Expr = expr ; } public SV@@ DB@@ Expr getD@@ el@@ ay@@ Expr ( ) { return f@@ Delay@@ Expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Param@@ Value@@ Assign@@ List ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Config@@ Rule@@ St@@ mt@@ Base extends SV@@ DB@@ Stmt { public boolean f@@ Is@@ Li@@ b@@ List ; public List < SV@@ DB@@ Expr > f@@ Li@@ b@@ Use@@ List ; public SV@@ DB@@ Expr f@@ Li@@ b@@ Cell@@ Id ; public SV@@ DB@@ Param@@ Value@@ Assign@@ List f@@ Param@@ Value@@ As@@ sign ; public SV@@ DB@@ Config@@ Rule@@ St@@ mt@@ Base ( SV@@ DB@@ Item@@ Type type ) { super ( type ) ; f@@ Li@@ b@@ Use@@ List = new ArrayList < SV@@ DB@@ Expr > ( ) ; } public void add@@ Li@@ b ( SV@@ DB@@ Expr lib ) { f@@ Li@@ b@@ Use@@ List . add ( lib ) ; } public void set@@ Li@@ b@@ Cell@@ Id ( SV@@ DB@@ Expr id ) { f@@ Li@@ b@@ Cell@@ Id = id ; } public void set@@ Param@@ As@@ sign ( SV@@ DB@@ Param@@ Value@@ Assign@@ List as@@ sign ) { f@@ Param@@ Value@@ As@@ sign = as@@ sign ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Fin@@ al@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Fin@@ al@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Fin@@ al@@ Stmt ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Wait@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Expr f@@ Expr ; public SV@@ DB@@ Wait@@ Stmt ( ) { this ( SV@@ DB@@ Item@@ Type . Wait@@ Stmt ) ; } protected SV@@ DB@@ Wait@@ Stmt ( SV@@ DB@@ Item@@ Type type ) { super ( type ) ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ For@@ k@@ Stmt extends SV@@ DB@@ Block@@ Stmt { public enum Join@@ Type { Join , Join@@ N@@ one , Join@@ An@@ y } ; public Join@@ Type f@@ Join@@ Type ; public SV@@ DB@@ For@@ k@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . For@@ k@@ Stmt ) ; } public Join@@ Type get@@ Join@@ Type ( ) { return f@@ Join@@ Type ; } public void set@@ Join@@ Type ( Join@@ Type jo@@ in_@@ type ) { f@@ Join@@ Type = jo@@ in_@@ type ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Whi@@ le@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Expr f@@ Con@@ d ; public SV@@ DB@@ Whi@@ le@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Whi@@ le@@ Stmt ) ; } public SV@@ DB@@ Whi@@ le@@ Stmt ( SV@@ DB@@ Expr con@@ d ) { super ( SV@@ DB@@ Item@@ Type . Whi@@ le@@ Stmt ) ; f@@ Con@@ d = con@@ d ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Con@@ d ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Con@@ d = expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Time@@ P@@ rec@@ ision@@ Stmt extends SV@@ DB@@ Stmt { public String f@@ Arg@@ 1 ; public String f@@ Arg@@ 2 ; public SV@@ DB@@ Time@@ P@@ rec@@ ision@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Time@@ P@@ rec@@ ision@@ Stmt ) ; } public String get@@ Arg@@ 1 ( ) { return f@@ Arg@@ 1 ; } public void set@@ Arg@@ 1 ( String arg1 ) { f@@ Arg@@ 1 = arg1 ; } public String get@@ Arg@@ 2 ( ) { return f@@ Arg@@ 2 ; } public void set@@ Arg@@ 2 ( String arg@@ 2 ) { f@@ Arg@@ 2 = arg@@ 2 ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Add@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . attr . SV@@ DB@@ Do@@ Not@@ Save@@ Attr ; public class SV@@ DB@@ Action@@ Block@@ Stmt extends SV@@ DB@@ Stmt implements IS@@ V@@ DB@@ Add@@ Child@@ Item { @ SV@@ DB@@ Do@@ Not@@ Save@@ Attr private int f@@ Add@@ Idx ; public SV@@ DB@@ Stmt f@@ Stmt ; public SV@@ DB@@ Stmt f@@ El@@ se@@ Stmt ; public SV@@ DB@@ Action@@ Block@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Action@@ Block@@ Stmt ) ; } public void set@@ Stmt ( SV@@ DB@@ Stmt stmt ) { f@@ Stmt = stmt ; } public SV@@ DB@@ Stmt get@@ Stmt ( ) { return f@@ Stmt ; } public void set@@ El@@ se@@ Stmt ( SV@@ DB@@ Stmt stmt ) { f@@ El@@ se@@ Stmt = stmt ; } public SV@@ DB@@ Stmt getE@@ l@@ se@@ Stmt ( ) { return f@@ El@@ se@@ Stmt ; } public void add@@ Child@@ Item ( IS@@ V@@ DB@@ Child@@ Item item ) { if ( f@@ Add@@ Idx ++ == 0 ) { f@@ Stmt = ( SV@@ DB@@ Stmt ) item ; } else if ( f@@ Add@@ Idx ++ == 1 ) { f@@ Stmt = ( SV@@ DB@@ Stmt ) item ; } } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . List ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Named@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Var@@ Decl@@ Item extends SV@@ DB@@ Stmt implements IS@@ V@@ DB@@ Named@@ Item { public String f@@ Name ; public int f@@ Attr ; public int f@@ Var@@ Attr ; public List < SV@@ DB@@ Var@@ Dim@@ Item > f@@ Array@@ Dim ; public SV@@ DB@@ Expr f@@ Init@@ Expr ; public SV@@ DB@@ Var@@ Decl@@ Item ( ) { super ( SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Item ) ; } public SV@@ DB@@ Var@@ Decl@@ Item ( String name ) { super ( SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Item ) ; f@@ Name = name ; } public void setName ( String name ) { f@@ Name = name ; } public String getName ( ) { return f@@ Name ; } public void set@@ Init@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Init@@ Expr = expr ; } public SV@@ DB@@ Expr getIn@@ it@@ Expr ( ) { return f@@ Init@@ Expr ; } public int get@@ Attr ( ) { return f@@ Attr ; } public void set@@ Attr ( int attr ) { f@@ Attr |= attr ; } public void reset@@ Attr ( int attr ) { f@@ Attr = attr ; } public List < SV@@ DB@@ Var@@ Dim@@ Item > get@@ Array@@ Dim ( ) { return f@@ Array@@ Dim ; } public void set@@ Array@@ Dim ( List < SV@@ DB@@ Var@@ Dim@@ Item > dim ) { f@@ Array@@ Dim = dim ; } public SV@@ DB@@ Var@@ Decl@@ Stmt getParent ( ) { return ( SV@@ DB@@ Var@@ Decl@@ Stmt ) f@@ Parent ; } public void set@@ Parent ( IS@@ V@@ DB@@ Child@@ Item parent ) { f@@ Parent = parent ; } public SV@@ DB@@ Var@@ Decl@@ Item d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Var@@ Decl@@ Item ) super . d@@ uplic@@ ate ( ) ; } public void init ( IS@@ V@@ DB@@ Item@@ Base other ) { } public boolean equals ( IS@@ V@@ DB@@ Item@@ Base other , boolean re@@ cur@@ se ) { return false ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Config@@ Default@@ C@@ la@@ use@@ Stmt extends SV@@ DB@@ Config@@ Rule@@ St@@ mt@@ Base { public SV@@ DB@@ Config@@ Default@@ C@@ la@@ use@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Config@@ Default@@ C@@ la@@ use@@ Stmt ) ; f@@ Is@@ Li@@ b@@ List = true ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Return@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Expr f@@ Return@@ Expr ; public SV@@ DB@@ Return@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Return@@ Stmt ) ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Return@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Return@@ Expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Def@@ Param@@ Stmt extends SV@@ DB@@ Stmt { public List < SV@@ DB@@ Def@@ Param@@ Item > f@@ Param@@ Assign@@ List ; public SV@@ DB@@ Def@@ Param@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Def@@ Param@@ Stmt ) ; f@@ Param@@ Assign@@ List = new ArrayList < SV@@ DB@@ Def@@ Param@@ Item > ( ) ; } public List < SV@@ DB@@ Def@@ Param@@ Item > getPar@@ am@@ Assign@@ List ( ) { return f@@ Param@@ Assign@@ List ; } public void add@@ Param@@ As@@ sign ( SV@@ DB@@ Def@@ Param@@ Item item ) { f@@ Param@@ Assign@@ List . add ( item ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Break@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Break@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Break@@ Stmt ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Import@@ Item extends SV@@ DB@@ Stmt { public String f@@ Imp@@ ort ; public SV@@ DB@@ Import@@ Item ( ) { super ( SV@@ DB@@ Item@@ Type . Import@@ Item ) ; } public String get@@ Imp@@ ort ( ) { return f@@ Imp@@ ort ; } public void set@@ Imp@@ ort ( String im@@ p ) { f@@ Imp@@ ort = im@@ p ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Time@@ Unit@@ s@@ Stmt extends SV@@ DB@@ Stmt { public String f@@ Unit@@ s ; public SV@@ DB@@ Time@@ Unit@@ s@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Time@@ Unit@@ s@@ Stmt ) ; } public String get@@ Unit@@ s ( ) { return f@@ Unit@@ s ; } public void set@@ Unit@@ s ( String un@@ its ) { f@@ Unit@@ s = un@@ its ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Do@@ Whi@@ le@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Expr f@@ Con@@ d ; public SV@@ DB@@ Do@@ Whi@@ le@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Do@@ Whi@@ le@@ Stmt ) ; } public void set@@ Con@@ d ( SV@@ DB@@ Expr con@@ d ) { f@@ Con@@ d = con@@ d ; } public SV@@ DB@@ Expr get@@ Con@@ d ( ) { return f@@ Con@@ d ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Constraint@@ If@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Expr f@@ If@@ Expr ; public SV@@ DB@@ Stmt f@@ Constraint ; public SV@@ DB@@ Stmt f@@ El@@ se ; public boolean f@@ El@@ se@@ If ; public SV@@ DB@@ Constraint@@ If@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Constraint@@ If@@ Stmt ) ; } public SV@@ DB@@ Constraint@@ If@@ Stmt ( SV@@ DB@@ Expr expr , SV@@ DB@@ Stmt constra@@ int , SV@@ DB@@ Stmt el@@ se@@ _@@ expr , boolean el@@ se@@ _@@ if ) { super ( SV@@ DB@@ Item@@ Type . Constraint@@ If@@ Stmt ) ; f@@ If@@ Expr = expr ; f@@ Constraint = constra@@ int ; f@@ El@@ se = el@@ se@@ _@@ expr ; f@@ El@@ se@@ If = el@@ se@@ _@@ if ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ If@@ Expr ; } public SV@@ DB@@ Stmt get@@ Constraint ( ) { return f@@ Constraint ; } public SV@@ DB@@ Stmt getE@@ l@@ se@@ Clause ( ) { return f@@ El@@ se ; } public boolean is@@ El@@ se@@ If ( ) { return f@@ El@@ se@@ If ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Fore@@ ver@@ Stmt extends SV@@ DB@@ Body@@ Stmt { public SV@@ DB@@ Fore@@ ver@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Fore@@ ver@@ Stmt ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Case@@ Stmt extends SV@@ DB@@ Stmt { public enum Case@@ Type { Case , Case@@ x , Case@@ z , Rand@@ case } ; public Case@@ Type f@@ Case@@ Type ; public SV@@ DB@@ Expr f@@ Expr ; public List < SV@@ DB@@ Case@@ Item > f@@ Case@@ Item@@ List ; public SV@@ DB@@ Case@@ Stmt ( ) { this ( Case@@ Type . Case ) ; } public SV@@ DB@@ Case@@ Stmt ( Case@@ Type type ) { super ( SV@@ DB@@ Item@@ Type . Case@@ Stmt ) ; f@@ Case@@ Item@@ List = new ArrayList < SV@@ DB@@ Case@@ Item > ( ) ; f@@ Case@@ Type = type ; } public Case@@ Type getC@@ ase@@ Type ( ) { return f@@ Case@@ Type ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Expr = expr ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } public List < SV@@ DB@@ Case@@ Item > getC@@ ase@@ Item@@ List ( ) { return f@@ Case@@ Item@@ List ; } public void add@@ Case@@ Item ( SV@@ DB@@ Case@@ Item item ) { f@@ Case@@ Item@@ List . add ( item ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; public enum SV@@ DB@@ Co@@ ver@@ age@@ Bin@@ s@@ Type { Bin@@ s , Illegal@@ Bin@@ s , Ignore@@ Bin@@ s } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ TypeInfo ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Var@@ Dim@@ Item extends SV@@ DB@@ Stmt { public enum Dim@@ Type { Un@@ si@@ z@@ ed , Si@@ z@@ ed , Associ@@ ative , Queue } ; public Dim@@ Type f@@ Dim@@ Type ; public SV@@ DB@@ Expr f@@ Expr ; public SV@@ DB@@ TypeInfo f@@ TypeInfo ; public SV@@ DB@@ Var@@ Dim@@ Item ( ) { super ( SV@@ DB@@ Item@@ Type . Var@@ Dim@@ Item ) ; } public void setD@@ im@@ Type ( Dim@@ Type type ) { f@@ Dim@@ Type = type ; } public Dim@@ Type getD@@ im@@ Type ( ) { return f@@ Dim@@ Type ; } public SV@@ DB@@ Expr get@@ Expr ( ) { return f@@ Expr ; } public void set@@ Expr ( SV@@ DB@@ Expr expr ) { f@@ Expr = expr ; } public SV@@ DB@@ TypeInfo getType@@ Info ( ) { return f@@ TypeInfo ; } public void set@@ TypeInfo ( SV@@ DB@@ TypeInfo type@@ _info ) { f@@ TypeInfo = type@@ _info ; } public String toString ( ) { String ret = "[" ; if ( f@@ Dim@@ Type != null ) { switch ( f@@ Dim@@ Type ) { case Associ@@ ative : if ( f@@ TypeInfo != null ) { ret += f@@ TypeInfo . toString ( ) ; } break ; case Queue : ret += "$@@ " ; break ; case Si@@ z@@ ed : if ( f@@ Expr != null ) { ret += f@@ Expr . toString ( ) ; } break ; case Un@@ si@@ z@@ ed : break ; } } ret += "]" ; return ret ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; public class SV@@ DB@@ Event@@ Trig@@ ger@@ Stmt extends SV@@ DB@@ Stmt { public SV@@ DB@@ Stmt f@@ Delay@@ Or@@ Event@@ Control ; public SV@@ DB@@ Expr f@@ Hierarch@@ ical@@ Event@@ Identifier ; public SV@@ DB@@ Event@@ Trig@@ ger@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Event@@ Trig@@ ger@@ Stmt ) ; } public SV@@ DB@@ Stmt getD@@ el@@ ay@@ Or@@ Event@@ Control ( ) { return f@@ Delay@@ Or@@ Event@@ Control ; } public void set@@ Delay@@ Or@@ Event@@ Control ( SV@@ DB@@ Stmt stmt ) { f@@ Delay@@ Or@@ Event@@ Control = stmt ; } public SV@@ DB@@ Expr getH@@ i@@ erarch@@ ical@@ Event@@ Identifier ( ) { return f@@ Hierarch@@ ical@@ Event@@ Identifier ; } public void set@@ Hierarch@@ ical@@ Event@@ Identifier ( SV@@ DB@@ Expr expr ) { f@@ Hierarch@@ ical@@ Event@@ Identifier = expr ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Dis@@ able@@ For@@ k@@ Stmt extends SV@@ DB@@ Dis@@ able@@ Stmt { public SV@@ DB@@ Dis@@ able@@ For@@ k@@ Stmt ( ) { super ( SV@@ DB@@ Item@@ Type . Dis@@ able@@ For@@ k@@ Stmt ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . stmt ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public class SV@@ DB@@ Stmt extends SV@@ DB@@ Child@@ Item { protected SV@@ DB@@ Stmt ( SV@@ DB@@ Item@@ Type type ) { super ( type ) ; } @ Override public void init ( IS@@ V@@ DB@@ Item@@ Base other ) { super . init ( other ) ; } @ Override public boolean equals ( Object obj ) { return super . equals ( obj ) ; } @ Override public SV@@ DB@@ Stmt d@@ uplic@@ ate ( ) { return ( SV@@ DB@@ Stmt ) super . d@@ uplic@@ ate ( ) ; } @ Override public boolean equals ( IS@@ V@@ DB@@ Item@@ Base obj , boolean f@@ ull ) { return super . equals ( obj , f@@ ull ) ; } public static boolean is@@ Type ( IS@@ V@@ DB@@ Item@@ Base item , SV@@ DB@@ Item@@ Type ... types ) { boolean ret = true ; if ( ret ) { ret = false ; for ( SV@@ DB@@ Item@@ Type t : types ) { if ( t == item . getType ( ) ) { ret = true ; break ; } } } return ret ; } } </s>
<s> package net . sf . sv@@ editor . core . db ; import java . util . ArrayList ; import java . util . List ; public class SV@@ DB@@ Type@@ Info@@ Enum extends SV@@ DB@@ TypeInfo { public List < SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator > f@@ Enum@@ er@@ ators ; public SV@@ DB@@ Type@@ Info@@ Enum ( ) { this ( "" ) ; } public SV@@ DB@@ Type@@ Info@@ Enum ( String typ@@ ename ) { super ( typ@@ ename , SV@@ DB@@ Item@@ Type . Type@@ Info@@ Enum ) ; f@@ Enum@@ er@@ ators = new ArrayList < SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator > ( ) ; } public void add@@ Enum@@ er@@ ator ( SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator e ) { e . set@@ Parent ( this ) ; f@@ Enum@@ er@@ ators . add ( e ) ; } public List < SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator > get@@ Enum@@ er@@ ators ( ) { return f@@ Enum@@ er@@ ators ; } public String toString ( ) { return getName ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db ; public interface IS@@ V@@ DB@@ End@@ Location { SV@@ DB@@ Location getEnd@@ Location ( ) ; void set@@ End@@ Location ( SV@@ DB@@ Location loc ) ; } </s>
<s> package net . sf . sv@@ editor . core . db ; import java . util . ArrayList ; import java . util . List ; public class SV@@ DB@@ Scope@@ Item extends SV@@ DB@@ Item implements IS@@ V@@ DB@@ Scope@@ Item { public List < IS@@ V@@ DB@@ Child@@ Item > f@@ Items ; public SV@@ DB@@ Location f@@ End@@ Location ; protected SV@@ DB@@ Scope@@ Item ( String name , SV@@ DB@@ Item@@ Type type ) { super ( name , type ) ; f@@ Items = new ArrayList < IS@@ V@@ DB@@ Child@@ Item > ( ) ; } public SV@@ DB@@ Scope@@ Item ( ) { super ( "" , SV@@ DB@@ Item@@ Type . Null@@ Expr ) ; f@@ Items = new ArrayList < IS@@ V@@ DB@@ Child@@ Item > ( ) ; } public void set@@ End@@ Location ( SV@@ DB@@ Location loc ) { f@@ End@@ Location = loc ; } public SV@@ DB@@ Location getEnd@@ Location ( ) { return f@@ End@@ Location ; } public void add@@ Item ( IS@@ V@@ DB@@ Item@@ Base item ) { if ( item instanceof IS@@ V@@ DB@@ Child@@ Item ) { ( ( IS@@ V@@ DB@@ Child@@ Item ) item ) . set@@ Parent ( this ) ; f@@ Items . add ( ( IS@@ V@@ DB@@ Child@@ Item ) item ) ; } else { throw new RuntimeException ( "" + item . getClass ( ) . getName ( ) ) ; } } public void add@@ Child@@ Item ( IS@@ V@@ DB@@ Child@@ Item item ) { item . set@@ Parent ( this ) ; f@@ Items . add ( item ) ; } @ Deprecated @ SuppressWarnings ( { "unchecked" , "raw@@ types" } ) public List < IS@@ V@@ DB@@ Item@@ Base > get@@ Items ( ) { return ( List < IS@@ V@@ DB@@ Item@@ Base > ) ( ( List ) f@@ Items ) ; } public Iterable < IS@@ V@@ DB@@ Child@@ Item > getChildren ( ) { return f@@ Items ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof SV@@ DB@@ Scope@@ Item ) { SV@@ DB@@ Scope@@ Item o = ( SV@@ DB@@ Scope@@ Item ) obj ; if ( f@@ End@@ Location == null || o . f@@ End@@ Location == null ) { if ( f@@ End@@ Location != o . f@@ End@@ Location ) { return false ; } } else if ( ! f@@ End@@ Location . equals ( o . f@@ End@@ Location ) ) { return false ; } if ( f@@ Items . size ( ) == o . f@@ Items . size ( ) ) { for ( int i = 0 ; i < f@@ Items . size ( ) ; i ++ ) { if ( ! f@@ Items . get ( i ) . equals ( o . f@@ Items . get ( i ) ) ) { return false ; } } } else { return false ; } return super . equals ( obj ) ; } return false ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Parent ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Named@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Type@@ Info@@ Enum ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator ; import net . sf . sv@@ editor . core . db . attr . SV@@ DB@@ Do@@ Not@@ Save@@ Attr ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Typed@@ ef@@ Stmt ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; public class SV@@ DB@@ Decl@@ Cache@@ Item implements IS@@ V@@ DB@@ Named@@ Item { public String f@@ FileName ; @ SV@@ DB@@ Do@@ Not@@ Save@@ Attr private IS@@ V@@ DB@@ Decl@@ Cache f@@ Parent ; public String f@@ Name ; public SV@@ DB@@ Item@@ Type f@@ Type ; public boolean f@@ Is@@ File@@ Tree@@ Item ; public SV@@ DB@@ Decl@@ Cache@@ Item ( ) { } public SV@@ DB@@ Decl@@ Cache@@ Item ( IS@@ V@@ DB@@ Decl@@ Cache parent , String filename , String name , SV@@ DB@@ Item@@ Type type , boolean is_@@ ft@@ _@@ item ) { f@@ Parent = parent ; f@@ FileName = filename ; f@@ Name = name ; f@@ Type = type ; f@@ Is@@ File@@ Tree@@ Item = is_@@ ft@@ _@@ item ; } public void init ( IS@@ V@@ DB@@ Decl@@ Cache parent ) { f@@ Parent = parent ; } public String get@@ Filename ( ) { return f@@ FileName ; } public void set@@ Filename ( String filename ) { f@@ FileName = filename ; } public String getName ( ) { return f@@ Name ; } public void setName ( String name ) { f@@ Name = name ; } public boolean is@@ File@@ Tree@@ Item ( ) { return f@@ Is@@ File@@ Tree@@ Item ; } public void set@@ Parent ( IS@@ V@@ DB@@ Decl@@ Cache parent ) { f@@ Parent = parent ; } public IS@@ V@@ DB@@ Decl@@ Cache getParent ( ) { return f@@ Parent ; } public SV@@ DB@@ Item@@ Type getType ( ) { return f@@ Type ; } public void setType ( SV@@ DB@@ Item@@ Type type ) { f@@ Type = type ; } public IS@@ V@@ DB@@ Item@@ Base getS@@ V@@ DB@@ Item ( ) { if ( f@@ Parent == null ) { return null ; } SV@@ DB@@ File file = f@@ Parent . get@@ Decl@@ File ( new Null@@ ProgressMonitor ( ) , this ) ; if ( file != null ) { for ( IS@@ V@@ DB@@ Child@@ Item c : file . getChildren ( ) ) { if ( SV@@ DB@@ Item . getName ( c ) . equals ( f@@ Name ) && c . getType ( ) == getType ( ) ) { return c ; } else if ( c instanceof IS@@ V@@ DB@@ Child@@ Parent ) { IS@@ V@@ DB@@ Item@@ Base i = getS@@ V@@ DB@@ Item ( ( IS@@ V@@ DB@@ Child@@ Parent ) c ) ; if ( i != null ) { return i ; } } else if ( getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ Enum@@ er@@ ator && c . getType ( ) == SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) { SV@@ DB@@ Typed@@ ef@@ Stmt stmt = ( SV@@ DB@@ Typed@@ ef@@ Stmt ) c ; if ( stmt . getType@@ Info ( ) . getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ Enum ) { SV@@ DB@@ Type@@ Info@@ Enum e = ( SV@@ DB@@ Type@@ Info@@ Enum ) stmt . getType@@ Info ( ) ; for ( SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator en : e . get@@ Enum@@ er@@ ators ( ) ) { if ( en . getName ( ) . equals ( getName ( ) ) ) { return en ; } } } } } } return null ; } private IS@@ V@@ DB@@ Item@@ Base getS@@ V@@ DB@@ Item ( IS@@ V@@ DB@@ Child@@ Parent p ) { for ( IS@@ V@@ DB@@ Child@@ Item c : p . getChildren ( ) ) { if ( SV@@ DB@@ Item . getName ( c ) . equals ( f@@ Name ) && c . getType ( ) == f@@ Type ) { return c ; } } return null ; } public SV@@ DB@@ File getFile ( ) { if ( f@@ Parent == null ) { System . out . println ( "@@ Parent of " + f@@ Type + " " + f@@ Name + " is null@@ " ) ; return null ; } else { return f@@ Parent . get@@ Decl@@ File ( new Null@@ ProgressMonitor ( ) , this ) ; } } public SV@@ DB@@ File getFile@@ P@@ P ( ) { if ( f@@ Parent == null ) { System . out . println ( "@@ Parent of " + f@@ Type + " " + f@@ Name + " is null@@ " ) ; return null ; } else { return f@@ Parent . get@@ Decl@@ File@@ P@@ P ( new Null@@ ProgressMonitor ( ) , this ) ; } } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . lang . ref . Reference ; import java . lang . ref . W@@ eak@@ Reference ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . SV@@ FileUtils ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache@@ Factory ; import net . sf . sv@@ editor . core . db . index . cache . In@@ Memory@@ Index@@ Cache ; import net . sf . sv@@ editor . core . db . index . plugin@@ _@@ lib . SV@@ DB@@ Plugin@@ Li@@ b@@ Index@@ Factory ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import org . eclipse . core . runtime . I@@ Configuration@@ Element ; import org . eclipse . core . runtime . I@@ Extension ; import org . eclipse . core . runtime . I@@ Extension@@ Point ; import org . eclipse . core . runtime . I@@ Extension@@ Registry ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; import org . eclipse . core . runtime . P@@ latform ; import org . eclipse . core . runtime . Sub@@ ProgressMonitor ; public class SV@@ DB@@ Index@@ Registry implements I@@ Log@@ Level { public static final String G@@ LO@@ B@@ AL_@@ PRO@@ J@@ ECT = "G@@ LO@@ B@@ AL@@ " ; private SV@@ DB@@ Index@@ Collection@@ Mgr f@@ Index@@ Collection@@ Mgr ; private SV@@ DB@@ Index@@ Collection f@@ Global@@ Index@@ Mgr ; private List < Reference < IS@@ V@@ DB@@ Index > > f@@ Index@@ List ; private IS@@ V@@ DB@@ Index@@ Cache@@ Factory f@@ Cache@@ Factory ; private boolean f@@ Auto@@ Re@@ build@@ E@@ n ; private Log@@ Handle f@@ Log ; public SV@@ DB@@ Index@@ Registry ( ) { this ( false ) ; } public SV@@ DB@@ Index@@ Registry ( boolean stand@@ al@@ one@@ _@@ test_@@ mode ) { f@@ Index@@ List = new ArrayList < Reference < IS@@ V@@ DB@@ Index > > ( ) ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; f@@ Auto@@ Re@@ build@@ E@@ n = true ; f@@ Index@@ Collection@@ Mgr = new SV@@ DB@@ Index@@ Collection@@ Mgr ( ) ; } public void set@@ Enable@@ Auto@@ Re@@ build ( boolean en ) { f@@ Auto@@ Re@@ build@@ E@@ n = en ; clear@@ St@@ ale@@ Index@@ es ( ) ; for ( Reference < IS@@ V@@ DB@@ Index > i : f@@ Index@@ List ) { if ( i . get ( ) != null ) { i . get ( ) . set@@ Enable@@ Auto@@ Re@@ build ( f@@ Auto@@ Re@@ build@@ E@@ n ) ; } } } public SV@@ DB@@ Index@@ Collection@@ Mgr getIndex@@ Collection@@ Mgr ( ) { return f@@ Index@@ Collection@@ Mgr ; } public void init ( IS@@ V@@ DB@@ Index@@ Cache@@ Factory cache@@ _@@ factory ) { f@@ Cache@@ Factory = cache@@ _@@ factory ; f@@ Index@@ List . clear ( ) ; f@@ Global@@ Index@@ Mgr = get@@ Global@@ Index@@ Mgr ( ) ; } public void test_@@ init ( IS@@ V@@ DB@@ Index@@ Cache@@ Factory cache@@ _@@ factory ) { f@@ Cache@@ Factory = cache@@ _@@ factory ; f@@ Index@@ List . clear ( ) ; } public List < IS@@ V@@ DB@@ Index > getAll@@ Project@@ Lists ( ) { List < IS@@ V@@ DB@@ Index > ret = new ArrayList < IS@@ V@@ DB@@ Index > ( ) ; synchronized ( f@@ Index@@ List ) { for ( Reference < IS@@ V@@ DB@@ Index > i : f@@ Index@@ List ) { if ( i . get ( ) != null ) { ret . add ( i . get ( ) ) ; } } } return ret ; } public List < IS@@ V@@ DB@@ Index > get@@ Project@@ Index@@ List ( String project ) { List < IS@@ V@@ DB@@ Index > ret = new ArrayList < IS@@ V@@ DB@@ Index > ( ) ; clear@@ St@@ ale@@ Index@@ es ( ) ; synchronized ( f@@ Index@@ List ) { for ( Reference < IS@@ V@@ DB@@ Index > i : f@@ Index@@ List ) { if ( i . get ( ) != null && i . get ( ) . get@@ Project ( ) . equals ( project ) ) { ret . add ( i . get ( ) ) ; } } } return ret ; } public List < IS@@ V@@ DB@@ Index > getIndex@@ List ( ) { List < IS@@ V@@ DB@@ Index > ret = new ArrayList < IS@@ V@@ DB@@ Index > ( ) ; clear@@ St@@ ale@@ Index@@ es ( ) ; synchronized ( f@@ Index@@ List ) { for ( Reference < IS@@ V@@ DB@@ Index > i : f@@ Index@@ List ) { if ( i . get ( ) != null ) { ret . add ( i . get ( ) ) ; } } } return ret ; } public void dis@@ po@@ se@@ Index ( IS@@ V@@ DB@@ Index index ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + index . getBase@@ Location ( ) + " ; " + index . getConfig ( ) ) ; synchronized ( f@@ Index@@ List ) { f@@ Index@@ List . remove ( index ) ; } index . dispose ( ) ; } public SV@@ DB@@ Index@@ Collection get@@ Global@@ Index@@ Mgr ( ) { if ( f@@ Global@@ Index@@ Mgr == null ) { f@@ Global@@ Index@@ Mgr = new SV@@ DB@@ Index@@ Collection ( f@@ Index@@ Collection@@ Mgr , G@@ LO@@ B@@ AL_@@ PRO@@ J@@ ECT ) ; IS@@ V@@ DB@@ Index index = find@@ Create@@ Index ( new Null@@ ProgressMonitor ( ) , SV@@ DB@@ Index@@ Registry . G@@ LO@@ B@@ AL_@@ PRO@@ J@@ ECT , SV@@ Core@@ Plugin . SV@@ _@@ B@@ UI@@ L@@ T@@ IN_@@ LI@@ BR@@ ARY , SV@@ DB@@ Plugin@@ Li@@ b@@ Index@@ Factory . TYPE , null ) ; if ( index != null ) { f@@ Global@@ Index@@ Mgr . add@@ Plugin@@ Libr@@ ary ( index ) ; } } return f@@ Global@@ Index@@ Mgr ; } public IS@@ V@@ DB@@ Index find@@ Create@@ Index ( I@@ ProgressMonitor monitor , String project , String base@@ _@@ location , String type , SV@@ DB@@ Index@@ Config config ) { IS@@ V@@ DB@@ Index ret = null ; base@@ _@@ location = SV@@ FileUtils . normali@@ ze ( base@@ _@@ location ) ; f@@ Log . debug ( "" + base@@ _@@ location + " ; " + type ) ; synchronized ( f@@ Index@@ List ) { for ( Reference < IS@@ V@@ DB@@ Index > i : f@@ Index@@ List ) { IS@@ V@@ DB@@ Index index = i . get ( ) ; if ( index != null && index . get@@ Project ( ) . equals ( project ) && index . getBase@@ Location ( ) . equals ( base@@ _@@ location ) && index . getType@@ ID ( ) . equals ( type ) ) { ret = index ; break ; } } } if ( ret != null ) { if ( ! SV@@ DB@@ Index@@ Config . equals ( config , ret . getConfig ( ) ) ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + ret . getBase@@ Location ( ) + "" ) ; dis@@ po@@ se@@ Index ( ret ) ; ret = null ; } } if ( ret == null ) { f@@ Log . debug ( "" ) ; IS@@ V@@ DB@@ Index@@ Factory factory = find@@ Factory ( type ) ; IS@@ V@@ DB@@ Index@@ Cache cache = null ; if ( type . equals ( SV@@ DB@@ Sh@@ ad@@ ow@@ Index@@ Factory . TYPE ) ) { cache = new In@@ Memory@@ Index@@ Cache ( ) ; } else { cache = f@@ Cache@@ Factory . create@@ Index@@ Cache ( project , base@@ _@@ location ) ; } ret = factory . create@@ SV@@ DB@@ Index ( project , base@@ _@@ location , cache , config ) ; ret . set@@ Enable@@ Auto@@ Re@@ build ( f@@ Auto@@ Re@@ build@@ E@@ n ) ; Sub@@ ProgressMonitor m = new Sub@@ ProgressMonitor ( monitor , 1 ) ; ret . init ( m ) ; synchronized ( f@@ Index@@ List ) { f@@ Index@@ List . add ( new W@@ eak@@ Reference < IS@@ V@@ DB@@ Index > ( ret ) ) ; } } else { f@@ Log . debug ( "" ) ; } return ret ; } public IS@@ V@@ DB@@ Index find@@ Create@@ Index ( String project , String base@@ _@@ location , String type , IS@@ V@@ DB@@ Index@@ Factory factory , SV@@ DB@@ Index@@ Config config ) { return find@@ Create@@ Index ( new Null@@ ProgressMonitor ( ) , project , base@@ _@@ location , type , factory , config ) ; } public IS@@ V@@ DB@@ Index find@@ Create@@ Index ( I@@ ProgressMonitor monitor , String project , String base@@ _@@ location , String type , IS@@ V@@ DB@@ Index@@ Factory factory , SV@@ DB@@ Index@@ Config config ) { IS@@ V@@ DB@@ Index ret = null ; f@@ Log . debug ( "" + base@@ _@@ location + " ; " + type ) ; synchronized ( f@@ Index@@ List ) { for ( Reference < IS@@ V@@ DB@@ Index > i : f@@ Index@@ List ) { IS@@ V@@ DB@@ Index index = i . get ( ) ; if ( index != null && index . get@@ Project ( ) . equals ( project ) && index . getBase@@ Location ( ) . equals ( base@@ _@@ location ) && index . getType@@ ID ( ) . equals ( type ) ) { ret = index ; break ; } } } if ( ret == null ) { f@@ Log . debug ( "" ) ; IS@@ V@@ DB@@ Index@@ Cache cache = f@@ Cache@@ Factory . create@@ Index@@ Cache ( project , base@@ _@@ location ) ; ret = factory . create@@ SV@@ DB@@ Index ( project , base@@ _@@ location , cache , config ) ; ret . set@@ Enable@@ Auto@@ Re@@ build ( f@@ Auto@@ Re@@ build@@ E@@ n ) ; Sub@@ ProgressMonitor m = new Sub@@ ProgressMonitor ( monitor , 1 ) ; ret . init ( m ) ; synchronized ( f@@ Index@@ List ) { f@@ Index@@ List . add ( new W@@ eak@@ Reference < IS@@ V@@ DB@@ Index > ( ret ) ) ; } } else { f@@ Log . debug ( "" ) ; } return ret ; } public void re@@ build@@ Index ( I@@ ProgressMonitor monitor , String project ) { f@@ Log . debug ( "" + project + "\"" ) ; clear@@ St@@ ale@@ Index@@ es ( ) ; synchronized ( f@@ Index@@ List ) { for ( Reference < IS@@ V@@ DB@@ Index > i : f@@ Index@@ List ) { IS@@ V@@ DB@@ Index index = i . get ( ) ; if ( index != null && index . get@@ Project ( ) . equals ( project ) ) { index . re@@ build@@ Index ( monitor ) ; } } } } public void save@@ _state ( ) { f@@ Log . debug ( "@@ save@@ _@@ state@@ (@@ )" ) ; synchronized ( f@@ Index@@ List ) { for ( Reference < IS@@ V@@ DB@@ Index > i : f@@ Index@@ List ) { IS@@ V@@ DB@@ Index index = i . get ( ) ; if ( index != null ) { index . dispose ( ) ; } } } if ( f@@ Cache@@ Factory != null ) { List < IS@@ V@@ DB@@ Index@@ Cache > cache@@ _@@ l = new ArrayList < IS@@ V@@ DB@@ Index@@ Cache > ( ) ; synchronized ( f@@ Index@@ List ) { for ( Reference < IS@@ V@@ DB@@ Index > i : f@@ Index@@ List ) { IS@@ V@@ DB@@ Index index = i . get ( ) ; if ( index != null && ! cache@@ _@@ l . contains ( index . getC@@ ache ( ) ) && index . getC@@ ache ( ) != null ) { cache@@ _@@ l . add ( index . getC@@ ache ( ) ) ; } } } f@@ Cache@@ Factory . comp@@ act@@ Cache ( cache@@ _@@ l ) ; } } private IS@@ V@@ DB@@ Index@@ Factory find@@ Factory ( String type ) { IS@@ V@@ DB@@ Index@@ Factory ret = null ; I@@ Extension@@ Registry r@@ g@@ y = P@@ latform . get@@ Extension@@ Registry ( ) ; I@@ Extension@@ Point ext@@ _p@@ t = r@@ g@@ y . get@@ Extension@@ Point ( SV@@ Core@@ Plugin . PL@@ UG@@ IN_@@ ID , "" ) ; for ( I@@ Extension ext@@ _@@ l : ext@@ _p@@ t . get@@ Exten@@ sions ( ) ) { for ( I@@ Configuration@@ Element ce@@ l : ext@@ _@@ l . get@@ Configuration@@ Elements ( ) ) { String id = ce@@ l . getAttribute ( "id" ) ; if ( type . equals ( id ) ) { try { ret = ( IS@@ V@@ DB@@ Index@@ Factory ) ce@@ l . create@@ Execut@@ able@@ Extension ( "@@ class@@ " ) ; } catch ( Exception e ) { f@@ Log . error ( "" + "@@ extension \"" + id + "\"" , e ) ; } break ; } } } return ret ; } private void clear@@ St@@ ale@@ Index@@ es ( ) { synchronized ( f@@ Index@@ List ) { for ( int i = 0 ; i < f@@ Index@@ List . size ( ) ; i ++ ) { if ( f@@ Index@@ List . get ( i ) . get ( ) == null ) { System . out . println ( "" ) ; f@@ Index@@ List . remove ( i ) ; i -- ; } } } } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache ; import net . sf . sv@@ editor . core . db . project . SV@@ DB@@ Source@@ Collection ; import net . sf . sv@@ editor . core . files@@ et . Abstract@@ SV@@ File@@ Matcher ; import net . sf . sv@@ editor . core . files@@ et . SV@@ File@@ Set ; import net . sf . sv@@ editor . core . files@@ et . SV@@ Files@@ y@@ ste@@ m@@ File@@ Matcher ; import net . sf . sv@@ editor . core . files@@ et . SV@@ Work@@ space@@ File@@ Matcher ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; public class SV@@ DB@@ Source@@ Collection@@ Index@@ Factory implements IS@@ V@@ DB@@ Index@@ Factory { public static final String TYPE = "" ; public static final String FI@@ LE@@ SET = "@@ FILE_@@ SE@@ T" ; private Log@@ Handle f@@ Log ; public SV@@ DB@@ Source@@ Collection@@ Index@@ Factory ( ) { f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; } public IS@@ V@@ DB@@ Index create@@ SV@@ DB@@ Index ( String project@@ _name , String base@@ _@@ location , IS@@ V@@ DB@@ Index@@ Cache cache , SV@@ DB@@ Index@@ Config config ) { IS@@ V@@ DB@@ Index ret ; IS@@ V@@ DB@@ File@@ System@@ Provider f@@ s_@@ provider = null ; List < Abstract@@ SV@@ File@@ Matcher > match@@ er@@ _@@ list = new ArrayList < Abstract@@ SV@@ File@@ Matcher > ( ) ; f@@ Log . debug ( "" + project@@ _name + " ; " + base@@ _@@ location ) ; SV@@ File@@ Set fs = null ; Abstract@@ SV@@ File@@ Matcher matcher = null ; if ( config != null ) { fs = ( SV@@ File@@ Set ) config . get ( FI@@ LE@@ SET ) ; } if ( base@@ _@@ location . startsWith ( "" ) ) { if ( fs == null ) { fs = new SV@@ File@@ Set ( base@@ _@@ location ) ; fs . getIn@@ clu@@ des ( ) . addAll ( SV@@ DB@@ Source@@ Collection . parse@@ Pattern@@ List ( SV@@ Core@@ Plugin . getDefault ( ) . getDefault@@ Source@@ Collection@@ Inclu@@ des ( ) ) ) ; fs . getEx@@ clu@@ des ( ) . addAll ( SV@@ DB@@ Source@@ Collection . parse@@ Pattern@@ List ( SV@@ Core@@ Plugin . getDefault ( ) . getDefault@@ Source@@ Collection@@ Exclu@@ des ( ) ) ) ; } matcher = new SV@@ Work@@ space@@ File@@ Matcher ( ) ; matcher . add@@ File@@ Set ( fs ) ; f@@ s_@@ provider = new SV@@ DB@@ WS@@ File@@ System@@ Provider ( ) ; match@@ er@@ _@@ list . add ( matcher ) ; } else { if ( fs == null ) { fs = new SV@@ File@@ Set ( base@@ _@@ location ) ; fs . getIn@@ clu@@ des ( ) . addAll ( SV@@ DB@@ Source@@ Collection . parse@@ Pattern@@ List ( SV@@ Core@@ Plugin . getDefault ( ) . getDefault@@ Source@@ Collection@@ Inclu@@ des ( ) ) ) ; fs . getEx@@ clu@@ des ( ) . addAll ( SV@@ DB@@ Source@@ Collection . parse@@ Pattern@@ List ( SV@@ Core@@ Plugin . getDefault ( ) . getDefault@@ Source@@ Collection@@ Exclu@@ des ( ) ) ) ; } matcher = new SV@@ Files@@ y@@ ste@@ m@@ File@@ Matcher ( ) ; matcher . add@@ File@@ Set ( fs ) ; f@@ s_@@ provider = new SV@@ DB@@ F@@ S@@ File@@ System@@ Provider ( ) ; match@@ er@@ _@@ list . add ( matcher ) ; } ret = new SV@@ DB@@ Source@@ Collection@@ Index ( project@@ _name , base@@ _@@ location , match@@ er@@ _@@ list , f@@ s_@@ provider , cache , config ) ; return ret ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . ref . Reference ; import java . lang . ref . W@@ eak@@ Reference ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . SV@@ FileUtils ; import org . eclipse . core . resources . I@@ Container ; import org . eclipse . core . resources . I@@ File ; import org . eclipse . core . resources . I@@ Folder ; import org . eclipse . core . resources . I@@ Marker ; import org . eclipse . core . resources . I@@ Project ; import org . eclipse . core . resources . I@@ Resource ; import org . eclipse . core . resources . I@@ Resource@@ ChangeEvent ; import org . eclipse . core . resources . I@@ Resource@@ ChangeListener ; import org . eclipse . core . resources . I@@ Resource@@ Delta ; import org . eclipse . core . resources . I@@ Resource@@ Delta@@ Visitor ; import org . eclipse . core . resources . I@@ Work@@ space@@ Root ; import org . eclipse . core . resources . Resources@@ Plugin ; import org . eclipse . core . runtime . Core@@ Exception ; import org . eclipse . core . runtime . I@@ Path ; import org . eclipse . core . runtime . Path ; public class SV@@ DB@@ WS@@ File@@ System@@ Provider implements IS@@ V@@ DB@@ File@@ System@@ Provider , I@@ Resource@@ ChangeListener , I@@ Resource@@ Delta@@ Visitor { private List < Reference < IS@@ V@@ DB@@ File@@ System@@ ChangeListener > > f@@ Change@@ Listeners ; public SV@@ DB@@ WS@@ File@@ System@@ Provider ( ) { f@@ Change@@ Listeners = new ArrayList < Reference < IS@@ V@@ DB@@ File@@ System@@ ChangeListener > > ( ) ; } public void init ( String path ) { I@@ File file ; I@@ Container folder = null ; I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; if ( path . startsWith ( "" ) ) { path = path . substring ( "" . length ( ) ) ; } try { folder = root . get@@ Folder ( new Path ( path ) ) ; if ( ! folder . exists ( ) ) { file = root . getFile ( new Path ( path ) ) ; folder = file . getParent ( ) ; if ( ! folder . exists ( ) ) { folder = null ; } } } catch ( IllegalArgumentException e ) { } if ( folder == null ) { String p@@ name = path ; if ( p@@ name . startsWith ( "/" ) ) { p@@ name = p@@ name . substring ( 1 ) ; } if ( p@@ name . endsWith ( "/" ) ) { p@@ name = p@@ name . substring ( 0 , p@@ name . length ( ) - 1 ) ; } for ( I@@ Project p_@@ t : root . get@@ Projec@@ ts ( ) ) { if ( p_@@ t . is@@ Open ( ) && p_@@ t . getName ( ) . equals ( p@@ name ) ) { folder = p_@@ t ; } } } if ( folder != null ) { try { folder . refresh@@ Local ( I@@ Resource . DE@@ P@@ TH_@@ INF@@ IN@@ ITE , null ) ; } catch ( Core@@ Exception e ) { } } Resources@@ Plugin . get@@ Workspace ( ) . add@@ Resource@@ ChangeListener ( this ) ; } public void add@@ Marker ( String path , final String type , final int lin@@ en@@ o , final String msg ) { if ( path . startsWith ( "" ) ) { path = path . substring ( "" . length ( ) ) ; I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; final I@@ File file = root . getFile ( new Path ( path ) ) ; int se@@ ver@@ ity ; if ( type . equals ( MAR@@ K@@ ER_@@ TYPE_@@ ERROR ) ) { se@@ ver@@ ity = I@@ Marker . SEVER@@ ITY_@@ ERROR ; } else if ( type . equals ( MAR@@ K@@ ER_@@ TYPE_@@ WAR@@ NING ) ) { se@@ ver@@ ity = I@@ Marker . SEVER@@ ITY_@@ WAR@@ NING ; } else { se@@ ver@@ ity = I@@ Marker . SEVER@@ ITY_@@ INFO ; } SV@@ Core@@ Plugin . getDefault ( ) . prop@@ ag@@ ate@@ Marker ( file , se@@ ver@@ ity , lin@@ en@@ o , msg ) ; } } public void clear@@ Mark@@ ers ( String path ) { if ( path . startsWith ( "" ) ) { path = path . substring ( "" . length ( ) ) ; I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ File file = root . getFile ( new Path ( path ) ) ; if ( file . exists ( ) ) { try { I@@ Marker mark@@ ers [ ] = file . find@@ Mark@@ ers ( I@@ Marker . PRO@@ BLE@@ M , true , I@@ Resource . DE@@ P@@ TH_@@ INF@@ IN@@ ITE ) ; for ( I@@ Marker m : mark@@ ers ) { m . delete ( ) ; } } catch ( Core@@ Exception e ) { } } } } public void dispose ( ) { Resources@@ Plugin . get@@ Workspace ( ) . remove@@ Resource@@ ChangeListener ( this ) ; } public boolean file@@ Exists ( String path ) { if ( path . startsWith ( "" ) ) { path = path . substring ( "" . length ( ) ) ; I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; try { I@@ File file = root . getFile ( new Path ( path ) ) ; I@@ Folder folder = root . get@@ Folder ( new Path ( path ) ) ; return ( file . exists ( ) || folder . exists ( ) ) ; } catch ( IllegalArgumentException e ) { return false ; } } else { return new File ( path ) . exists ( ) ; } } public boolean is@@ Dir ( String path ) { if ( path . startsWith ( "" ) ) { path = path . substring ( "" . length ( ) ) ; if ( path . startsWith ( "/" ) ) { path = path . substring ( 1 ) ; } I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; try { I@@ Folder folder = root . get@@ Folder ( new Path ( path ) ) ; return folder . exists ( ) ; } catch ( IllegalArgumentException e ) { } try { I@@ Project project = root . get@@ Project ( path ) ; return project . exists ( ) ; } catch ( IllegalArgumentException e ) { } return false ; } else { return new File ( path ) . isDirectory ( ) ; } } public List < String > get@@ Files ( String path ) { List < String > ret = new ArrayList < String > ( ) ; if ( path . startsWith ( "" ) ) { path = path . substring ( "" . length ( ) ) ; if ( path . startsWith ( "/" ) ) { path = path . substring ( 1 ) ; } I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ Container c = null ; try { c = root . get@@ Folder ( new Path ( path ) ) ; } catch ( IllegalArgumentException e ) { } if ( c == null ) { try { c = root . get@@ Project ( path ) ; } catch ( IllegalArgumentException e ) { } } if ( c != null ) { try { for ( I@@ Resource m : c . mem@@ bers ( ) ) { I@@ Path p = m . getFull@@ Path ( ) ; ret . add ( "" + p . toString ( ) ) ; } } catch ( Core@@ Exception e ) { } } } else { File p = new File ( path ) ; if ( p . isDirectory ( ) ) { File f_@@ l [ ] = p . list@@ Files ( ) ; if ( f_@@ l != null ) { for ( File f : p . list@@ Files ( ) ) { if ( ! f . getName ( ) . equals ( "." ) && ! f . getName ( ) . equals ( ".@@ ." ) ) { ret . add ( f . getAbsolutePath ( ) ) ; } } } } } return ret ; } public void close@@ Stream ( InputStream in ) { try { if ( in != null ) { in . close ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } public InputStream open@@ Stream ( String path ) { InputStream ret = null ; if ( path . startsWith ( "" ) ) { path = path . substring ( "" . length ( ) ) ; I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ File file = root . getFile ( new Path ( path ) ) ; if ( ! file . exists ( ) ) { return null ; } for ( int i = 0 ; i < 2 ; i ++ ) { try { ret = file . get@@ Contents ( ) ; break ; } catch ( Core@@ Exception e ) { if ( i == 0 && e . getMessage ( ) . contains ( "@@ out of syn@@ c" ) ) { try { file . getParent ( ) . refresh@@ Local ( I@@ Resource . DE@@ P@@ TH_@@ INF@@ IN@@ ITE , null ) ; } catch ( Core@@ Exception e2 ) { } } else { e . printStackTrace ( ) ; } } } } else { try { ret = new FileInputStream ( path ) ; } catch ( IOException e ) { } } return ret ; } public String resolve@@ Path ( String path , String fmt ) { boolean w@@ s_@@ path = path . startsWith ( "" ) ; if ( w@@ s_@@ path ) { path = path . substring ( "" . length ( ) ) ; StringBuilder ret = new StringBuilder ( ) ; int i = path . length ( ) - 1 ; int end ; int skip@@ C@@ nt = 0 ; while ( i >= 0 ) { end = ret . length ( ) ; while ( i >= 0 && path . charAt ( i ) != '/' && path . charAt ( i ) != '\@@ \@@ ' ) { ret . append ( path . charAt ( i ) ) ; i -- ; } if ( i != - 1 ) { ret . append ( "/" ) ; i -- ; } if ( ( ret . length ( ) - end ) > 0 ) { String str = ret . substring ( end , ret . length ( ) - 1 ) ; if ( str . equals ( ".@@ ." ) ) { skip@@ C@@ nt ++ ; ret . set@@ Length ( end ) ; } else if ( skip@@ C@@ nt > 0 ) { ret . set@@ Length ( end ) ; skip@@ C@@ nt -- ; } } } if ( skip@@ C@@ nt > 0 ) { throw new RuntimeException ( "" ) ; } path = ret . re@@ verse ( ) . toString ( ) ; } if ( fmt != null ) { if ( fmt . equals ( IS@@ V@@ DB@@ File@@ System@@ Provider . PAT@@ H@@ F@@ M@@ T_@@ FI@@ LE@@ SY@@ STE@@ M ) ) { if ( w@@ s_@@ path ) { if ( is@@ Dir ( "" + path ) ) { I@@ Container c = SV@@ FileUtils . get@@ Work@@ space@@ Folder ( path ) ; if ( c != null ) { path = c . getLocation ( ) . to@@ O@@ S@@ String ( ) ; } } else { I@@ File f = SV@@ FileUtils . get@@ Work@@ space@@ File ( path ) ; if ( f != null ) { path = f . getLocation ( ) . to@@ O@@ S@@ String ( ) ; } } } } else if ( fmt . equals ( IS@@ V@@ DB@@ File@@ System@@ Provider . PAT@@ H@@ F@@ M@@ T_@@ WOR@@ K@@ SP@@ ACE ) ) { if ( ! w@@ s_@@ path ) { if ( is@@ Dir ( path ) ) { I@@ Container c = SV@@ FileUtils . find@@ Work@@ space@@ Folder ( path ) ; if ( c != null ) { path = "" + c . getFull@@ Path ( ) ; } } else { I@@ File f = SV@@ FileUtils . find@@ Work@@ space@@ File ( path ) ; if ( f != null ) { path = "" + f . getFull@@ Path ( ) ; } } } } } else { if ( w@@ s_@@ path ) { path = "" + path ; } } return path ; } protected String normali@@ ze@@ Path ( String path ) { StringBuilder ret = new StringBuilder ( ) ; int i = path . length ( ) - 1 ; int end ; int skip@@ C@@ nt = 0 ; while ( i >= 0 ) { end = ret . length ( ) ; while ( i >= 0 && path . charAt ( i ) != '/' && path . charAt ( i ) != '\@@ \@@ ' ) { ret . append ( path . charAt ( i ) ) ; i -- ; } if ( i != - 1 ) { ret . append ( "/" ) ; i -- ; } if ( ( ret . length ( ) - end ) > 0 ) { String str = ret . substring ( end , ret . length ( ) - 1 ) ; if ( str . equals ( ".@@ ." ) ) { skip@@ C@@ nt ++ ; ret . set@@ Length ( end ) ; } else if ( skip@@ C@@ nt > 0 ) { ret . set@@ Length ( end ) ; skip@@ C@@ nt -- ; } } } if ( skip@@ C@@ nt > 0 ) { throw new RuntimeException ( "" ) ; } return ret . re@@ verse ( ) . toString ( ) ; } public long getLast@@ Modified@@ Time ( String path ) { if ( path . startsWith ( "" ) ) { path = path . substring ( "" . length ( ) ) ; I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ File file = root . getFile ( new Path ( path ) ) ; if ( file != null && file . getLocation ( ) != null && file . getLocation ( ) . to@@ File ( ) != null ) { return file . getLocation ( ) . to@@ File ( ) . lastModified ( ) ; } else { return 0 ; } } else { return new File ( path ) . lastModified ( ) ; } } public void add@@ File@@ System@@ ChangeListener ( IS@@ V@@ DB@@ File@@ System@@ ChangeListener l ) { synchronized ( f@@ Change@@ Listeners ) { f@@ Change@@ Listeners . add ( new W@@ eak@@ Reference < IS@@ V@@ DB@@ File@@ System@@ ChangeListener > ( l ) ) ; } } public void remove@@ File@@ System@@ ChangeListener ( IS@@ V@@ DB@@ File@@ System@@ ChangeListener l ) { synchronized ( f@@ Change@@ Listeners ) { for ( int i = 0 ; i < f@@ Change@@ Listeners . size ( ) ; i ++ ) { IS@@ V@@ DB@@ File@@ System@@ ChangeListener ll = f@@ Change@@ Listeners . get ( i ) . get ( ) ; if ( ll == null || ll == l ) { f@@ Change@@ Listeners . remove ( i ) ; i -- ; } } } } public synchronized boolean visit ( I@@ Resource@@ Delta delta ) throws Core@@ Exception { if ( delta . getResource ( ) instanceof I@@ File ) { String file = "" ; file += SV@@ FileUtils . normali@@ ze ( ( ( I@@ File ) delta . getResource ( ) ) . getFull@@ Path ( ) . to@@ O@@ S@@ String ( ) ) ; if ( delta . get@@ Kind ( ) == I@@ Resource@@ Delta . REMO@@ V@@ ED ) { synchronized ( f@@ Change@@ Listeners ) { for ( int i = 0 ; i < f@@ Change@@ Listeners . size ( ) ; i ++ ) { IS@@ V@@ DB@@ File@@ System@@ ChangeListener l = f@@ Change@@ Listeners . get ( i ) . get ( ) ; if ( l == null ) { f@@ Change@@ Listeners . remove ( i ) ; i -- ; } else { l . file@@ Removed ( file ) ; } } } } else if ( delta . get@@ Kind ( ) == I@@ Resource@@ Delta . AD@@ DED ) { synchronized ( f@@ Change@@ Listeners ) { for ( int i = 0 ; i < f@@ Change@@ Listeners . size ( ) ; i ++ ) { IS@@ V@@ DB@@ File@@ System@@ ChangeListener l = f@@ Change@@ Listeners . get ( i ) . get ( ) ; if ( l == null ) { f@@ Change@@ Listeners . remove ( i ) ; i -- ; } else { l . file@@ Added ( file ) ; } } } } else if ( delta . get@@ Kind ( ) == I@@ Resource@@ Delta . CHANGE@@ D ) { if ( ( delta . getF@@ l@@ ags ( ) & I@@ Resource@@ Delta . CONT@@ ENT ) != 0 ) { synchronized ( f@@ Change@@ Listeners ) { for ( int i = 0 ; i < f@@ Change@@ Listeners . size ( ) ; i ++ ) { IS@@ V@@ DB@@ File@@ System@@ ChangeListener l = f@@ Change@@ Listeners . get ( i ) . get ( ) ; if ( l == null ) { f@@ Change@@ Listeners . remove ( i ) ; i -- ; } else { l . file@@ Changed ( file ) ; } } } } } } return true ; } public void resource@@ Changed ( I@@ Resource@@ ChangeEvent event ) { try { if ( event . getD@@ el@@ ta ( ) != null ) { event . getD@@ el@@ ta ( ) . accept ( this ) ; } } catch ( Core@@ Exception e ) { e . printStackTrace ( ) ; } } } </s>
<s> package net . sf . sv@@ editor . core . db . index . plugin@@ _@@ lib ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . db . index . IS@@ V@@ DB@@ Index ; import net . sf . sv@@ editor . core . db . index . IS@@ V@@ DB@@ Index@@ Factory ; import net . sf . sv@@ editor . core . db . index . SV@@ DB@@ Index@@ Config ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache ; public class SV@@ DB@@ Plugin@@ Li@@ b@@ Index@@ Factory implements IS@@ V@@ DB@@ Index@@ Factory { public static final String TYPE = "" ; public IS@@ V@@ DB@@ Index create@@ SV@@ DB@@ Index ( String project , String base@@ _@@ location , IS@@ V@@ DB@@ Index@@ Cache cache , SV@@ DB@@ Index@@ Config config ) { for ( SV@@ DB@@ Plugin@@ Li@@ b@@ Descriptor d : SV@@ Core@@ Plugin . getDefault ( ) . getPlu@@ gin@@ Li@@ b@@ List ( ) ) { if ( d . getId ( ) . equals ( base@@ _@@ location ) ) { return new SV@@ DB@@ Plugin@@ Li@@ b@@ Index ( project , d . get@@ Namespace ( ) , d . getPath ( ) , cache ) ; } } return null ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index . plugin@@ _@@ lib ; import java . net . URI ; import org . eclipse . core . files@@ y@@ ste@@ m . I@@ File@@ Store ; import org . eclipse . core . files@@ y@@ ste@@ m . provider . FileSystem ; public class Plugin@@ Files@@ y@@ ste@@ m extends FileSystem { public Plugin@@ Files@@ y@@ ste@@ m ( ) { } @ Override public I@@ File@@ Store get@@ Store ( URI uri ) { return new Plugin@@ File@@ Store ( uri ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index . plugin@@ _@@ lib ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . db . index . IS@@ V@@ DB@@ File@@ System@@ ChangeListener ; import net . sf . sv@@ editor . core . db . index . IS@@ V@@ DB@@ File@@ System@@ Provider ; import net . sf . sv@@ editor . core . db . index . SV@@ D@@ BL@@ ib@@ Index ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache ; import net . sf . sv@@ editor . core . log . LogFactory ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; import org . eclipse . core . runtime . P@@ latform ; import org . osgi . framework . Bundle ; import org . osgi . framework . Version ; public class SV@@ DB@@ Plugin@@ Li@@ b@@ Index extends SV@@ D@@ BL@@ ib@@ Index implements IS@@ V@@ DB@@ File@@ System@@ Provider { private Bundle f@@ Bundle ; private String f@@ Plugin@@ NS ; private String f@@ Root@@ File ; private long f@@ Bundle@@ Version = - 1 ; public SV@@ DB@@ Plugin@@ Li@@ b@@ Index ( String project , String plugin@@ _@@ ns , String root , IS@@ V@@ DB@@ Index@@ Cache cache ) { super ( project , "@@ plugin@@ :@@ /" + plugin@@ _@@ ns + "/" + root , null , cache , null ) ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; f@@ Root@@ File = root ; f@@ Plugin@@ NS = plugin@@ _@@ ns ; f@@ Bundle = P@@ latform . get@@ Bundle ( f@@ Plugin@@ NS ) ; f@@ Log . debug ( "@@ Root@@ File@@ : " + f@@ Root@@ File + " Root@@ : " + getBase@@ Location ( ) ) ; set@@ File@@ System@@ Provider ( this ) ; } public String getType@@ ID ( ) { return SV@@ DB@@ Plugin@@ Li@@ b@@ Index@@ Factory . TYPE ; } @ Override protected void dis@@ cover@@ Root@@ Files ( I@@ ProgressMonitor monitor ) { clear@@ Files@@ List ( ) ; clear@@ Inclu@@ de@@ Paths ( ) ; add@@ File ( getBase@@ Location ( ) ) ; add@@ Inclu@@ de@@ Path ( get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) ) ; } public boolean is@@ Dir ( String path ) { if ( path . startsWith ( "@@ plugin@@ :@@ /" ) ) { URL entry ; String le@@ af = path . substring ( ( "@@ plugin@@ :@@ /" + f@@ Plugin@@ NS ) . length ( ) ) ; return ( ( entry = f@@ Bundle . get@@ Entry ( le@@ af ) ) != null && entry . getPath ( ) . endsWith ( "/" ) ) ; } else { return false ; } } public List < String > get@@ Files ( String path ) { return new ArrayList < String > ( ) ; } public void add@@ Marker ( String path , String type , int lin@@ en@@ o , String msg ) { } public void clear@@ Mark@@ ers ( String path ) { } public void close@@ Stream ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { } } public boolean file@@ Exists ( String path ) { if ( path . startsWith ( "@@ plugin@@ :@@ /" ) ) { String le@@ af = path . substring ( ( "@@ plugin@@ :@@ /" + f@@ Plugin@@ NS ) . length ( ) ) ; return ( f@@ Bundle . get@@ Entry ( le@@ af ) != null ) ; } else { return false ; } } public String resolve@@ Path ( String path , String fmt ) { return path ; } public void init ( String root ) { } public InputStream open@@ Stream ( String path ) { InputStream ret = null ; if ( path . startsWith ( "@@ plugin@@ :@@ /" ) ) { String le@@ af = path . substring ( ( "@@ plugin@@ :@@ /" + f@@ Plugin@@ NS ) . length ( ) ) ; URL url = f@@ Bundle . get@@ Entry ( le@@ af ) ; if ( url != null ) { try { ret = url . open@@ Stream ( ) ; } catch ( IOException e ) { f@@ Log . error ( "" + path + "\"" , e ) ; } } } return ret ; } public long getLast@@ Modified@@ Time ( String file ) { if ( f@@ Bundle@@ Version == - 1 ) { Version v = SV@@ Core@@ Plugin . getDefault ( ) . get@@ Bundle ( ) . getVersion ( ) ; f@@ Bundle@@ Version = v . getM@@ ic@@ ro ( ) ; f@@ Bundle@@ Version |= v . getMin@@ or ( ) << 16 ; f@@ Bundle@@ Version |= v . get@@ Ma@@ j@@ or ( ) << 24 ; f@@ Bundle@@ Version |= ( 8@@ L << 48@@ L ) ; } if ( f@@ Bundle@@ Version < f@@ Bundle . getLast@@ Modified ( ) ) { System . out . println ( "" + f@@ Bundle@@ Version + " " + f@@ Bundle . getLast@@ Modified ( ) ) ; } return f@@ Bundle@@ Version ; } @ Override public void dispose ( ) { if ( getC@@ ache ( ) != null ) { getC@@ ache ( ) . sync ( ) ; } } public void add@@ File@@ System@@ ChangeListener ( IS@@ V@@ DB@@ File@@ System@@ ChangeListener l ) { } public void remove@@ File@@ System@@ ChangeListener ( IS@@ V@@ DB@@ File@@ System@@ ChangeListener l ) { } } </s>
<s> package net . sf . sv@@ editor . core . db . index . plugin@@ _@@ lib ; public class SV@@ DB@@ Plugin@@ Li@@ b@@ Descriptor { private String f@@ Name ; private String f@@ Id ; private String f@@ Namespace ; private String f@@ Path ; private boolean f@@ Is@@ Default ; private String f@@ Description ; public SV@@ DB@@ Plugin@@ Li@@ b@@ Descriptor ( String name , String id , String namespace , String path , boolean is_@@ default , String description ) { f@@ Name = name ; f@@ Id = id ; f@@ Namespace = namespace ; f@@ Path = path ; f@@ Is@@ Default = is_@@ default ; f@@ Description = description ; } public String getName ( ) { return f@@ Name ; } public String getId ( ) { return f@@ Id ; } public String getPath ( ) { return f@@ Path ; } public String get@@ Namespace ( ) { return f@@ Namespace ; } public boolean is@@ Default ( ) { return f@@ Is@@ Default ; } public String getDescription ( ) { return f@@ Description ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index . plugin@@ _@@ lib ; import java . io . InputStream ; import java . net . URI ; import java . net . URL ; import org . eclipse . core . files@@ y@@ ste@@ m . E@@ F@@ S ; import org . eclipse . core . files@@ y@@ ste@@ m . I@@ FileInfo ; import org . eclipse . core . files@@ y@@ ste@@ m . I@@ File@@ Store ; import org . eclipse . core . files@@ y@@ ste@@ m . provider . FileInfo ; import org . eclipse . core . files@@ y@@ ste@@ m . provider . File@@ Store ; import org . eclipse . core . runtime . Core@@ Exception ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; import org . eclipse . core . runtime . P@@ latform ; import org . osgi . framework . Bundle ; public class Plugin@@ File@@ Store extends File@@ Store { private URI f@@ URI ; public Plugin@@ File@@ Store ( URI uri ) { f@@ URI = uri ; } public String getPlu@@ gin@@ Path ( ) { return f@@ URI . toString ( ) ; } @ Override public String [ ] child@@ Names ( int options , I@@ ProgressMonitor monitor ) throws Core@@ Exception { return new String [ 0 ] ; } @ Override public I@@ FileInfo fetch@@ Info ( int options , I@@ ProgressMonitor monitor ) throws Core@@ Exception { FileInfo info = new FileInfo ( getName ( ) ) ; info . set@@ Exists ( true ) ; info . set@@ Length ( 1 ) ; info . set@@ Directory ( false ) ; info . setAttribute ( E@@ F@@ S . ATTRIBUTE_@@ READ_@@ ONLY , true ) ; info . setAttribute ( E@@ F@@ S . ATTRIBUTE_@@ H@@ ID@@ DE@@ N , false ) ; return info ; } @ Override public I@@ File@@ Store getChild ( String name ) { return null ; } @ Override public String getName ( ) { return f@@ URI . getPath ( ) . substring ( f@@ URI . getPath ( ) . lastIndexOf ( '/' ) + 1 ) ; } @ Override public I@@ File@@ Store getParent ( ) { return null ; } @ Override public InputStream open@@ InputStream ( int options , I@@ ProgressMonitor monitor ) throws Core@@ Exception { String host = f@@ URI . get@@ Host ( ) ; String path = f@@ URI . getPath ( ) ; if ( host == null ) { host = path . substring ( 1 , path . indexOf ( '/' , 1 ) ) ; path = path . substring ( path . indexOf ( '/' , 1 ) + 1 ) ; } Bundle bundle = P@@ latform . get@@ Bundle ( host ) ; URL url = bundle . get@@ Entry ( path ) ; try { return url . open@@ Stream ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } } @ Override public URI to@@ URI ( ) { return f@@ URI ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; public interface IS@@ V@@ DB@@ Project@@ Ref@@ Provider { SV@@ DB@@ Index@@ Collection resolve@@ Project@@ Ref ( String path ) ; } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . util . Map ; public class SV@@ DB@@ Index@@ Factory@@ Utils { @ SuppressWarnings ( "unchecked" ) public static void set@@ Base@@ Properties ( Map < String , Object > config , IS@@ V@@ DB@@ Index index ) { if ( config != null ) { if ( config . containsKey ( IS@@ V@@ DB@@ Index@@ Factory . KEY_@@ Global@@ Defin@@ e@@ Map ) ) { Map < String , String > defin@@ e_@@ map = ( Map < String , String > ) config . get ( IS@@ V@@ DB@@ Index@@ Factory . KEY_@@ Global@@ Defin@@ e@@ Map ) ; for ( String key : defin@@ e_@@ map . keySet ( ) ) { index . set@@ Global@@ Defin@@ e ( key , defin@@ e_@@ map . get ( key ) ) ; } } } } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import java . util . regex . Pattern ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . SV@@ FileUtils ; import net . sf . sv@@ editor . core . Tuple ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Parent ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ File@@ Factory ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Named@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Scope@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Marker ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Marker . Mar@@ ker@@ Kind ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Marker . Mar@@ ker@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Package@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Pre@@ Proc@@ Con@@ d ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Pre@@ Proc@@ Observer ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache ; import net . sf . sv@@ editor . core . db . re@@ fs . IS@@ V@@ DB@@ Ref@@ Matcher ; import net . sf . sv@@ editor . core . db . re@@ fs . SV@@ DB@@ Ref@@ Cache@@ Entry ; import net . sf . sv@@ editor . core . db . re@@ fs . SV@@ DB@@ Ref@@ Cache@@ Item ; import net . sf . sv@@ editor . core . db . search . IS@@ V@@ DB@@ Find@@ Name@@ Matcher ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Search@@ Result ; import net . sf . sv@@ editor . core . job@@ _@@ m@@ gr . I@@ Job ; import net . sf . sv@@ editor . core . job@@ _@@ m@@ gr . I@@ Job@@ Mgr ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Handle ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level@@ Listener ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import net . sf . sv@@ editor . core . pre@@ pro@@ c . SV@@ Pre@@ Proc@@ Direc@@ tive@@ Scanner ; import net . sf . sv@@ editor . core . scanner . File@@ Context@@ Search@@ M@@ ac@@ ro@@ Provider ; import net . sf . sv@@ editor . core . scanner . I@@ Pre@@ Proc@@ M@@ ac@@ ro@@ Provider ; import net . sf . sv@@ editor . core . scanner . SV@@ File@@ Tree@@ M@@ ac@@ ro@@ Provider ; import net . sf . sv@@ editor . core . scanner . SV@@ Pre@@ Proc@@ Defin@@ e@@ Provider ; import org . eclipse . core . files@@ y@@ ste@@ m . provider . File@@ Tree ; import org . eclipse . core . resources . I@@ Container ; import org . eclipse . core . resources . I@@ File ; import org . eclipse . core . resources . I@@ Work@@ space@@ Root ; import org . eclipse . core . resources . Resources@@ Plugin ; import org . eclipse . core . runtime . I@@ Path ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; import org . eclipse . core . runtime . Path ; import org . eclipse . core . runtime . Sub@@ ProgressMonitor ; public abstract class Abstract@@ Thread@@ ed@@ SV@@ DB@@ Index implements IS@@ V@@ DB@@ Index , IS@@ V@@ DB@@ File@@ System@@ ChangeListener , I@@ Log@@ Level@@ Listener , I@@ Log@@ Level { private static final int Index@@ State@@ _@@ All@@ Invalid = 0 ; private static final int Index@@ State@@ _@@ Root@@ Files@@ Dis@@ cover@@ ed = ( Index@@ State@@ _@@ All@@ Invalid + 1 ) ; private static final int Index@@ State@@ _@@ Files@@ Pre@@ Process@@ ed = ( Index@@ State@@ _@@ Root@@ Files@@ Dis@@ cover@@ ed + 1 ) ; private static final int Index@@ State@@ _@@ File@@ Tree@@ Valid = ( Index@@ State@@ _@@ Files@@ Pre@@ Process@@ ed + 1 ) ; private static final int Index@@ State@@ _@@ All@@ Files@@ Par@@ sed = ( Index@@ State@@ _@@ File@@ Tree@@ Valid + 1 ) ; public String f@@ Project@@ Name ; private String f@@ Base@@ Location ; private String f@@ Resol@@ ved@@ Base@@ Location ; private String f@@ Base@@ Location@@ Dir ; private SV@@ DB@@ Base@@ Index@@ Cache@@ Data f@@ Index@@ Cache@@ Data ; private boolean f@@ Cache@@ Data@@ Valid ; protected Set < String > f@@ Missing@@ Inclu@@ des ; private IS@@ V@@ DB@@ Inclu@@ de@@ File@@ Provider f@@ Inclu@@ de@@ File@@ Provider ; private List < IS@@ V@@ DB@@ Index@@ ChangeListener > f@@ Index@@ Change@@ Listeners ; protected static Pattern f@@ W@@ in@@ Path@@ Pattern ; protected Log@@ Handle f@@ Log ; private IS@@ V@@ DB@@ File@@ System@@ Provider f@@ File@@ System@@ Provider ; protected boolean f@@ Load@@ Up@@ To@@ Date ; private IS@@ V@@ DB@@ Index@@ Cache f@@ Cache ; private SV@@ DB@@ Index@@ Config f@@ Config ; private Set < String > f@@ File@@ Di@@ rs ; protected boolean f@@ Debug@@ E@@ n ; protected boolean f@@ In@@ Work@@ space@@ O@@ k ; private int f@@ Index@@ State ; protected boolean f@@ Auto@@ Re@@ build@@ E@@ n ; protected boolean f@@ Is@@ Dir@@ ty ; protected boolean f@@ Enable@@ Threads = false ; static { f@@ W@@ in@@ Path@@ Pattern = Pattern . compile ( "\@@ \\@@ \@@ " ) ; } protected Abstract@@ Thread@@ ed@@ SV@@ DB@@ Index ( String project ) { f@@ Index@@ Change@@ Listeners = new ArrayList < IS@@ V@@ DB@@ Index@@ ChangeListener > ( ) ; f@@ Project@@ Name = project ; f@@ Log = LogFactory . get@@ Log@@ Handle ( get@@ Log@@ Name ( ) ) ; f@@ Log . add@@ Log@@ Level@@ Listener ( this ) ; f@@ Debug@@ E@@ n = f@@ Log . isEnabled ( ) ; f@@ Missing@@ Inclu@@ des = new HashSet < String > ( ) ; f@@ Auto@@ Re@@ build@@ E@@ n = true ; f@@ File@@ Di@@ rs = new HashSet < String > ( ) ; } public Abstract@@ Thread@@ ed@@ SV@@ DB@@ Index ( String project , String base@@ _@@ location , IS@@ V@@ DB@@ File@@ System@@ Provider f@@ s_@@ provider , IS@@ V@@ DB@@ Index@@ Cache cache , SV@@ DB@@ Index@@ Config config ) { this ( project ) ; f@@ Base@@ Location = base@@ _@@ location ; f@@ Cache = cache ; f@@ Config = config ; set@@ File@@ System@@ Provider ( f@@ s_@@ provider ) ; f@@ In@@ Work@@ space@@ O@@ k = ( base@@ _@@ location . startsWith ( "" ) ) ; f@@ Auto@@ Re@@ build@@ E@@ n = true ; } public void log@@ Level@@ Changed ( I@@ Log@@ Handle handle ) { f@@ Debug@@ E@@ n = handle . isEnabled ( ) ; } public void set@@ Enable@@ Auto@@ Re@@ build ( boolean en ) { f@@ Auto@@ Re@@ build@@ E@@ n = en ; } public boolean is@@ Dir@@ ty ( ) { return f@@ Is@@ Dir@@ ty ; } protected abstract String get@@ Log@@ Name ( ) ; protected boolean check@@ Cache@@ Valid ( ) { boolean valid = true ; String version = SV@@ Core@@ Plugin . getVersion ( ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + f@@ Index@@ Cache@@ Data . getVersion ( ) + " version@@ =" + version ) ; } if ( f@@ Index@@ Cache@@ Data . getVersion ( ) == null || ! f@@ Index@@ Cache@@ Data . getVersion ( ) . equals ( version ) ) { valid = false ; return valid ; } if ( f@@ Config != null ) { } if ( f@@ Cache . getFile@@ List ( ) . size ( ) > 0 ) { for ( String path : f@@ Cache . getFile@@ List ( ) ) { long f@@ s_@@ timestamp = f@@ File@@ System@@ Provider . getLast@@ Modified@@ Time ( path ) ; long cache@@ _@@ timestamp = f@@ Cache . getLast@@ Modified ( path ) ; if ( f@@ s_@@ timestamp != cache@@ _@@ timestamp ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path + ": file@@ =" + f@@ s_@@ timestamp + " cache@@ =" + cache@@ _@@ timestamp ) ; } valid = false ; break ; } } } else { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "@@ Cache " + getBase@@ Location ( ) + "" ) ; } SV@@ DB@@ Index@@ Factory@@ Utils . set@@ Base@@ Properties ( f@@ Config , this ) ; valid = false ; } if ( getC@@ ache@@ Data ( ) . getM@@ is@@ sing@@ Inclu@@ de@@ Files ( ) . size ( ) > 0 && valid ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" ) ; } for ( String path : getC@@ ache@@ Data ( ) . getM@@ is@@ sing@@ Inclu@@ de@@ Files ( ) ) { SV@@ DB@@ Search@@ Result < SV@@ DB@@ File > res = find@@ Inclu@@ ded@@ File ( path ) ; if ( res != null ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "@@ Cache " + getBase@@ Location ( ) + "" + path ) ; } valid = false ; break ; } } } if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + getBase@@ Location ( ) + " is " + ( ( valid ) ? "@@ valid@@ " : "@@ invalid@@ " ) ) ; } return valid ; } @ SuppressWarnings ( "unchecked" ) public void init ( I@@ ProgressMonitor monitor ) { Sub@@ ProgressMonitor m ; monitor . begin@@ Task ( "" + getBase@@ Location ( ) , 100 ) ; m = new Sub@@ ProgressMonitor ( monitor , 1 ) ; f@@ Index@@ Cache@@ Data = create@@ Index@@ Cache@@ Data ( ) ; f@@ Cache@@ Data@@ Valid = f@@ Cache . init ( m , f@@ Index@@ Cache@@ Data ) ; if ( f@@ Cache@@ Data@@ Valid ) { f@@ Cache@@ Data@@ Valid = check@@ Cache@@ Valid ( ) ; } if ( f@@ Cache@@ Data@@ Valid ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" ) ; } f@@ Index@@ State = Index@@ State@@ _@@ File@@ Tree@@ Valid ; if ( f@@ Index@@ Cache@@ Data . get@@ Decl@@ Cache@@ Map ( ) != null ) { for ( Entry < String , List < SV@@ DB@@ Decl@@ Cache@@ Item > > e : f@@ Index@@ Cache@@ Data . get@@ Decl@@ Cache@@ Map ( ) . entrySet ( ) ) { for ( SV@@ DB@@ Decl@@ Cache@@ Item i : e . getValue ( ) ) { i . init ( this ) ; } } } if ( f@@ Index@@ Cache@@ Data . getPack@@ age@@ Cache@@ Map ( ) != null ) { for ( Entry < String , List < SV@@ DB@@ Decl@@ Cache@@ Item > > e : f@@ Index@@ Cache@@ Data . getPack@@ age@@ Cache@@ Map ( ) . entrySet ( ) ) { for ( SV@@ DB@@ Decl@@ Cache@@ Item i : e . getValue ( ) ) { i . init ( this ) ; } } } for ( String f : f@@ Cache . getFile@@ List ( ) ) { add@@ File@@ Dir ( f ) ; } } else { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "@@ Cache " + getBase@@ Location ( ) + " is invalid@@ " ) ; } in@@ validate@@ Index ( "" , true ) ; } f@@ Index@@ Cache@@ Data . set@@ Version ( SV@@ Core@@ Plugin . getVersion ( ) ) ; if ( f@@ Config != null && f@@ Config . containsKey ( IS@@ V@@ DB@@ Index@@ Factory . KEY_@@ Global@@ Defin@@ e@@ Map ) ) { Map < String , String > defin@@ e_@@ map = ( Map < String , String > ) f@@ Config . get ( IS@@ V@@ DB@@ Index@@ Factory . KEY_@@ Global@@ Defin@@ e@@ Map ) ; f@@ Index@@ Cache@@ Data . clear@@ Global@@ Defin@@ es ( ) ; for ( String key : defin@@ e_@@ map . keySet ( ) ) { f@@ Index@@ Cache@@ Data . set@@ Global@@ Defin@@ e ( key , defin@@ e_@@ map . get ( key ) ) ; } } monitor . done ( ) ; } public void load@@ Index ( I@@ ProgressMonitor monitor ) { ensure@@ Index@@ State ( monitor , Index@@ State@@ _@@ All@@ Files@@ Par@@ sed ) ; } public synchronized void ensure@@ Index@@ State ( I@@ ProgressMonitor monitor , int state ) { List < I@@ Job > job@@ s = new ArrayList < I@@ Job > ( ) ; I@@ Job@@ Mgr job@@ _@@ m@@ gr = SV@@ Core@@ Plugin . getJob@@ Mgr ( ) ; monitor . begin@@ Task ( "" + getBase@@ Location ( ) , 4 ) ; if ( f@@ Index@@ State < Index@@ State@@ _@@ Root@@ Files@@ Dis@@ cover@@ ed && state >= Index@@ State@@ _@@ Root@@ Files@@ Dis@@ cover@@ ed ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + f@@ Index@@ State ) ; } Sub@@ ProgressMonitor m = new Sub@@ ProgressMonitor ( monitor , 1 ) ; dis@@ cover@@ Root@@ Files ( job@@ s ) ; f@@ Cache . sync ( ) ; f@@ Is@@ Dir@@ ty = false ; join ( m , job@@ s ) ; job@@ s . clear ( ) ; f@@ Index@@ State = Index@@ State@@ _@@ Root@@ Files@@ Dis@@ cover@@ ed ; } if ( f@@ Index@@ State < Index@@ State@@ _@@ Files@@ Pre@@ Process@@ ed && state >= Index@@ State@@ _@@ Files@@ Pre@@ Process@@ ed ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + f@@ Index@@ State ) ; } Sub@@ ProgressMonitor m = new Sub@@ ProgressMonitor ( monitor , 1 ) ; pre@@ Process@@ Files ( job@@ s ) ; f@@ Is@@ Dir@@ ty = false ; join ( m , job@@ s ) ; job@@ s . clear ( ) ; f@@ Index@@ State = Index@@ State@@ _@@ Files@@ Pre@@ Process@@ ed ; } if ( f@@ Index@@ State < Index@@ State@@ _@@ File@@ Tree@@ Valid && state >= Index@@ State@@ _@@ File@@ Tree@@ Valid ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + f@@ Index@@ State ) ; } Sub@@ ProgressMonitor m = new Sub@@ ProgressMonitor ( monitor , 1 ) ; List < String > missing@@ _@@ inclu@@ des = new ArrayList < String > ( ) ; build@@ File@@ Tree ( job@@ s , missing@@ _@@ inclu@@ des ) ; join ( m , job@@ s ) ; job@@ s . clear ( ) ; getC@@ ache@@ Data ( ) . clear@@ Missing@@ Inclu@@ de@@ Files ( ) ; for ( String path : missing@@ _@@ inclu@@ des ) { getC@@ ache@@ Data ( ) . add@@ Missing@@ Inclu@@ de@@ File ( path ) ; } prop@@ ag@@ ate@@ All@@ Mark@@ ers ( ) ; notify@@ Index@@ Re@@ bu@@ il@@ t ( ) ; f@@ Is@@ Dir@@ ty = false ; f@@ Index@@ State = Index@@ State@@ _@@ File@@ Tree@@ Valid ; } if ( f@@ Index@@ State < Index@@ State@@ _@@ All@@ Files@@ Par@@ sed && state >= Index@@ State@@ _@@ All@@ Files@@ Par@@ sed ) { if ( f@@ Cache@@ Data@@ Valid ) { Sub@@ ProgressMonitor m = new Sub@@ ProgressMonitor ( monitor , 1 ) ; f@@ Cache . init@@ Load ( m ) ; m . done ( ) ; } else { parse@@ Files ( job@@ s ) ; } f@@ Index@@ State = Index@@ State@@ _@@ All@@ Files@@ Par@@ sed ; f@@ Is@@ Dir@@ ty = false ; join ( new Null@@ ProgressMonitor ( ) , job@@ s ) ; job@@ s . clear ( ) ; } monitor . done ( ) ; } protected void parse@@ Files ( List < I@@ Job > job@@ s ) { final List < String > path@@ s = new ArrayList < String > ( ) ; f@@ Log . debug ( LE@@ VE@@ L_@@ MA@@ X , "@@ parse@@ Fil@@ es" ) ; synchronized ( f@@ Cache ) { path@@ s . addAll ( f@@ Cache . getFile@@ List ( ) ) ; } I@@ Job@@ Mgr job@@ _@@ m@@ gr = SV@@ Core@@ Plugin . getJob@@ Mgr ( ) ; for ( String path : path@@ s ) { Parse@@ Files@@ Runnable r = new Parse@@ Files@@ Runnable ( path ) ; I@@ Job j = job@@ _@@ m@@ gr . create@@ Job ( ) ; j . init ( path , r ) ; synchronized ( job@@ s ) { job@@ s . add ( j ) ; } if ( f@@ Enable@@ Threads ) { job@@ _@@ m@@ gr . queue@@ Job ( j ) ; } } } private class Parse@@ Files@@ Runnable implements Runnable { private String f@@ Path ; public Parse@@ Files@@ Runnable ( String path ) { f@@ Path = path ; } public void run ( ) { SV@@ DB@@ File file ; SV@@ DB@@ File@@ Tree ft@@ _@@ root ; synchronized ( f@@ Cache ) { ft@@ _@@ root = f@@ Cache . getFile@@ Tree ( new Null@@ ProgressMonitor ( ) , f@@ Path ) ; } if ( ft@@ _@@ root == null ) { try { throw new Exception ( ) ; } catch ( Exception e ) { f@@ Log . error ( "@@ File Path \"" + f@@ Path + "" + getBase@@ Location ( ) , e ) ; for ( String p : getFile@@ List ( new Null@@ ProgressMonitor ( ) ) ) { f@@ Log . error ( "@@ path@@ : " + p ) ; } } } long start = System . currentTimeMillis ( ) ; I@@ Pre@@ Proc@@ M@@ ac@@ ro@@ Provider mp = create@@ M@@ ac@@ ro@@ Provider ( ft@@ _@@ root ) ; process@@ File ( ft@@ _@@ root , mp ) ; long end = System . currentTimeMillis ( ) ; synchronized ( f@@ Cache ) { file = f@@ Cache . getFile ( new Null@@ ProgressMonitor ( ) , f@@ Path ) ; } } } protected void in@@ validate@@ Index ( String reason , boolean force ) { if ( f@@ Debug@@ E@@ n ) { if ( f@@ Auto@@ Re@@ build@@ E@@ n || force ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + ( ( reason == null ) ? "" : reason ) ) ; } else { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + ( ( reason == null ) ? "" : reason ) + "" ) ; } } if ( f@@ Auto@@ Re@@ build@@ E@@ n || force ) { f@@ Index@@ State = Index@@ State@@ _@@ All@@ Invalid ; f@@ Cache@@ Data@@ Valid = false ; f@@ Index@@ Cache@@ Data . clear ( ) ; f@@ Cache . clear ( new Null@@ ProgressMonitor ( ) ) ; f@@ Missing@@ Inclu@@ des . clear ( ) ; } else { f@@ Is@@ Dir@@ ty = true ; } } public void re@@ build@@ Index ( I@@ ProgressMonitor monitor ) { in@@ validate@@ Index ( "" , true ) ; } public IS@@ V@@ DB@@ Index@@ Cache getC@@ ache ( ) { return f@@ Cache ; } public SV@@ DB@@ Index@@ Config getConfig ( ) { return f@@ Config ; } protected SV@@ DB@@ Base@@ Index@@ Cache@@ Data getC@@ ache@@ Data ( ) { return f@@ Index@@ Cache@@ Data ; } public void set@@ File@@ System@@ Provider ( IS@@ V@@ DB@@ File@@ System@@ Provider f@@ s_@@ provider ) { if ( f@@ File@@ System@@ Provider != null && f@@ s_@@ provider != f@@ File@@ System@@ Provider ) { f@@ File@@ System@@ Provider . remove@@ File@@ System@@ ChangeListener ( this ) ; } f@@ File@@ System@@ Provider = f@@ s_@@ provider ; if ( f@@ File@@ System@@ Provider != null ) { f@@ File@@ System@@ Provider . init ( get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) ) ; f@@ File@@ System@@ Provider . add@@ File@@ System@@ ChangeListener ( this ) ; } } public IS@@ V@@ DB@@ File@@ System@@ Provider getFile@@ System@@ Provider ( ) { return f@@ File@@ System@@ Provider ; } public void file@@ Changed ( String path ) { synchronized ( f@@ Cache ) { if ( f@@ Cache . getFile@@ List ( ) . contains ( path ) ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path ) ; } f@@ Cache . set@@ File ( path , null ) ; f@@ Cache . setLast@@ Modified ( path , getFile@@ System@@ Provider ( ) . getLast@@ Modified@@ Time ( path ) ) ; } } } public void file@@ Removed ( String path ) { synchronized ( f@@ Cache ) { if ( f@@ Cache . getFile@@ List ( ) . contains ( path ) ) { in@@ validate@@ Index ( "@@ File Remo@@ v@@ ed" , false ) ; } } } public void file@@ Added ( String path ) { File f = new File ( path ) ; File p = f . getParent@@ File ( ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "file@@ Add@@ ed@@ : " + path ) ; } if ( f@@ File@@ Di@@ rs . contains ( p . getPath ( ) ) ) { in@@ validate@@ Index ( "@@ File Add@@ ed" , false ) ; } } public String getBase@@ Location ( ) { return f@@ Base@@ Location ; } public String get@@ Project ( ) { return f@@ Project@@ Name ; } public String get@@ Resol@@ ved@@ Base@@ Location ( ) { if ( f@@ Resol@@ ved@@ Base@@ Location == null ) { f@@ Resol@@ ved@@ Base@@ Location = SV@@ DB@@ Index@@ Util . expand@@ Vars ( f@@ Base@@ Location , f@@ Project@@ Name , f@@ In@@ Work@@ space@@ O@@ k ) ; } return f@@ Resol@@ ved@@ Base@@ Location ; } public String get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) { if ( f@@ Base@@ Location@@ Dir == null ) { String base@@ _@@ location = get@@ Resol@@ ved@@ Base@@ Location ( ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + base@@ _@@ location ) ; } if ( f@@ File@@ System@@ Provider . is@@ Dir ( base@@ _@@ location ) ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + base@@ _@@ location + " is_@@ dir@@ " ) ; } f@@ Base@@ Location@@ Dir = base@@ _@@ location ; } else { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + base@@ _@@ location + " not@@ _@@ dir@@ " ) ; } f@@ Base@@ Location@@ Dir = SV@@ FileUtils . getPath@@ Parent ( base@@ _@@ location ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + base@@ _@@ location + ": " + f@@ Base@@ Location@@ Dir ) ; } } } return f@@ Base@@ Location@@ Dir ; } public void set@@ Global@@ Defin@@ e ( String key , String val ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + key + ", " + val + ")" ) ; } f@@ Index@@ Cache@@ Data . set@@ Global@@ Defin@@ e ( key , val ) ; if ( ! f@@ Index@@ Cache@@ Data . get@@ Global@@ Defin@@ es ( ) . containsKey ( key ) || ! f@@ Index@@ Cache@@ Data . get@@ Global@@ Defin@@ es ( ) . get ( key ) . equals ( val ) ) { re@@ build@@ Index ( new Null@@ ProgressMonitor ( ) ) ; } } public void clear@@ Global@@ Defin@@ es ( ) { f@@ Index@@ Cache@@ Data . clear@@ Global@@ Defin@@ es ( ) ; } protected void clear@@ Defin@@ es ( ) { f@@ Index@@ Cache@@ Data . clear@@ Defin@@ es ( ) ; } protected void add@@ Defin@@ e ( String key , String val ) { f@@ Index@@ Cache@@ Data . add@@ Defin@@ e ( key , val ) ; } protected void clear@@ Inclu@@ de@@ Paths ( ) { f@@ Index@@ Cache@@ Data . clear@@ Inclu@@ de@@ Paths ( ) ; } protected void add@@ Inclu@@ de@@ Path ( String path ) { f@@ Index@@ Cache@@ Data . add@@ Inclu@@ de@@ Path ( path ) ; } public Set < String > getFile@@ List ( I@@ ProgressMonitor monitor ) { ensure@@ Index@@ State ( monitor , Index@@ State@@ _@@ File@@ Tree@@ Valid ) ; return f@@ Cache . getFile@@ List ( ) ; } public SV@@ DB@@ File find@@ File ( I@@ ProgressMonitor monitor , String path ) { return find@@ File ( path ) ; } public SV@@ DB@@ File find@@ Pre@@ Proc@@ File ( I@@ ProgressMonitor monitor , String path ) { return find@@ Pre@@ Proc@@ File ( path ) ; } public synchronized List < SV@@ DB@@ Marker > getM@@ ar@@ k@@ ers ( String path ) { find@@ File ( path ) ; return f@@ Cache . getM@@ ar@@ k@@ ers ( path ) ; } protected void add@@ File ( String path ) { synchronized ( f@@ Cache ) { f@@ Cache . add@@ File ( path ) ; f@@ Cache . setLast@@ Modified ( path , getFile@@ System@@ Provider ( ) . getLast@@ Modified@@ Time ( path ) ) ; } add@@ File@@ Dir ( path ) ; } protected void add@@ File@@ Dir ( String file@@ _@@ path ) { File f = new File ( file@@ _@@ path ) ; File p = f . getParent@@ File ( ) ; if ( p != null && ! f@@ File@@ Di@@ rs . contains ( p . getPath ( ) ) ) { f@@ File@@ Di@@ rs . add ( p . getPath ( ) ) ; } } protected void clear@@ Files@@ List ( ) { f@@ Cache . clear ( new Null@@ ProgressMonitor ( ) ) ; f@@ File@@ Di@@ rs . clear ( ) ; } protected void prop@@ ag@@ ate@@ All@@ Mark@@ ers ( ) { Set < String > file@@ _@@ list = f@@ Cache . getFile@@ List ( ) ; for ( String path : file@@ _@@ list ) { if ( path != null ) { prop@@ ag@@ ate@@ Mark@@ ers ( path ) ; } } } protected void prop@@ ag@@ ate@@ Mark@@ ers ( String path ) { List < SV@@ DB@@ Marker > ml = f@@ Cache . getM@@ ar@@ k@@ ers ( path ) ; getFile@@ System@@ Provider ( ) . clear@@ Mark@@ ers ( path ) ; if ( ml != null ) { for ( SV@@ DB@@ Marker m : ml ) { String type = null ; switch ( m . getM@@ ar@@ ker@@ Type ( ) ) { case Info : type = IS@@ V@@ DB@@ File@@ System@@ Provider . MAR@@ K@@ ER_@@ TYPE_@@ INFO ; break ; case Warn@@ ing : type = IS@@ V@@ DB@@ File@@ System@@ Provider . MAR@@ K@@ ER_@@ TYPE_@@ WAR@@ NING ; break ; case Error : type = IS@@ V@@ DB@@ File@@ System@@ Provider . MAR@@ K@@ ER_@@ TYPE_@@ ERROR ; break ; } getFile@@ System@@ Provider ( ) . add@@ Marker ( path , type , m . getLocation ( ) . getL@@ ine ( ) , m . getMessage ( ) ) ; } } } protected SV@@ DB@@ Base@@ Index@@ Cache@@ Data create@@ Index@@ Cache@@ Data ( ) { return new SV@@ DB@@ Base@@ Index@@ Cache@@ Data ( getBase@@ Location ( ) ) ; } protected abstract void dis@@ cover@@ Root@@ Files ( List < I@@ Job > job@@ s ) ; protected void pre@@ Process@@ Files ( List < I@@ Job > job@@ s ) { I@@ Job@@ Mgr job@@ _@@ m@@ gr = SV@@ Core@@ Plugin . getJob@@ Mgr ( ) ; final List < String > path@@ s = new ArrayList < String > ( ) ; synchronized ( f@@ Cache ) { path@@ s . addAll ( f@@ Cache . getFile@@ List ( ) ) ; } for ( String path : path@@ s ) { I@@ Job job = job@@ _@@ m@@ gr . create@@ Job ( ) ; job . init ( path , new Pre@@ Process@@ Files@@ Runnable ( path ) ) ; synchronized ( job@@ s ) { job@@ s . add ( job ) ; } if ( f@@ Enable@@ Threads ) { job@@ _@@ m@@ gr . queue@@ Job ( job ) ; } } } private class Pre@@ Process@@ Files@@ Runnable implements Runnable { private String f@@ Path ; public Pre@@ Process@@ Files@@ Runnable ( String path ) { f@@ Path = path ; } public void run ( ) { long start = System . currentTimeMillis ( ) ; SV@@ DB@@ File file = process@@ Pre@@ Proc@@ File ( f@@ Path ) ; long end = System . currentTimeMillis ( ) ; synchronized ( f@@ Cache ) { f@@ Cache . set@@ Pre@@ Proc@@ File ( f@@ Path , file ) ; f@@ Cache . setLast@@ Modified ( f@@ Path , f@@ File@@ System@@ Provider . getLast@@ Modified@@ Time ( f@@ Path ) ) ; } } } protected void build@@ File@@ Tree ( List < I@@ Job > job@@ s , List < String > missing@@ _@@ inclu@@ des ) { final List < String > path@@ s = new ArrayList < String > ( ) ; I@@ Job@@ Mgr job@@ _@@ m@@ gr = SV@@ Core@@ Plugin . getJob@@ Mgr ( ) ; synchronized ( f@@ Cache ) { path@@ s . addAll ( getC@@ ache ( ) . getFile@@ List ( ) ) ; } f@@ Log . debug ( LE@@ VE@@ L_@@ MA@@ X , "" ) ; for ( String path : path@@ s ) { I@@ Job job = job@@ _@@ m@@ gr . create@@ Job ( ) ; job . init ( path , new Build@@ File@@ Tree@@ Runnable ( path , missing@@ _@@ inclu@@ des ) ) ; synchronized ( job@@ s ) { job@@ s . add ( job ) ; } if ( f@@ Enable@@ Threads ) { job@@ _@@ m@@ gr . queue@@ Job ( job ) ; } } } private class Build@@ File@@ Tree@@ Runnable implements Runnable { private String f@@ Path ; private List < String > f@@ Missing@@ Inclu@@ des ; public Build@@ File@@ Tree@@ Runnable ( String path , List < String > missing@@ _@@ in@@ c ) { f@@ Path = path ; f@@ Missing@@ Inclu@@ des = missing@@ _@@ in@@ c ; } public void run ( ) { SV@@ DB@@ File@@ Tree ft@@ _@@ root ; synchronized ( f@@ Cache ) { ft@@ _@@ root = f@@ Cache . getFile@@ Tree ( new Null@@ ProgressMonitor ( ) , f@@ Path ) ; } if ( ft@@ _@@ root == null ) { SV@@ DB@@ File pp@@ _@@ file ; synchronized ( f@@ Cache ) { pp@@ _@@ file = f@@ Cache . getPre@@ Proc@@ File ( new Null@@ ProgressMonitor ( ) , f@@ Path ) ; } if ( pp@@ _@@ file == null ) { f@@ Log . error ( "" + f@@ Path + "\" from cache@@ " ) ; } else { long start = System . currentTimeMillis ( ) ; ft@@ _@@ root = new SV@@ DB@@ File@@ Tree ( ( SV@@ DB@@ File ) pp@@ _@@ file . d@@ uplic@@ ate ( ) ) ; Set < String > inclu@@ ded@@ _@@ files = new HashSet < String > ( ) ; Map < String , SV@@ DB@@ File@@ Tree > work@@ ing_@@ set = new HashMap < String , SV@@ DB@@ File@@ Tree > ( ) ; build@@ Pre@@ Proc@@ File@@ Map ( null , ft@@ _@@ root , f@@ Missing@@ Inclu@@ des , inclu@@ ded@@ _@@ files , work@@ ing_@@ set ) ; long end = System . currentTimeMillis ( ) ; } } } } private void build@@ Pre@@ Proc@@ File@@ Map ( SV@@ DB@@ File@@ Tree parent , SV@@ DB@@ File@@ Tree root , List < String > missing@@ _@@ inclu@@ des , Set < String > inclu@@ ded@@ _@@ files , Map < String , SV@@ DB@@ File@@ Tree > work@@ ing_@@ set ) { SV@@ DB@@ File@@ Tree@@ Utils ft@@ _@@ utils = new SV@@ DB@@ File@@ Tree@@ Utils ( ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "@@ set@@ File@@ Tree " + root . getFile@@ Path ( ) ) ; } if ( ! work@@ ing_@@ set . containsKey ( root . getFile@@ Path ( ) ) ) { work@@ ing_@@ set . put ( root . getFile@@ Path ( ) , root ) ; } synchronized ( f@@ Cache ) { if ( ! work@@ ing_@@ set . containsKey ( root . getFile@@ Path ( ) ) ) { System . out . println ( "@@ File@@ Tree " + root . getFile@@ Path ( ) + "" ) ; } f@@ Cache . set@@ File@@ Tree ( root . getFile@@ Path ( ) , root ) ; } if ( parent != null ) { root . getIn@@ clu@@ ded@@ By@@ Files ( ) . add ( parent . getFile@@ Path ( ) ) ; } synchronized ( root ) { ft@@ _@@ utils . resolve@@ Condition@@ als ( root , new SV@@ Pre@@ Proc@@ Defin@@ e@@ Provider ( create@@ Pre@@ Proc@@ M@@ ac@@ ro@@ Provider ( root , work@@ ing_@@ set ) ) ) ; } List < SV@@ DB@@ Marker > mark@@ ers = new ArrayList < SV@@ DB@@ Marker > ( ) ; inclu@@ ded@@ _@@ files . add ( root . getFile@@ Path ( ) ) ; add@@ Pre@@ Proc@@ File@@ Inclu@@ de@@ Files ( root , root . getS@@ V@@ DB@@ File ( ) , mark@@ ers , missing@@ _@@ inclu@@ des , inclu@@ ded@@ _@@ files , work@@ ing_@@ set ) ; synchronized ( f@@ Cache ) { f@@ Cache . set@@ File@@ Tree ( root . getFile@@ Path ( ) , root ) ; f@@ Cache . set@@ Mark@@ ers ( root . getFile@@ Path ( ) , mark@@ ers ) ; } } private void add@@ Pre@@ Proc@@ File@@ Inclu@@ de@@ Files ( SV@@ DB@@ File@@ Tree root , IS@@ V@@ DB@@ Scope@@ Item scope , List < SV@@ DB@@ Marker > mark@@ ers , List < String > missing@@ _@@ inclu@@ des , Set < String > inclu@@ ded@@ _@@ files , Map < String , SV@@ DB@@ File@@ Tree > work@@ ing_@@ set ) { for ( int i = 0 ; i < scope . get@@ Items ( ) . size ( ) ; i ++ ) { IS@@ V@@ DB@@ Item@@ Base it = scope . get@@ Items ( ) . get ( i ) ; if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Inclu@@ de ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + ( ( IS@@ V@@ DB@@ Named@@ Item ) it ) . getName ( ) ) ; } SV@@ DB@@ Search@@ Result < SV@@ DB@@ File > f = find@@ Inclu@@ ded@@ File@@ Glob@@ al ( ( ( IS@@ V@@ DB@@ Named@@ Item ) it ) . getName ( ) ) ; if ( f != null ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + ( ( IS@@ V@@ DB@@ Named@@ Item ) it ) . getName ( ) + "\" in index \"" + f . getIndex ( ) . getBase@@ Location ( ) + "\"" ) ; } String file@@ _@@ path = f . getItem ( ) . getFile@@ Path ( ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + file@@ _@@ path + "" + root . getFile@@ Path ( ) + "\"" ) ; } SV@@ DB@@ File@@ Tree ft = new SV@@ DB@@ File@@ Tree ( ( SV@@ DB@@ File ) f . getItem ( ) . d@@ uplic@@ ate ( ) ) ; root . add@@ Inclu@@ ded@@ File ( ft . getFile@@ Path ( ) ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( " No@@ w h@@ as " + ft . getIn@@ clu@@ ded@@ Files ( ) . size ( ) + "" ) ; } if ( ! inclu@@ ded@@ _@@ files . contains ( f . getItem ( ) . getFile@@ Path ( ) ) ) { build@@ Pre@@ Proc@@ File@@ Map ( root , ft , missing@@ _@@ inclu@@ des , inclu@@ ded@@ _@@ files , work@@ ing_@@ set ) ; } } else { String missing@@ _@@ path = ( ( IS@@ V@@ DB@@ Named@@ Item ) it ) . getName ( ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + missing@@ _@@ path + "" + root . getFile@@ Path ( ) + ")" ) ; } synchronized ( missing@@ _@@ inclu@@ des ) { if ( ! missing@@ _@@ inclu@@ des . contains ( missing@@ _@@ path ) ) { missing@@ _@@ inclu@@ des . add ( missing@@ _@@ path ) ; } } SV@@ DB@@ File@@ Tree ft = new SV@@ DB@@ File@@ Tree ( SV@@ DB@@ Item . getName ( it ) ) ; root . add@@ Inclu@@ ded@@ File ( ft . getFile@@ Path ( ) ) ; ft . getIn@@ clu@@ ded@@ By@@ Files ( ) . add ( root . getFile@@ Path ( ) ) ; SV@@ DB@@ Marker err = new SV@@ DB@@ Marker ( Mar@@ ker@@ Type . Error , Mar@@ ker@@ Kind . Missing@@ Inclu@@ de , "" + ( ( IS@@ V@@ DB@@ Named@@ Item ) it ) . getName ( ) + "\"" ) ; err . setLocation ( it . getLocation ( ) ) ; mark@@ ers . add ( err ) ; } } else if ( it instanceof IS@@ V@@ DB@@ Scope@@ Item ) { add@@ Pre@@ Proc@@ File@@ Inclu@@ de@@ Files ( root , ( IS@@ V@@ DB@@ Scope@@ Item ) it , mark@@ ers , missing@@ _@@ inclu@@ des , inclu@@ ded@@ _@@ files , work@@ ing_@@ set ) ; } } } public SV@@ DB@@ Search@@ Result < SV@@ DB@@ File > find@@ Inclu@@ ded@@ File ( String path ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + path ) ; } for ( String inc@@ _@@ dir : f@@ Index@@ Cache@@ Data . getIn@@ clu@@ de@@ Paths ( ) ) { String inc@@ _@@ path = resolve@@ Path ( inc@@ _@@ dir + "/" + path , f@@ In@@ Work@@ space@@ O@@ k ) ; SV@@ DB@@ File file = null ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + inc@@ _@@ path + "\"" ) ; } if ( ( file = f@@ Cache . getPre@@ Proc@@ File ( new Null@@ ProgressMonitor ( ) , inc@@ _@@ path ) ) != null ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + inc@@ _@@ path + "" ) ; } } else { if ( f@@ File@@ System@@ Provider . file@@ Exists ( inc@@ _@@ path ) ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + inc@@ _@@ path + "\"" ) ; } file = process@@ Pre@@ Proc@@ File ( inc@@ _@@ path ) ; add@@ File ( inc@@ _@@ path ) ; f@@ Cache . set@@ Pre@@ Proc@@ File ( inc@@ _@@ path , file ) ; f@@ Cache . setLast@@ Modified ( inc@@ _@@ path , f@@ File@@ System@@ Provider . getLast@@ Modified@@ Time ( inc@@ _@@ path ) ) ; } else { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + inc@@ _@@ path + "" ) ; } } } if ( file != null ) { return new SV@@ DB@@ Search@@ Result < SV@@ DB@@ File > ( file , this ) ; } } String res@@ _@@ path = resolve@@ Path ( path , f@@ In@@ Work@@ space@@ O@@ k ) ; if ( f@@ File@@ System@@ Provider . file@@ Exists ( res@@ _@@ path ) ) { SV@@ DB@@ File pp@@ _@@ file = null ; if ( ( pp@@ _@@ file = process@@ Pre@@ Proc@@ File ( res@@ _@@ path ) ) != null ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + path + "\"" ) ; } add@@ File ( res@@ _@@ path ) ; return new SV@@ DB@@ Search@@ Result < SV@@ DB@@ File > ( pp@@ _@@ file , this ) ; } } return null ; } protected String resolve@@ Path ( String path@@ _@@ or@@ ig , boolean in_@@ work@@ space@@ _@@ ok ) { String path = path@@ _@@ or@@ ig ; String nor@@ m_@@ path = null ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + path@@ _@@ or@@ ig ) ; } if ( path . startsWith ( ".@@ ." ) ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" ) ; } if ( ( nor@@ m_@@ path = resolve@@ Relative@@ Path ( get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) , path ) ) == null ) { for ( String inc@@ _@@ path : f@@ Index@@ Cache@@ Data . getIn@@ clu@@ de@@ Paths ( ) ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( " Check@@ : " + inc@@ _@@ path + " ; " + path ) ; } if ( ( nor@@ m_@@ path = resolve@@ Relative@@ Path ( inc@@ _@@ path , path ) ) != null ) { break ; } } } else { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "n@@ or@@ m_@@ path@@ =" + nor@@ m_@@ path ) ; } } } else { if ( path . equals ( "." ) ) { path = get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) ; } else if ( path . startsWith ( "." ) ) { path = get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) + "/" + path . substring ( 2 ) ; } else { if ( ! f@@ File@@ System@@ Provider . file@@ Exists ( path ) ) { String imp@@ _@@ path = get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) + "/" + path ; if ( f@@ File@@ System@@ Provider . file@@ Exists ( imp@@ _@@ path ) ) { path = imp@@ _@@ path ; } } } nor@@ m_@@ path = normali@@ ze@@ Path ( path ) ; } if ( nor@@ m_@@ path != null && ! nor@@ m_@@ path . startsWith ( "" ) && in_@@ work@@ space@@ _@@ ok ) { I@@ Work@@ space@@ Root w@@ s_@@ root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ File file = w@@ s_@@ root . getFile@@ For@@ Location ( new Path ( nor@@ m_@@ path ) ) ; if ( file != null && file . exists ( ) ) { nor@@ m_@@ path = "" + file . getFull@@ Path ( ) . to@@ O@@ S@@ String ( ) ; } } return ( nor@@ m_@@ path != null ) ? nor@@ m_@@ path : path@@ _@@ or@@ ig ; } private String resolve@@ Relative@@ Path ( String base , String path ) { String nor@@ m_@@ path = normali@@ ze@@ Path ( base + "/" + path ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + nor@@ m_@@ path + "" + get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) ) ; } if ( f@@ File@@ System@@ Provider . file@@ Exists ( nor@@ m_@@ path ) ) { return nor@@ m_@@ path ; } else if ( getBase@@ Location ( ) . startsWith ( "" ) ) { String base@@ _@@ loc = get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + base@@ _@@ loc ) ; } base@@ _@@ loc = base@@ _@@ loc . substring ( "" . length ( ) ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + base@@ _@@ loc ) ; } I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ Container base@@ _@@ dir = null ; try { base@@ _@@ dir = root . get@@ Folder ( new Path ( base@@ _@@ loc ) ) ; } catch ( IllegalArgumentException e ) { } if ( base@@ _@@ dir == null ) { if ( base@@ _@@ loc . length ( ) > 0 ) { base@@ _@@ dir = root . get@@ Project ( base@@ _@@ loc . substring ( 1 ) ) ; } } if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "b@@ ase@@ _@@ dir@@ =" + base@@ _@@ dir ) ; } if ( base@@ _@@ dir != null && base@@ _@@ dir . exists ( ) ) { I@@ Path base@@ _@@ dir@@ _@@ p = base@@ _@@ dir . getLocation ( ) ; if ( base@@ _@@ dir@@ _@@ p != null ) { File path@@ _f@@ _@@ t = new File ( base@@ _@@ dir@@ _@@ p . to@@ File ( ) , path ) ; try { if ( path@@ _f@@ _@@ t . exists ( ) ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + path@@ _f@@ _@@ t . getCanonical@@ Path ( ) ) ; } nor@@ m_@@ path = SV@@ FileUtils . normali@@ ze ( path@@ _f@@ _@@ t . getCanonical@@ Path ( ) ) ; return nor@@ m_@@ path ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } return null ; } protected String normali@@ ze@@ Path ( String path ) { StringBuilder ret = new StringBuilder ( ) ; int i = path . length ( ) - 1 ; int end ; int skip@@ C@@ nt = 0 ; while ( i >= 0 && ( path . charAt ( i ) == '/' || path . charAt ( i ) == '\@@ \@@ ' ) ) { i -- ; } while ( i >= 0 ) { end = ret . length ( ) ; while ( i >= 0 && path . charAt ( i ) != '/' && path . charAt ( i ) != '\@@ \@@ ' ) { ret . append ( path . charAt ( i ) ) ; i -- ; } if ( i != - 1 ) { ret . append ( "/" ) ; i -- ; } if ( ( ret . length ( ) - end ) > 0 ) { String str = ret . substring ( end , ret . length ( ) - 1 ) ; if ( str . equals ( ".@@ ." ) ) { skip@@ C@@ nt ++ ; ret . set@@ Length ( end ) ; } else if ( skip@@ C@@ nt > 0 ) { ret . set@@ Length ( end ) ; skip@@ C@@ nt -- ; } } } return ret . re@@ verse ( ) . toString ( ) ; } public void set@@ Inclu@@ de@@ File@@ Provider ( IS@@ V@@ DB@@ Inclu@@ de@@ File@@ Provider provider ) { f@@ Inclu@@ de@@ File@@ Provider = provider ; } public void add@@ ChangeListener ( IS@@ V@@ DB@@ Index@@ ChangeListener l ) { synchronized ( f@@ Index@@ Change@@ Listeners ) { f@@ Index@@ Change@@ Listeners . add ( l ) ; } } public void remove@@ ChangeListener ( IS@@ V@@ DB@@ Index@@ ChangeListener l ) { synchronized ( f@@ Index@@ Change@@ Listeners ) { f@@ Index@@ Change@@ Listeners . remove ( l ) ; } } protected void notify@@ Index@@ Re@@ bu@@ il@@ t ( ) { synchronized ( f@@ Index@@ Change@@ Listeners ) { for ( IS@@ V@@ DB@@ Index@@ ChangeListener l : f@@ Index@@ Change@@ Listeners ) { l . index@@ _@@ re@@ bu@@ il@@ t ( ) ; } } } public boolean is@@ Loaded ( ) { return true ; } public boolean is@@ File@@ List@@ Loaded ( ) { return ( f@@ Index@@ State >= Index@@ State@@ _@@ File@@ Tree@@ Valid ) ; } protected I@@ Pre@@ Proc@@ M@@ ac@@ ro@@ Provider create@@ M@@ ac@@ ro@@ Provider ( SV@@ DB@@ File@@ Tree file@@ _@@ tree ) { SV@@ File@@ Tree@@ M@@ ac@@ ro@@ Provider mp = new SV@@ File@@ Tree@@ M@@ ac@@ ro@@ Provider ( f@@ Cache , file@@ _@@ tree , f@@ Missing@@ Inclu@@ des ) ; for ( Entry < String , String > entry : f@@ Index@@ Cache@@ Data . get@@ Global@@ Defin@@ es ( ) . entrySet ( ) ) { mp . set@@ M@@ ac@@ ro ( entry . getKey ( ) , entry . getValue ( ) ) ; } for ( Entry < String , String > entry : f@@ Index@@ Cache@@ Data . get@@ Defin@@ es ( ) . entrySet ( ) ) { mp . set@@ M@@ ac@@ ro ( entry . getKey ( ) , entry . getValue ( ) ) ; } return mp ; } protected I@@ Pre@@ Proc@@ M@@ ac@@ ro@@ Provider create@@ Pre@@ Proc@@ M@@ ac@@ ro@@ Provider ( SV@@ DB@@ File@@ Tree file , Map < String , SV@@ DB@@ File@@ Tree > work@@ ing_@@ set ) { File@@ Context@@ Search@@ M@@ ac@@ ro@@ Provider mp = new File@@ Context@@ Search@@ M@@ ac@@ ro@@ Provider ( f@@ Cache , work@@ ing_@@ set ) ; mp . set@@ File@@ Context ( file ) ; for ( Entry < String , String > entry : f@@ Index@@ Cache@@ Data . get@@ Global@@ Defin@@ es ( ) . entrySet ( ) ) { mp . set@@ M@@ ac@@ ro ( entry . getKey ( ) , entry . getValue ( ) ) ; } for ( Entry < String , String > entry : f@@ Index@@ Cache@@ Data . get@@ Defin@@ es ( ) . entrySet ( ) ) { mp . set@@ M@@ ac@@ ro ( entry . getKey ( ) , entry . getValue ( ) ) ; } return mp ; } public SV@@ DB@@ Search@@ Result < SV@@ DB@@ File > find@@ Inclu@@ ded@@ File@@ Glob@@ al ( String le@@ af ) { SV@@ DB@@ Search@@ Result < SV@@ DB@@ File > ret = find@@ Inclu@@ ded@@ File ( le@@ af ) ; if ( ret == null ) { if ( f@@ Inclu@@ de@@ File@@ Provider != null ) { ret = f@@ Inclu@@ de@@ File@@ Provider . find@@ Inclu@@ ded@@ File ( le@@ af ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" + le@@ af + "" + ret + ")" ) ; } } else { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" ) ; } } } return ret ; } public Tuple < SV@@ DB@@ File , SV@@ DB@@ File > parse ( I@@ ProgressMonitor monitor , InputStream in , String path , List < SV@@ DB@@ Marker > mark@@ ers ) { if ( mark@@ ers == null ) { mark@@ ers = new ArrayList < SV@@ DB@@ Marker > ( ) ; } SV@@ Pre@@ Proc@@ Defin@@ e@@ Provider d@@ p = new SV@@ Pre@@ Proc@@ Defin@@ e@@ Provider ( null ) ; IS@@ V@@ DB@@ File@@ Factory factory = SV@@ Core@@ Plugin . create@@ File@@ Factory ( d@@ p ) ; path = SV@@ FileUtils . normali@@ ze ( path ) ; SV@@ DB@@ File@@ Tree file@@ _@@ tree = find@@ File@@ Tree ( path ) ; if ( file@@ _@@ tree == null ) { if ( getFile@@ System@@ Provider ( ) . file@@ Exists ( path ) ) { in@@ validate@@ Index ( "" + path , false ) ; add@@ File ( path ) ; file@@ _@@ tree = find@@ File@@ Tree ( path ) ; if ( file@@ _@@ tree == null && ! f@@ Auto@@ Re@@ build@@ E@@ n ) { file@@ _@@ tree = inc@@ r@@ Create@@ File@@ Tree ( path ) ; } } else { return null ; } } mark@@ ers . clear ( ) ; List < SV@@ DB@@ Marker > mar@@ ker@@ s_@@ e = f@@ Cache . getM@@ ar@@ k@@ ers ( path ) ; if ( mar@@ ker@@ s_@@ e != null ) { for ( SV@@ DB@@ Marker m : mar@@ ker@@ s_@@ e ) { if ( m . get@@ Kind ( ) == Mar@@ ker@@ Kind . Missing@@ Inclu@@ de ) { mark@@ ers . add ( m ) ; } } } Input@@ Stream@@ Cop@@ i@@ er cop@@ i@@ er = new Input@@ Stream@@ Cop@@ i@@ er ( in ) ; in = null ; SV@@ Pre@@ Proc@@ Direc@@ tive@@ Scanner sc = new SV@@ Pre@@ Proc@@ Direc@@ tive@@ Scanner ( ) ; SV@@ DB@@ Pre@@ Proc@@ Observer ob = new SV@@ DB@@ Pre@@ Proc@@ Observer ( ) ; sc . set@@ Observer ( ob ) ; file@@ _@@ tree = file@@ _@@ tree . d@@ uplic@@ ate ( ) ; sc . init ( cop@@ i@@ er . copy ( ) , path ) ; sc . process ( ) ; SV@@ DB@@ File sv@@ db@@ _p@@ p = ob . get@@ Files ( ) . get ( 0 ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "" ) ; } file@@ _@@ tree . setS@@ V@@ DB@@ File ( sv@@ db@@ _p@@ p ) ; if ( file@@ _@@ tree . getFile@@ Path ( ) == null ) { System . out . println ( "" + path + " is null@@ " ) ; } d@@ p . set@@ M@@ ac@@ ro@@ Provider ( create@@ M@@ ac@@ ro@@ Provider ( file@@ _@@ tree ) ) ; SV@@ DB@@ File sv@@ db@@ _@@ f = factory . parse ( cop@@ i@@ er . copy ( ) , file@@ _@@ tree . getFile@@ Path ( ) , mark@@ ers ) ; if ( sv@@ db@@ _@@ f . getFile@@ Path ( ) == null ) { System . out . println ( "@@ file path@@ : " + path + " is null@@ " ) ; } return new Tuple < SV@@ DB@@ File , SV@@ DB@@ File > ( sv@@ db@@ _p@@ p , sv@@ db@@ _@@ f ) ; } public IS@@ V@@ DB@@ Item@@ Iterator getItem@@ Iterator ( I@@ ProgressMonitor monitor ) { return new SV@@ DB@@ Index@@ Item@@ Iterator ( getFile@@ List ( new Null@@ ProgressMonitor ( ) ) , this ) ; } public SV@@ DB@@ File find@@ File ( String path ) { ensure@@ Index@@ State ( new Null@@ ProgressMonitor ( ) , Index@@ State@@ _@@ File@@ Tree@@ Valid ) ; SV@@ DB@@ File ret ; synchronized ( f@@ Cache ) { ret = f@@ Cache . getFile ( new Null@@ ProgressMonitor ( ) , path ) ; } if ( ret == null ) { SV@@ DB@@ File@@ Tree ft@@ _@@ root ; synchronized ( f@@ Cache ) { ft@@ _@@ root = f@@ Cache . getFile@@ Tree ( new Null@@ ProgressMonitor ( ) , path ) ; } if ( ft@@ _@@ root != null ) { I@@ Pre@@ Proc@@ M@@ ac@@ ro@@ Provider mp = create@@ M@@ ac@@ ro@@ Provider ( ft@@ _@@ root ) ; process@@ File ( ft@@ _@@ root , mp ) ; synchronized ( f@@ Cache ) { ret = f@@ Cache . getFile ( new Null@@ ProgressMonitor ( ) , path ) ; } } else { try { throw new Exception ( ) ; } catch ( Exception e ) { f@@ Log . error ( "@@ File Path \"" + path + "" , e ) ; for ( String p : getFile@@ List ( new Null@@ ProgressMonitor ( ) ) ) { System . out . println ( "@@ path@@ : " + p ) ; } } } } if ( ret == null ) { try { throw new Exception ( "@@ File \"" + path + "\" not found@@ " ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return ret ; } protected void process@@ File ( SV@@ DB@@ File@@ Tree path , I@@ Pre@@ Proc@@ M@@ ac@@ ro@@ Provider mp ) { SV@@ Pre@@ Proc@@ Defin@@ e@@ Provider d@@ p = new SV@@ Pre@@ Proc@@ Defin@@ e@@ Provider ( mp ) ; IS@@ V@@ DB@@ File@@ Factory factory = SV@@ Core@@ Plugin . create@@ File@@ Factory ( d@@ p ) ; f@@ Log . debug ( LE@@ VE@@ L_@@ MA@@ X , "" + path . getFile@@ Path ( ) ) ; String path@@ _@@ s = path . getFile@@ Path ( ) ; InputStream in = f@@ File@@ System@@ Provider . open@@ Stream ( path@@ _@@ s ) ; if ( in == null ) { f@@ Log . error ( "" + path@@ _@@ s + "\"" ) ; } BufferedInputStream in_@@ b = new BufferedInputStream ( in ) ; List < SV@@ DB@@ Marker > mark@@ ers = f@@ Cache . getM@@ ar@@ k@@ ers ( path . getFile@@ Path ( ) ) ; if ( mark@@ ers == null ) { mark@@ ers = new ArrayList < SV@@ DB@@ Marker > ( ) ; } for ( int i = 0 ; i < mark@@ ers . size ( ) ; i ++ ) { if ( mark@@ ers . get ( i ) . get@@ Kind ( ) == Mar@@ ker@@ Kind . Un@@ defin@@ ed@@ M@@ ac@@ ro || mark@@ ers . get ( i ) . get@@ Kind ( ) == Mar@@ ker@@ Kind . Parse@@ Error ) { mark@@ ers . remove ( i ) ; i -- ; } } SV@@ DB@@ File sv@@ db@@ _@@ f = factory . parse ( in_@@ b , path . getFile@@ Path ( ) , mark@@ ers ) ; if ( sv@@ db@@ _@@ f == null ) { return ; } cache@@ Declar@@ ations ( sv@@ db@@ _@@ f ) ; f@@ File@@ System@@ Provider . clear@@ Mark@@ ers ( path@@ _@@ s ) ; f@@ Cache . set@@ File ( path . getFile@@ Path ( ) , sv@@ db@@ _@@ f ) ; f@@ Cache . setLast@@ Modified ( path . getFile@@ Path ( ) , f@@ File@@ System@@ Provider . getLast@@ Modified@@ Time ( path . getFile@@ Path ( ) ) ) ; f@@ Cache . set@@ Mark@@ ers ( path . getFile@@ Path ( ) , mark@@ ers ) ; f@@ File@@ System@@ Provider . close@@ Stream ( in ) ; prop@@ ag@@ ate@@ Mark@@ ers ( path . getFile@@ Path ( ) ) ; } public synchronized SV@@ DB@@ File find@@ Pre@@ Proc@@ File ( String path ) { ensure@@ Index@@ State ( new Null@@ ProgressMonitor ( ) , Index@@ State@@ _@@ File@@ Tree@@ Valid ) ; return f@@ Cache . getPre@@ Proc@@ File ( new Null@@ ProgressMonitor ( ) , path ) ; } protected SV@@ DB@@ File process@@ Pre@@ Proc@@ File ( String path ) { SV@@ Pre@@ Proc@@ Direc@@ tive@@ Scanner sc = new SV@@ Pre@@ Proc@@ Direc@@ tive@@ Scanner ( ) ; SV@@ DB@@ Pre@@ Proc@@ Observer ob = new SV@@ DB@@ Pre@@ Proc@@ Observer ( ) ; sc . set@@ Observer ( ob ) ; f@@ Log . debug ( "" + path ) ; InputStream in = f@@ File@@ System@@ Provider . open@@ Stream ( path ) ; if ( in == null ) { f@@ Log . error ( getClass ( ) . getName ( ) + "" + path + "\"" ) ; return null ; } sc . init ( in , path ) ; sc . process ( ) ; getFile@@ System@@ Provider ( ) . close@@ Stream ( in ) ; SV@@ DB@@ File file = ob . get@@ Files ( ) . get ( 0 ) ; return file ; } public synchronized SV@@ DB@@ File@@ Tree find@@ File@@ Tree ( String path ) { ensure@@ Index@@ State ( new Null@@ ProgressMonitor ( ) , Index@@ State@@ _@@ File@@ Tree@@ Valid ) ; SV@@ DB@@ File@@ Tree ft = f@@ Cache . getFile@@ Tree ( new Null@@ ProgressMonitor ( ) , path ) ; return ft ; } protected SV@@ DB@@ File@@ Tree inc@@ r@@ Create@@ File@@ Tree ( String path ) { SV@@ DB@@ File@@ Tree ft = new SV@@ DB@@ File@@ Tree ( path ) ; synchronized ( f@@ Cache ) { f@@ Cache . set@@ File@@ Tree ( path , ft ) ; } return ft ; } public void dispose ( ) { f@@ Log . debug ( "@@ dis@@ po@@ se@@ (@@ ) - " + getBase@@ Location ( ) ) ; if ( f@@ Cache != null ) { f@@ Cache . sync ( ) ; } if ( f@@ File@@ System@@ Provider != null ) { f@@ File@@ System@@ Provider . dispose ( ) ; } } public List < SV@@ DB@@ Decl@@ Cache@@ Item > find@@ Global@@ Scope@@ Decl ( I@@ ProgressMonitor monitor , String name , IS@@ V@@ DB@@ Find@@ Name@@ Matcher matcher ) { List < SV@@ DB@@ Decl@@ Cache@@ Item > ret = new ArrayList < SV@@ DB@@ Decl@@ Cache@@ Item > ( ) ; Map < String , List < SV@@ DB@@ Decl@@ Cache@@ Item > > decl@@ _c@@ ache = f@@ Index@@ Cache@@ Data . get@@ Decl@@ Cache@@ Map ( ) ; ensure@@ Index@@ State ( monitor , Index@@ State@@ _@@ All@@ Files@@ Par@@ sed ) ; for ( Entry < String , List < SV@@ DB@@ Decl@@ Cache@@ Item > > e : decl@@ _c@@ ache . entrySet ( ) ) { for ( SV@@ DB@@ Decl@@ Cache@@ Item item : e . getValue ( ) ) { if ( matcher . match ( item , name ) ) { ret . add ( item ) ; } } } return ret ; } public List < SV@@ DB@@ Ref@@ Cache@@ Item > find@@ Reference@@ s ( I@@ ProgressMonitor monitor , String name , IS@@ V@@ DB@@ Ref@@ Matcher matcher ) { List < SV@@ DB@@ Ref@@ Cache@@ Item > ret = new ArrayList < SV@@ DB@@ Ref@@ Cache@@ Item > ( ) ; Map < String , SV@@ DB@@ Ref@@ Cache@@ Entry > ref@@ _c@@ ache = f@@ Index@@ Cache@@ Data . get@@ Reference@@ Cache@@ Map ( ) ; for ( Entry < String , SV@@ DB@@ Ref@@ Cache@@ Entry > e : ref@@ _c@@ ache . entrySet ( ) ) { matcher . find@@ _@@ matches ( ret , e . getValue ( ) , name ) ; } return ret ; } public Iterable < String > getFile@@ Names ( I@@ ProgressMonitor monitor ) { return new Iterable < String > ( ) { public Iterator < String > iterator ( ) { return f@@ Cache . getFile@@ List ( ) . iterator ( ) ; } } ; } protected void cache@@ Declar@@ ations ( SV@@ DB@@ File file ) { Map < String , List < SV@@ DB@@ Decl@@ Cache@@ Item > > decl@@ _c@@ ache = f@@ Index@@ Cache@@ Data . get@@ Decl@@ Cache@@ Map ( ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + file . getFile@@ Path ( ) ) ; } if ( ! decl@@ _c@@ ache . containsKey ( file . getFile@@ Path ( ) ) ) { decl@@ _c@@ ache . put ( file . getFile@@ Path ( ) , new ArrayList < SV@@ DB@@ Decl@@ Cache@@ Item > ( ) ) ; } else { decl@@ _c@@ ache . get ( file . getFile@@ Path ( ) ) . clear ( ) ; } cache@@ Declar@@ ations ( file . getFile@@ Path ( ) , file , false ) ; } private void cache@@ Declar@@ ations ( String filename , IS@@ V@@ DB@@ Child@@ Parent scope , boolean is_@@ ft ) { Map < String , List < SV@@ DB@@ Decl@@ Cache@@ Item > > decl@@ _c@@ ache = f@@ Index@@ Cache@@ Data . get@@ Decl@@ Cache@@ Map ( ) ; List < SV@@ DB@@ Decl@@ Cache@@ Item > decl@@ _@@ list = decl@@ _c@@ ache . get ( filename ) ; for ( IS@@ V@@ DB@@ Child@@ Item item : scope . getChildren ( ) ) { if ( item . getType ( ) . is@@ Elem@@ Of ( SV@@ DB@@ Item@@ Type . Package@@ Decl ) ) { decl@@ _@@ list . add ( new SV@@ DB@@ Decl@@ Cache@@ Item ( this , filename , ( ( SV@@ DB@@ Package@@ Decl ) item ) . getName ( ) , item . getType ( ) , is_@@ ft ) ) ; cache@@ Declar@@ ations ( filename , ( SV@@ DB@@ Package@@ Decl ) item , is_@@ ft ) ; } else if ( item . getType ( ) . is@@ Elem@@ Of ( SV@@ DB@@ Item@@ Type . Function , SV@@ DB@@ Item@@ Type . Task , SV@@ DB@@ Item@@ Type . Class@@ Decl , SV@@ DB@@ Item@@ Type . Module@@ Decl , SV@@ DB@@ Item@@ Type . Interface@@ Decl , SV@@ DB@@ Item@@ Type . Program@@ Decl , SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) ) { f@@ Log . debug ( "@@ Add@@ ing " + item . getType ( ) + " " + ( ( IS@@ V@@ DB@@ Named@@ Item ) item ) . getName ( ) + " to cache@@ " ) ; decl@@ _@@ list . add ( new SV@@ DB@@ Decl@@ Cache@@ Item ( this , filename , ( ( IS@@ V@@ DB@@ Named@@ Item ) item ) . getName ( ) , item . getType ( ) , is_@@ ft ) ) ; } else if ( item . getType ( ) == SV@@ DB@@ Item@@ Type . Pre@@ Proc@@ Con@@ d ) { cache@@ Declar@@ ations ( filename , ( SV@@ DB@@ Pre@@ Proc@@ Con@@ d ) item , is_@@ ft ) ; } else if ( item . getType ( ) == SV@@ DB@@ Item@@ Type . M@@ ac@@ ro@@ Def ) { decl@@ _@@ list . add ( new SV@@ DB@@ Decl@@ Cache@@ Item ( this , filename , ( ( IS@@ V@@ DB@@ Named@@ Item ) item ) . getName ( ) , item . getType ( ) , is_@@ ft ) ) ; } } } public List < SV@@ DB@@ Decl@@ Cache@@ Item > find@@ Package@@ Decl ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item pk@@ g_@@ item ) { return null ; } public SV@@ DB@@ File get@@ Decl@@ File ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item item ) { ensure@@ Index@@ State ( monitor , Index@@ State@@ _@@ All@@ Files@@ Par@@ sed ) ; return find@@ File ( item . get@@ Filename ( ) ) ; } public SV@@ DB@@ File get@@ Decl@@ File@@ P@@ P ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item item ) { ensure@@ Index@@ State ( monitor , Index@@ State@@ _@@ All@@ Files@@ Par@@ sed ) ; return find@@ Pre@@ Proc@@ File ( item . get@@ Filename ( ) ) ; } public SV@@ Pre@@ Proc@@ Direc@@ tive@@ Scanner create@@ Pre@@ Proc@@ Scanner ( String path ) { path = SV@@ FileUtils . normali@@ ze ( path ) ; InputStream in = getFile@@ System@@ Provider ( ) . open@@ Stream ( path ) ; SV@@ DB@@ File@@ Tree ft = find@@ File@@ Tree ( path ) ; if ( ft == null ) { f@@ Log . error ( "" + path + "\"" ) ; return null ; } I@@ Pre@@ Proc@@ M@@ ac@@ ro@@ Provider mp = create@@ M@@ ac@@ ro@@ Provider ( ft ) ; SV@@ Pre@@ Proc@@ Defin@@ e@@ Provider d@@ p = new SV@@ Pre@@ Proc@@ Defin@@ e@@ Provider ( mp ) ; SV@@ Pre@@ Proc@@ Direc@@ tive@@ Scanner pp = new SV@@ Pre@@ Proc@@ Direc@@ tive@@ Scanner ( ) ; pp . set@@ Defin@@ e@@ Provider ( d@@ p ) ; pp . init ( in , path ) ; return pp ; } private void join ( I@@ ProgressMonitor m , List < I@@ Job > job@@ s ) { synchronized ( job@@ s ) { for ( I@@ Job j : job@@ s ) { if ( f@@ Enable@@ Threads ) { j . join ( ) ; } else { j . run ( new Null@@ ProgressMonitor ( ) ) ; } } } } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . util . List ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item ; public interface IS@@ V@@ DB@@ ChangeListener { void SV@@ DB@@ File@@ Changed ( SV@@ DB@@ File file , List < SV@@ DB@@ Item > add@@ s , List < SV@@ DB@@ Item > remo@@ v@@ es , List < SV@@ DB@@ Item > ch@@ anges ) ; } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . io . File ; import java . util . List ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Named@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Inclu@@ de ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Pre@@ Proc@@ Con@@ d ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Scope@@ Item ; import net . sf . sv@@ editor . core . scanner . I@@ Defin@@ e@@ Provider ; public class SV@@ DB@@ File@@ Tree@@ Utils { private boolean f@@ Debug@@ E@@ n = false ; private IS@@ V@@ DB@@ Index f@@ Index ; public SV@@ DB@@ File@@ Tree@@ Utils ( ) { } public void set@@ Index ( IS@@ V@@ DB@@ Index index ) { f@@ Index = index ; } public void resolve@@ Condition@@ als ( SV@@ DB@@ File@@ Tree file , I@@ Defin@@ e@@ Provider d@@ p ) { process@@ Scope ( file . getS@@ V@@ DB@@ File ( ) , d@@ p , file , null ) ; } private static SV@@ DB@@ File@@ Tree find@@ Best@@ In@@ c@@ Parent ( SV@@ DB@@ File@@ Tree file , SV@@ DB@@ File@@ Tree p1 , SV@@ DB@@ File@@ Tree p2 ) { File file@@ _@@ dir = new File ( file . getFile@@ Path ( ) ) . getParent@@ File ( ) ; File p@@ 1_@@ dir = new File ( p1 . getFile@@ Path ( ) ) . getParent@@ File ( ) ; File p@@ 2_@@ dir = new File ( p2 . getFile@@ Path ( ) ) . getParent@@ File ( ) ; if ( file@@ _@@ dir . equals ( p@@ 1_@@ dir ) && ! file@@ _@@ dir . equals ( p@@ 2_@@ dir ) ) { return p1 ; } else if ( file@@ _@@ dir . equals ( p@@ 2_@@ dir ) && ! file@@ _@@ dir . equals ( p@@ 1_@@ dir ) ) { return p2 ; } else { return p1 ; } } private void process@@ File ( I@@ Defin@@ e@@ Provider d@@ p , SV@@ DB@@ File@@ Tree file , List < SV@@ DB@@ File@@ Tree > file@@ _@@ l ) { debug ( "" + file . getFile@@ Path ( ) + ")" ) ; file . set@@ File@@ Process@@ ed ( true ) ; process@@ Scope ( file . getS@@ V@@ DB@@ File ( ) , d@@ p , file , file@@ _@@ l ) ; if ( f@@ Debug@@ E@@ n ) { debug ( " File \"" + file . getFile@@ Path ( ) + "\" complet@@ e" ) ; for ( String f : file . getIn@@ clu@@ ded@@ Files ( ) ) { debug ( "" + f ) ; } for ( String f : file . getIn@@ clu@@ ded@@ By@@ Files ( ) ) { debug ( "" + f ) ; } } debug ( "" + file . getFile@@ Path ( ) + ")" ) ; } private void process@@ Scope ( SV@@ DB@@ Scope@@ Item scope , I@@ Defin@@ e@@ Provider d@@ p , SV@@ DB@@ File@@ Tree file , List < SV@@ DB@@ File@@ Tree > file@@ _@@ l ) { List < IS@@ V@@ DB@@ Item@@ Base > it@@ _@@ l = scope . get@@ Items ( ) ; debug ( "" + scope . getName ( ) ) ; for ( int i = 0 ; i < it@@ _@@ l . size ( ) ; i ++ ) { IS@@ V@@ DB@@ Item@@ Base it = it@@ _@@ l . get ( i ) ; if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Pre@@ Proc@@ Con@@ d ) { SV@@ DB@@ Pre@@ Proc@@ Con@@ d c = ( SV@@ DB@@ Pre@@ Proc@@ Con@@ d ) it ; debug ( "@@ con@@ d@@ =" + c . get@@ Condition@@ al ( ) ) ; debug ( "" + c . getName ( ) + " " + c . get@@ Condition@@ al ( ) ) ; String con@@ d = c . get@@ Condition@@ al ( ) ; boolean defin@@ ed = d@@ p . is@@ Defin@@ ed ( con@@ d , it . getLocation ( ) . getL@@ ine ( ) ) ; if ( ( defin@@ ed && c . getName ( ) . equals ( "@@ if@@ def@@ " ) ) || ( ! defin@@ ed && c . getName ( ) . equals ( "@@ if@@ n@@ def@@ " ) ) ) { while ( i + 1 < it@@ _@@ l . size ( ) && it@@ _@@ l . get ( i + 1 ) . getType ( ) == SV@@ DB@@ Item@@ Type . Pre@@ Proc@@ Con@@ d && ( ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _@@ l . get ( i + 1 ) ) . getName ( ) . equals ( "@@ el@@ se@@ " ) || ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _@@ l . get ( i + 1 ) ) . getName ( ) . equals ( "@@ el@@ si@@ f" ) ) ) { debug ( "" ) ; it@@ _@@ l . remove ( i + 1 ) ; } it@@ _@@ l . remove ( i ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + c . getName ( ) + ")" ) ; for ( IS@@ V@@ DB@@ Item@@ Base it@@ _@@ t : c . getChildren ( ) ) { debug ( " " + it@@ _@@ t . getType ( ) + " " + ( ( ( it@@ _@@ t instanceof IS@@ V@@ DB@@ Named@@ Item ) ) ? ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _@@ t ) . getName ( ) : "@@ UN@@ NAM@@ ED@@ " ) ) ; } } it@@ _@@ l . addAll ( i , c . get@@ Items ( ) ) ; i -- ; } else { boolean ta@@ ken = false ; it@@ _@@ l . remove ( i ) ; while ( i < it@@ _@@ l . size ( ) && it@@ _@@ l . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Pre@@ Proc@@ Con@@ d && ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _@@ l . get ( i ) ) . getName ( ) . equals ( "@@ el@@ si@@ f" ) ) { String el@@ si@@ f_@@ con@@ d = ( ( SV@@ DB@@ Pre@@ Proc@@ Con@@ d ) it@@ _@@ l . get ( i ) ) . get@@ Condition@@ al ( ) ; ta@@ ken = d@@ p . is@@ Defin@@ ed ( el@@ si@@ f_@@ con@@ d , it . getLocation ( ) . getL@@ ine ( ) ) ; if ( ta@@ ken ) { break ; } it@@ _@@ l . remove ( i ) ; } if ( ta@@ ken ) { IS@@ V@@ DB@@ Item@@ Base it@@ _@@ t = it@@ _@@ l . get ( i ) ; it@@ _@@ l . remove ( i ) ; it@@ _@@ l . addAll ( i , ( ( SV@@ DB@@ Pre@@ Proc@@ Con@@ d ) it@@ _@@ t ) . get@@ Items ( ) ) ; while ( i < it@@ _@@ l . size ( ) && it@@ _@@ l . get ( i + 1 ) . getType ( ) == SV@@ DB@@ Item@@ Type . Pre@@ Proc@@ Con@@ d && ( ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _@@ l . get ( i ) ) . getName ( ) . equals ( "@@ el@@ si@@ f" ) || ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _@@ l . get ( i ) ) . getName ( ) . equals ( "@@ el@@ se@@ " ) ) ) { it@@ _@@ l . remove ( i ) ; } } else { if ( i < it@@ _@@ l . size ( ) ) { IS@@ V@@ DB@@ Item@@ Base it@@ _@@ t = it@@ _@@ l . get ( i ) ; debug ( "" + SV@@ DB@@ Item . getName ( it@@ _@@ t ) ) ; if ( it@@ _@@ t . getType ( ) == SV@@ DB@@ Item@@ Type . Pre@@ Proc@@ Con@@ d && ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _@@ t ) . getName ( ) . equals ( "@@ el@@ se@@ " ) ) { it@@ _@@ l . remove ( i ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; for ( IS@@ V@@ DB@@ Item@@ Base it@@ _@@ t@@ t : ( ( SV@@ DB@@ Pre@@ Proc@@ Con@@ d ) it@@ _@@ t ) . getChildren ( ) ) { debug ( " " + it@@ _@@ t@@ t . getType ( ) + " " + ( ( it@@ _@@ t@@ t instanceof IS@@ V@@ DB@@ Named@@ Item ) ? ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _@@ t@@ t ) . getName ( ) : "@@ UN@@ NAM@@ ED@@ " ) ) ; } } it@@ _@@ l . addAll ( i , ( ( SV@@ DB@@ Pre@@ Proc@@ Con@@ d ) it@@ _@@ t ) . get@@ Items ( ) ) ; } } } i -- ; } } else if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Inclu@@ de ) { SV@@ DB@@ Inclu@@ de in@@ c = ( SV@@ DB@@ Inclu@@ de ) it ; debug ( "" + in@@ c . getName ( ) ) ; if ( file@@ _@@ l == null ) { debug ( "" ) ; } if ( file@@ _@@ l != null ) { SV@@ DB@@ File@@ Tree inc@@ _@@ file = find@@ Inclu@@ ded@@ File ( file , in@@ c . getName ( ) , file@@ _@@ l ) ; if ( inc@@ _@@ file == null && f@@ Index != null ) { SV@@ DB@@ File f = new SV@@ DB@@ Inclu@@ de@@ Search ( f@@ Index ) . find@@ Inclu@@ ded@@ File ( in@@ c . getName ( ) ) ; if ( f != null ) { inc@@ _@@ file = new SV@@ DB@@ File@@ Tree ( ( SV@@ DB@@ File ) f . d@@ uplic@@ ate ( ) ) ; } } if ( inc@@ _@@ file == null ) { System . out . println ( "" + in@@ c . getName ( ) + "\"" ) ; try { throw new Exception ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( ! file . getIn@@ clu@@ ded@@ Files ( ) . contains ( inc@@ _@@ file . getFile@@ Path ( ) ) ) { debug ( "" + in@@ c . getName ( ) + "\"" ) ; file . add@@ Inclu@@ ded@@ File ( inc@@ _@@ file . getFile@@ Path ( ) ) ; if ( ! inc@@ _@@ file . getFile@@ Process@@ ed ( ) ) { process@@ File ( d@@ p , inc@@ _@@ file , file@@ _@@ l ) ; } } else { debug ( " file \"" + inc@@ _@@ file . getFile@@ Path ( ) + "" ) ; } } } else if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Package@@ Decl ) { process@@ Scope ( ( SV@@ DB@@ Scope@@ Item ) it , d@@ p , file , file@@ _@@ l ) ; } } } private SV@@ DB@@ File@@ Tree find@@ Inclu@@ ded@@ File ( SV@@ DB@@ File@@ Tree file@@ _@@ t , String name , List < SV@@ DB@@ File@@ Tree > file@@ _@@ l ) { SV@@ DB@@ File@@ Tree inc@@ _@@ file = null ; boolean multi@@ _@@ in@@ c = false ; for ( SV@@ DB@@ File@@ Tree f : file@@ _@@ l ) { if ( f . getFile@@ Path ( ) . endsWith ( name ) ) { if ( inc@@ _@@ file != null ) { System . out . println ( "" + "@@ inclu@@ de \"" + name + "\"" ) ; inc@@ _@@ file = find@@ Best@@ In@@ c@@ Parent ( file@@ _@@ t , inc@@ _@@ file , f ) ; multi@@ _@@ in@@ c = true ; } else { inc@@ _@@ file = f ; } } } if ( multi@@ _@@ in@@ c ) { System . out . println ( "" + name + "\" in \"" + file@@ _@@ t . getFile@@ Path ( ) + "\" w@@ ith \"" + inc@@ _@@ file . getFile@@ Path ( ) + "\"" ) ; } return inc@@ _@@ file ; } private void debug ( String msg ) { if ( f@@ Debug@@ E@@ n ) { System . out . println ( msg ) ; } } } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . io . File ; import java . util . List ; import java . util . Set ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Marker ; import net . sf . sv@@ editor . core . db . index . SV@@ DB@@ File@@ Tree ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public interface IS@@ V@@ DB@@ Index@@ Cache { long num@@ Files@@ Read ( ) ; void remove@@ Storage@@ Path ( List < File > db@@ _@@ path@@ _@@ list ) ; void set@@ Index@@ Data ( Object data ) ; Object getIndex@@ Data ( ) ; boolean init ( I@@ ProgressMonitor monitor , Object index@@ _data ) ; void init@@ Load ( I@@ ProgressMonitor monitor ) ; void clear ( I@@ ProgressMonitor monitor ) ; Set < String > getFile@@ List ( ) ; long getLast@@ Modified ( String path ) ; void setLast@@ Modified ( String path , long timestamp ) ; void add@@ File ( String path ) ; List < SV@@ DB@@ Marker > getM@@ ar@@ k@@ ers ( String path ) ; void set@@ Mark@@ ers ( String path , List < SV@@ DB@@ Marker > mark@@ ers ) ; SV@@ DB@@ File getPre@@ Proc@@ File ( I@@ ProgressMonitor monitor , String path ) ; void set@@ Pre@@ Proc@@ File ( String path , SV@@ DB@@ File file ) ; SV@@ DB@@ File@@ Tree getFile@@ Tree ( I@@ ProgressMonitor monitor , String path ) ; void set@@ File@@ Tree ( String path , SV@@ DB@@ File@@ Tree file ) ; SV@@ DB@@ File getFile ( I@@ ProgressMonitor monitor , String path ) ; void set@@ File ( String path , SV@@ DB@@ File file ) ; void remove@@ File ( String path ) ; void sync ( ) ; } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . io . BufferedInputStream ; import java . io . Buffered@@ OutputStream ; import java . io . Data@@ Input ; import java . io . DataInputStream ; import java . io . Data@@ Output ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . RandomAccess@@ File ; import java . util . List ; import java . util . Random ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; import org . eclipse . core . runtime . Sub@@ ProgressMonitor ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . job@@ _@@ m@@ gr . I@@ Job ; import net . sf . sv@@ editor . core . job@@ _@@ m@@ gr . I@@ Job@@ Mgr ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Handle ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level@@ Listener ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; public class SV@@ DB@@ Dir@@ F@@ S implements IS@@ V@@ DB@@ F@@ S , I@@ Log@@ Level@@ Listener { private File f@@ DB@@ Dir ; private boolean f@@ Async@@ Cle@@ ar = false ; private boolean f@@ Debug@@ E@@ n ; private Log@@ Handle f@@ Log ; public SV@@ DB@@ Dir@@ F@@ S ( File root ) { f@@ DB@@ Dir = root ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "S@@ V@@ DB@@ Dir@@ F@@ S" ) ; f@@ Log . add@@ Log@@ Level@@ Listener ( this ) ; f@@ Debug@@ E@@ n = f@@ Log . isEnabled ( ) ; } public void set@@ Enable@@ Async@@ Cle@@ ar ( boolean en ) { f@@ Async@@ Cle@@ ar = en ; } public void log@@ Level@@ Changed ( I@@ Log@@ Handle handle ) { f@@ Debug@@ E@@ n = handle . isEnabled ( ) ; } public String getRoot ( ) { return f@@ DB@@ Dir . getAbsolutePath ( ) ; } public void remove@@ Storage@@ Path ( List < File > db@@ _@@ file@@ _@@ list ) { db@@ _@@ file@@ _@@ list . remove ( f@@ DB@@ Dir ) ; } public InputStream open@@ File@@ Read ( String path ) { InputStream ret = null ; try { ret = new FileInputStream ( new File ( f@@ DB@@ Dir , path ) ) ; } catch ( IOException e ) { } return ret ; } public RandomAccess@@ File open@@ Channel@@ Read ( String path ) { RandomAccess@@ File ret = null ; File target = new File ( f@@ DB@@ Dir , path ) ; try { ret = new RandomAccess@@ File ( target , "r@@ " ) ; } catch ( IOException e ) { } return ret ; } public Data@@ Input open@@ Data@@ Input ( String path ) { InputStream in = open@@ File@@ Read ( path ) ; if ( in != null ) { BufferedInputStream b@@ in = new BufferedInputStream ( in , 1024 * 8 ) ; DataInputStream d@@ in = new DataInputStream ( b@@ in ) ; return d@@ in ; } else { return null ; } } public void close@@ Input ( Data@@ Input in ) { try { if ( in instanceof DataInputStream ) { ( ( DataInputStream ) in ) . close ( ) ; } } catch ( IOException e ) { } } public void close@@ Channel ( RandomAccess@@ File ch ) { try { ch . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public OutputStream open@@ File@@ Write ( String path ) { OutputStream ret = null ; if ( ! f@@ DB@@ Dir . exists ( ) ) { f@@ DB@@ Dir . mk@@ dirs ( ) ; } try { ret = new FileOutputStream ( new File ( f@@ DB@@ Dir , path ) ) ; } catch ( IOException e ) { } return ret ; } public RandomAccess@@ File open@@ Channel@@ Write ( String path ) { RandomAccess@@ File ret = null ; File target = new File ( f@@ DB@@ Dir , path ) ; File target@@ _@@ p = target . getParent@@ File ( ) ; if ( ! target@@ _@@ p . exists ( ) ) { target@@ _@@ p . mk@@ dirs ( ) ; } try { ret = new RandomAccess@@ File ( new File ( f@@ DB@@ Dir , path ) , "r@@ w@@ " ) ; ret . set@@ Length ( 0 ) ; } catch ( IOException e ) { } return ret ; } public Data@@ Output open@@ Data@@ Output ( String path ) { OutputStream out = open@@ File@@ Write ( path ) ; if ( out != null ) { Buffered@@ OutputStream bo@@ s = new Buffered@@ OutputStream ( out , 1024 * 8 ) ; DataOutputStream do@@ s = new DataOutputStream ( bo@@ s ) ; return do@@ s ; } else { return null ; } } public void close@@ Output ( Data@@ Output out ) { try { if ( out instanceof DataOutputStream ) { ( ( DataOutputStream ) out ) . close ( ) ; } } catch ( IOException e ) { } } public void close ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { } } public boolean file@@ Exists ( String path ) { File file = new File ( f@@ DB@@ Dir , path ) ; if ( file . exists ( ) ) { return true ; } else { return false ; } } public long lastModified ( String path ) { File file = new File ( f@@ DB@@ Dir , path ) ; return file . lastModified ( ) ; } public void delete ( I@@ ProgressMonitor monitor , String path ) { if ( path . equals ( "" ) ) { if ( f@@ DB@@ Dir . exists ( ) ) { if ( f@@ Async@@ Cle@@ ar ) { async@@ _@@ clear ( f@@ DB@@ Dir ) ; } else { delete@@ _@@ tree ( monitor , f@@ DB@@ Dir ) ; } } } else { File file = new File ( f@@ DB@@ Dir , path ) ; debug ( "@@ Delete \"" + file . getAbsolutePath ( ) + "\"" ) ; if ( file . isDirectory ( ) ) { delete@@ _@@ tree ( new Sub@@ ProgressMonitor ( monitor , 1 ) , file ) ; } else if ( file . is@@ File ( ) ) { file . delete ( ) ; } } } public void mk@@ dirs ( String path ) { File file = new File ( f@@ DB@@ Dir , path ) ; if ( ! file . isDirectory ( ) ) { file . mk@@ dirs ( ) ; } } private void async@@ _@@ clear ( File root ) { Random r = new Random ( System . currentTimeMillis ( ) ) ; final File new@@ name = new File ( root . getParent@@ File ( ) , root . getName ( ) + "_" + Math . abs ( r . nextInt ( ) ) ) ; if ( ! root . ren@@ ame@@ To ( new@@ name ) ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" ) ; delete@@ _@@ tree ( null , root ) ; return ; } if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + new@@ name . getAbsolutePath ( ) ) ; } I@@ Job@@ Mgr job@@ _@@ m@@ gr = SV@@ Core@@ Plugin . getJob@@ Mgr ( ) ; I@@ Job job = job@@ _@@ m@@ gr . create@@ Job ( ) ; job . set@@ Priority ( 10 ) ; job . init ( "@@ Remove Cache@@ " , new Runnable ( ) { public void run ( ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" ) ; } delete@@ _@@ tree ( null , new@@ name ) ; } } ) ; job@@ _@@ m@@ gr . queue@@ Job ( job ) ; } private void delete@@ _@@ tree ( I@@ ProgressMonitor monitor , File p ) { if ( p . is@@ File ( ) ) { p . delete ( ) ; } else { if ( p . exists ( ) ) { File file@@ _@@ l [ ] = p . list@@ Files ( ) ; if ( file@@ _@@ l != null ) { if ( monitor != null ) { monitor . begin@@ Task ( "@@ Delete Cache@@ " , 1 ) ; } for ( File f : file@@ _@@ l ) { if ( f . getName ( ) . equals ( ".@@ ." ) || f . getName ( ) . equals ( "." ) ) { debug ( "[@@ ERR@@ OR@@ ] " + f . getName ( ) ) ; continue ; } if ( f . isDirectory ( ) ) { delete@@ _@@ tree ( null , f ) ; } } if ( monitor != null ) { monitor . done ( ) ; } } file@@ _@@ l = p . list@@ Files ( ) ; if ( file@@ _@@ l != null ) { for ( File f : file@@ _@@ l ) { if ( f . getName ( ) . equals ( ".@@ ." ) || f . getName ( ) . equals ( "." ) ) { debug ( "[@@ ERR@@ OR@@ ] " + f . getName ( ) ) ; continue ; } if ( f . is@@ File ( ) ) { f . delete ( ) ; } } } p . delete ( ) ; } } } public void sync ( ) throws IOException { } private void debug ( String msg ) { } } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . util . List ; public interface IS@@ V@@ DB@@ Index@@ Cache@@ Factory { IS@@ V@@ DB@@ Index@@ Cache create@@ Index@@ Cache ( String project@@ _name , String base@@ _@@ location ) ; void comp@@ act@@ Cache ( List < IS@@ V@@ DB@@ Index@@ Cache > cache@@ _@@ list ) ; } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . RandomAccess@@ File ; public class Buffered@@ RandomAccess@@ FileWriter extends RandomAccess@@ File { public Buffered@@ RandomAccess@@ FileWriter ( File path ) throws FileNotFoundException { super ( path , "r@@ w@@ " ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . io . File ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Marker ; import net . sf . sv@@ editor . core . db . index . SV@@ DB@@ File@@ Tree ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public class In@@ Memory@@ Index@@ Cache implements IS@@ V@@ DB@@ Index@@ Cache { private Object f@@ Data ; private Set < String > f@@ File@@ List ; private Map < String , Long > f@@ Last@@ Modified@@ Map ; private Map < String , SV@@ DB@@ File > f@@ Pre@@ Proc@@ File@@ Map ; private Map < String , SV@@ DB@@ File > f@@ File@@ Map ; private Map < String , SV@@ DB@@ File@@ Tree > f@@ File@@ TreeMap ; private Map < String , List < SV@@ DB@@ Marker > > f@@ Mar@@ ker@@ Map ; public In@@ Memory@@ Index@@ Cache ( ) { f@@ File@@ List = new HashSet < String > ( ) ; f@@ Last@@ Modified@@ Map = new HashMap < String , Long > ( ) ; f@@ Pre@@ Proc@@ File@@ Map = new HashMap < String , SV@@ DB@@ File > ( ) ; f@@ File@@ Map = new HashMap < String , SV@@ DB@@ File > ( ) ; f@@ File@@ TreeMap = new HashMap < String , SV@@ DB@@ File@@ Tree > ( ) ; f@@ Mar@@ ker@@ Map = new HashMap < String , List < SV@@ DB@@ Marker > > ( ) ; } public long num@@ Files@@ Read ( ) { return 0 ; } public void remove@@ Storage@@ Path ( List < File > db@@ _@@ path@@ _@@ list ) { } public void set@@ Index@@ Data ( Object data ) { f@@ Data = data ; } public Object getIndex@@ Data ( ) { return f@@ Data ; } public boolean init ( I@@ ProgressMonitor monitor , Object index@@ _data ) { f@@ Data = index@@ _data ; return true ; } public void init@@ Load ( I@@ ProgressMonitor monitor ) { } public void clear ( I@@ ProgressMonitor monitor ) { monitor . begin@@ Task ( "C@@ le@@ ar Cache@@ " , 1 ) ; f@@ File@@ List . clear ( ) ; f@@ File@@ Map . clear ( ) ; f@@ File@@ TreeMap . clear ( ) ; f@@ Last@@ Modified@@ Map . clear ( ) ; f@@ Pre@@ Proc@@ File@@ Map . clear ( ) ; f@@ Mar@@ ker@@ Map . clear ( ) ; monitor . done ( ) ; } public Set < String > getFile@@ List ( ) { return f@@ File@@ List ; } public List < SV@@ DB@@ Marker > getM@@ ar@@ k@@ ers ( String path ) { return f@@ Mar@@ ker@@ Map . get ( path ) ; } public void set@@ Mark@@ ers ( String path , List < SV@@ DB@@ Marker > mark@@ ers ) { if ( f@@ Mar@@ ker@@ Map . containsKey ( path ) ) { f@@ Mar@@ ker@@ Map . remove ( path ) ; } f@@ Mar@@ ker@@ Map . put ( path , mark@@ ers ) ; } public long getLast@@ Modified ( String path ) { if ( f@@ Last@@ Modified@@ Map . containsKey ( path ) ) { return f@@ Last@@ Modified@@ Map . get ( path ) ; } else { return - 1 ; } } public void setLast@@ Modified ( String path , long timestamp ) { if ( f@@ Last@@ Modified@@ Map . containsKey ( path ) ) { f@@ Last@@ Modified@@ Map . remove ( path ) ; } f@@ Last@@ Modified@@ Map . put ( path , timestamp ) ; } public void add@@ File ( String path ) { if ( ! f@@ File@@ List . contains ( path ) ) { f@@ File@@ List . add ( path ) ; } } public SV@@ DB@@ File getPre@@ Proc@@ File ( I@@ ProgressMonitor monitor , String path ) { return f@@ Pre@@ Proc@@ File@@ Map . get ( path ) ; } public void set@@ Pre@@ Proc@@ File ( String path , SV@@ DB@@ File file ) { if ( f@@ Pre@@ Proc@@ File@@ Map . containsKey ( path ) ) { f@@ Pre@@ Proc@@ File@@ Map . remove ( path ) ; } f@@ Pre@@ Proc@@ File@@ Map . put ( path , file ) ; } public SV@@ DB@@ File@@ Tree getFile@@ Tree ( I@@ ProgressMonitor monitor , String path ) { return f@@ File@@ TreeMap . get ( path ) ; } public void set@@ File@@ Tree ( String path , SV@@ DB@@ File@@ Tree file ) { if ( f@@ File@@ TreeMap . containsKey ( path ) ) { f@@ File@@ TreeMap . remove ( path ) ; } f@@ File@@ TreeMap . put ( path , file ) ; } public SV@@ DB@@ File getFile ( I@@ ProgressMonitor monitor , String path ) { return f@@ File@@ Map . get ( path ) ; } public void set@@ File ( String path , SV@@ DB@@ File file ) { if ( f@@ File@@ Map . containsKey ( path ) ) { f@@ File@@ Map . remove ( path ) ; } f@@ File@@ Map . put ( path , file ) ; } public void remove@@ File ( String path ) { f@@ File@@ List . remove ( path ) ; f@@ Pre@@ Proc@@ File@@ Map . remove ( path ) ; f@@ File@@ Map . remove ( path ) ; f@@ File@@ TreeMap . remove ( path ) ; } public void sync ( ) { } } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . io . Data@@ Input ; import java . io . Data@@ Output ; import java . io . IOException ; public class SV@@ DB@@ File@@ F@@ S@@ Root@@ Block { private long f@@ Block@@ Size ; private long f@@ Di@@ rent@@ Pt@@ r ; private long f@@ Bitmap@@ Pt@@ r ; public SV@@ DB@@ File@@ F@@ S@@ Root@@ Block ( Data@@ Input in ) throws IOException { f@@ Block@@ Size = in . read@@ Long ( ) ; f@@ Di@@ rent@@ Pt@@ r = in . read@@ Long ( ) ; f@@ Bitmap@@ Pt@@ r = in . read@@ Long ( ) ; } public void sync ( Data@@ Output out ) throws IOException { out . write@@ Long ( f@@ Block@@ Size ) ; out . write@@ Long ( f@@ Di@@ rent@@ Pt@@ r ) ; out . write@@ Long ( f@@ Bitmap@@ Pt@@ r ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . io . Data@@ Input ; import java . io . Data@@ Output ; import java . io . File ; import java . lang . ref . Reference ; import java . lang . ref . So@@ ft@@ Reference ; import java . lang . ref . W@@ eak@@ Reference ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . SV@@ FileUtils ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Marker ; import net . sf . sv@@ editor . core . db . index . SV@@ DB@@ Base@@ Index@@ Cache@@ Data ; import net . sf . sv@@ editor . core . db . index . SV@@ DB@@ File@@ Tree ; import net . sf . sv@@ editor . core . db . persistence . DB@@ FormatException ; import net . sf . sv@@ editor . core . db . persistence . DB@@ Write@@ Exception ; import net . sf . sv@@ editor . core . db . persistence . ID@@ B@@ Reader ; import net . sf . sv@@ editor . core . db . persistence . ID@@ B@@ Writer ; import net . sf . sv@@ editor . core . db . persistence . SV@@ DB@@ Persistence@@ R@@ W ; import net . sf . sv@@ editor . core . job@@ _@@ m@@ gr . I@@ Job ; import net . sf . sv@@ editor . core . job@@ _@@ m@@ gr . I@@ Job@@ Mgr ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Handle ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level@@ Listener ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; @ SuppressWarnings ( { "raw@@ types" , "unchecked" } ) public class SV@@ DB@@ Thread@@ ed@@ File@@ Index@@ Cache implements IS@@ V@@ DB@@ Index@@ Cache , I@@ Log@@ Level@@ Listener { private String f@@ Base@@ Location ; private Map < String , Cache@@ FileInfo > f@@ File@@ Cache ; private IS@@ V@@ DB@@ F@@ S f@@ SV@@ DB@@ F@@ S ; private Object f@@ Index@@ Data ; private Log@@ Handle f@@ Log ; private List < ID@@ B@@ Reader > f@@ Persistence@@ R@@ dr@@ Set ; private List < ID@@ B@@ Writer > f@@ Persistence@@ Writer@@ Set ; private long f@@ Num@@ Files@@ Read = 0 ; private boolean f@@ Debug@@ E@@ n = false ; private List < I@@ Job > f@@ Write@@ back@@ Job@@ s ; private int f@@ Max@@ Cache@@ Size = 100 ; private static Cache@@ FileInfo f@@ Cache@@ H@@ ead ; private static Cache@@ FileInfo f@@ Cache@@ Ta@@ il ; private static int f@@ Cache@@ Size ; private boolean f@@ Use@@ So@@ ft@@ Ref = true ; final class Cache@@ FileInfo { public boolean f@@ Cach@@ ed ; public String f@@ Path ; public Cache@@ FileInfo f@@ Pre@@ v ; public Cache@@ FileInfo f@@ Next ; public Reference < SV@@ DB@@ File > f@@ SV@@ DB@@ Pre@@ Proc@@ File ; public SV@@ DB@@ File f@@ SV@@ DB@@ Pre@@ Proc@@ File@@ Ref ; public Reference < SV@@ DB@@ File@@ Tree > f@@ SV@@ DB@@ File@@ Tree ; public SV@@ DB@@ File@@ Tree f@@ SV@@ DB@@ File@@ Tree@@ Ref ; public Reference < SV@@ DB@@ File > f@@ SV@@ DB@@ File ; public SV@@ DB@@ File f@@ SV@@ DB@@ File@@ Ref ; public Reference < List < SV@@ DB@@ Marker > > f@@ Mark@@ ers ; public List < SV@@ DB@@ Marker > f@@ Mar@@ ker@@ s@@ Ref ; public long f@@ Last@@ Modified ; public Cache@@ FileInfo ( String path ) { f@@ Path = path ; f@@ SV@@ DB@@ Pre@@ Proc@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( null ) ; f@@ SV@@ DB@@ File@@ Tree = ( Reference < SV@@ DB@@ File@@ Tree > ) create@@ Ref ( null ) ; f@@ SV@@ DB@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( null ) ; f@@ Mark@@ ers = ( Reference < List < SV@@ DB@@ Marker > > ) create@@ Ref ( null ) ; f@@ Last@@ Modified = - 1 ; } } public SV@@ DB@@ Thread@@ ed@@ File@@ Index@@ Cache ( IS@@ V@@ DB@@ F@@ S fs ) { f@@ SV@@ DB@@ F@@ S = fs ; f@@ File@@ Cache = new HashMap < String , SV@@ DB@@ Thread@@ ed@@ File@@ Index@@ Cache . Cache@@ FileInfo > ( ) ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; f@@ Debug@@ E@@ n = f@@ Log . isEnabled ( ) ; f@@ Log . add@@ Log@@ Level@@ Listener ( this ) ; f@@ Persistence@@ R@@ dr@@ Set = new ArrayList < ID@@ B@@ Reader > ( ) ; f@@ Persistence@@ Writer@@ Set = new ArrayList < ID@@ B@@ Writer > ( ) ; f@@ Write@@ back@@ Job@@ s = new ArrayList < I@@ Job > ( ) ; } public void log@@ Level@@ Changed ( I@@ Log@@ Handle handle ) { f@@ Debug@@ E@@ n = handle . isEnabled ( ) ; } public long num@@ Files@@ Read ( ) { return f@@ Num@@ Files@@ Read ; } public void remove@@ Storage@@ Path ( List < File > db@@ _@@ path@@ _@@ list ) { f@@ SV@@ DB@@ F@@ S . remove@@ Storage@@ Path ( db@@ _@@ path@@ _@@ list ) ; } public void set@@ Index@@ Data ( Object data ) { f@@ Index@@ Data = data ; } public Object getIndex@@ Data ( ) { return f@@ Index@@ Data ; } public boolean isValid ( ) { return true ; } public void clear ( I@@ ProgressMonitor monitor ) { monitor . begin@@ Task ( "C@@ le@@ ar Cache@@ " , 1 ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( "@@ clear@@ " ) ; } f@@ File@@ Cache . clear ( ) ; f@@ SV@@ DB@@ F@@ S . delete ( monitor , "" ) ; monitor . done ( ) ; } public void add@@ File ( String path ) { getC@@ ache@@ FileInfo ( path , true ) ; } private Cache@@ FileInfo getC@@ ache@@ FileInfo ( String path , boolean create ) { synchronized ( f@@ File@@ Cache ) { Cache@@ FileInfo file = null ; if ( ! f@@ File@@ Cache . containsKey ( path ) ) { if ( create ) { file = new Cache@@ FileInfo ( path ) ; f@@ File@@ Cache . put ( path , file ) ; } } else { file = f@@ File@@ Cache . get ( path ) ; } if ( file != null ) { if ( file . f@@ Cach@@ ed ) { move@@ Element@@ To@@ Ta@@ il ( file ) ; } else { add@@ Element@@ To@@ Ta@@ il ( file ) ; } } return file ; } } public void set@@ Mark@@ ers ( String path , List < SV@@ DB@@ Marker > mark@@ ers ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; cf@@ i . f@@ Mark@@ ers = ( Reference < List < SV@@ DB@@ Marker > > ) create@@ Ref ( mark@@ ers ) ; cf@@ i . f@@ Mar@@ ker@@ s@@ Ref = mark@@ ers ; } public List < SV@@ DB@@ Marker > getM@@ ar@@ k@@ ers ( String path ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , false ) ; List < SV@@ DB@@ Marker > m = ( cf@@ i != null ) ? cf@@ i . f@@ Mark@@ ers . get ( ) : null ; if ( m == null ) { String parent@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; String target@@ _@@ file = parent@@ _@@ dir + "/@@ mar@@ ker@@ s" ; if ( f@@ SV@@ DB@@ F@@ S . file@@ Exists ( target@@ _@@ file ) ) { cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; m = read@@ Mar@@ ker@@ List ( target@@ _@@ file ) ; cf@@ i . f@@ Mark@@ ers = ( Reference < List < SV@@ DB@@ Marker > > ) create@@ Ref ( m ) ; cf@@ i . f@@ Mar@@ ker@@ s@@ Ref = m ; } } if ( m == null ) { m = new ArrayList < SV@@ DB@@ Marker > ( ) ; } return m ; } public boolean init ( I@@ ProgressMonitor monitor , Object index@@ _data ) { boolean valid = false ; f@@ File@@ Cache . clear ( ) ; f@@ Base@@ Location = "" ; f@@ Index@@ Data = index@@ _data ; ID@@ B@@ Reader r@@ dr = alloc@@ Reader ( ) ; try { Data@@ Input in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( "@@ index@@ " ) ; if ( in != null ) { r@@ dr . init ( in ) ; f@@ Base@@ Location = r@@ dr . readString ( ) ; List < String > file@@ _@@ list = r@@ dr . read@@ String@@ List ( ) ; List < Long > tim@@ estamp@@ _@@ list = r@@ dr . read@@ Long@@ List ( ) ; for ( int i = 0 ; i < file@@ _@@ list . size ( ) ; i ++ ) { String path = file@@ _@@ list . get ( i ) ; Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; cf@@ i . f@@ Last@@ Modified = tim@@ estamp@@ _@@ list . get ( i ) ; } f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; } in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( "@@ index@@ _@@ data@@ " ) ; if ( in != null ) { r@@ dr . init ( in ) ; r@@ dr . readObject ( null , index@@ _data . getClass ( ) , index@@ _data ) ; debug ( "@@ Cache " + f@@ SV@@ DB@@ F@@ S . getRoot ( ) + " h@@ as base " + ( ( SV@@ DB@@ Base@@ Index@@ Cache@@ Data ) index@@ _data ) . getBase@@ Location ( ) ) ; f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; valid = true ; } else { debug ( "" ) ; } } catch ( DB@@ FormatException e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Reader ( r@@ dr ) ; } return valid ; } public void init@@ Load ( I@@ ProgressMonitor monitor ) { } public Set < String > getFile@@ List ( ) { return f@@ File@@ Cache . keySet ( ) ; } public long getLast@@ Modified ( String path ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , false ) ; if ( cf@@ i != null ) { return cf@@ i . f@@ Last@@ Modified ; } else { System . out . println ( "@@ File \"" + path + "" ) ; } return - 1 ; } public void setLast@@ Modified ( String path , long timestamp ) { if ( timestamp == - 1 ) { try { throw new Exception ( ) ; } catch ( Exception e ) { System . out . println ( "" ) ; e . printStackTrace ( ) ; } } Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; cf@@ i . f@@ Last@@ Modified = timestamp ; } public SV@@ DB@@ File getPre@@ Proc@@ File ( I@@ ProgressMonitor monitor , String path ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , false ) ; SV@@ DB@@ File pp@@ _@@ file = ( cf@@ i != null ) ? cf@@ i . f@@ SV@@ DB@@ Pre@@ Proc@@ File . get ( ) : null ; if ( pp@@ _@@ file == null ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; if ( f@@ SV@@ DB@@ F@@ S . file@@ Exists ( target@@ _@@ dir + "/@@ pre@@ Proc@@ File@@ " ) ) { cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; Data@@ Input in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( target@@ _@@ dir + "/@@ pre@@ Proc@@ File@@ " ) ; pp@@ _@@ file = read@@ File ( in , path ) ; f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; cf@@ i . f@@ SV@@ DB@@ Pre@@ Proc@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( pp@@ _@@ file ) ; cf@@ i . f@@ SV@@ DB@@ Pre@@ Proc@@ File@@ Ref = pp@@ _@@ file ; } } return pp@@ _@@ file ; } public SV@@ DB@@ File getFile ( I@@ ProgressMonitor monitor , String path ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , false ) ; SV@@ DB@@ File file = ( cf@@ i != null ) ? cf@@ i . f@@ SV@@ DB@@ File . get ( ) : null ; if ( file == null ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; if ( f@@ SV@@ DB@@ F@@ S . file@@ Exists ( target@@ _@@ dir + "/@@ file@@ " ) ) { cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; Data@@ Input in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( target@@ _@@ dir + "/@@ file@@ " ) ; file = read@@ File ( in , path ) ; f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; cf@@ i . f@@ SV@@ DB@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( file ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Ref = file ; f@@ Num@@ Files@@ Read ++ ; } else { debug ( "" + target@@ _@@ dir ) ; } } return file ; } public void set@@ Pre@@ Proc@@ File ( String path , SV@@ DB@@ File file ) { if ( file == null ) { try { throw new Exception ( "" + path + "\" is null@@ " ) ; } catch ( Exception e ) { f@@ Log . error ( "" + path + "\" is null@@ " , e ) ; } } Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; cf@@ i . f@@ SV@@ DB@@ Pre@@ Proc@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( file ) ; cf@@ i . f@@ SV@@ DB@@ Pre@@ Proc@@ File@@ Ref = file ; } public void set@@ File ( String path , SV@@ DB@@ File file ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; if ( file == null ) { debug ( "@@ set@@ File \"" + path + "\" == NUL@@ L@@ " ) ; cf@@ i . f@@ SV@@ DB@@ File = new W@@ eak@@ Reference < SV@@ DB@@ File > ( null ) ; String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; f@@ SV@@ DB@@ F@@ S . delete ( null , target@@ _@@ dir + "/@@ file@@ " ) ; } else { cf@@ i . f@@ SV@@ DB@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( file ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Ref = file ; } } public void set@@ File@@ Tree ( String path , SV@@ DB@@ File@@ Tree file@@ _@@ tree ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Tree = ( Reference < SV@@ DB@@ File@@ Tree > ) create@@ Ref ( file@@ _@@ tree ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Tree@@ Ref = file@@ _@@ tree ; if ( path == null ) { System . out . println ( "@@ Null path@@ " ) ; } } public SV@@ DB@@ File@@ Tree getFile@@ Tree ( I@@ ProgressMonitor monitor , String path ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , false ) ; SV@@ DB@@ File@@ Tree ft = ( cf@@ i != null ) ? cf@@ i . f@@ SV@@ DB@@ File@@ Tree . get ( ) : null ; if ( ft == null ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; if ( f@@ SV@@ DB@@ F@@ S . file@@ Exists ( target@@ _@@ dir + "/@@ file@@ Tree@@ Map@@ " ) ) { cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; Data@@ Input in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( target@@ _@@ dir + "/@@ file@@ Tree@@ Map@@ " ) ; ft = read@@ File@@ Tree ( in ) ; f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Tree = ( Reference < SV@@ DB@@ File@@ Tree > ) create@@ Ref ( ft ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Tree@@ Ref = ft ; } else { f@@ Log . debug ( "" + path + "" ) ; } } return ft ; } public void remove@@ File ( String path ) { Cache@@ FileInfo file = f@@ File@@ Cache . get ( path ) ; f@@ File@@ Cache . remove ( path ) ; remove@@ Element ( file ) ; String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; f@@ SV@@ DB@@ F@@ S . delete ( null , target@@ _@@ dir ) ; } private String compute@@ Path@@ Dir ( String path ) { return SV@@ FileUtils . compute@@ MD@@ 5 ( path ) ; } private SV@@ DB@@ File read@@ File ( Data@@ Input in , String path ) { ID@@ B@@ Reader reader = alloc@@ Reader ( ) ; reader . init ( in ) ; SV@@ DB@@ File ret = new SV@@ DB@@ File ( ) ; try { reader . readObject ( null , ret . getClass ( ) , ret ) ; } catch ( DB@@ FormatException e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Reader ( reader ) ; } return ret ; } private SV@@ DB@@ File@@ Tree read@@ File@@ Tree ( Data@@ Input in ) { ID@@ B@@ Reader reader = alloc@@ Reader ( ) ; reader . init ( in ) ; SV@@ DB@@ File@@ Tree ret = new SV@@ DB@@ File@@ Tree ( ) ; try { reader . readObject ( null , ret . getClass ( ) , ret ) ; } catch ( DB@@ FormatException e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Reader ( reader ) ; } return ret ; } private List < SV@@ DB@@ Marker > read@@ Mar@@ ker@@ List ( String path ) { Data@@ Input in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( path ) ; ID@@ B@@ Reader reader = alloc@@ Reader ( ) ; reader . init ( in ) ; List < SV@@ DB@@ Marker > ret = null ; try { ret = ( List < SV@@ DB@@ Marker > ) reader . read@@ Item@@ List ( null ) ; } catch ( DB@@ FormatException e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Reader ( reader ) ; } f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; return ret ; } public void sync ( ) { ID@@ B@@ Writer writer = alloc@@ Writer ( ) ; while ( f@@ Cache@@ H@@ ead != null ) { remove@@ Element ( f@@ Cache@@ H@@ ead ) ; } while ( true ) { I@@ Job j = null ; synchronized ( f@@ Write@@ back@@ Job@@ s ) { if ( f@@ Write@@ back@@ Job@@ s . size ( ) > 0 ) { j = f@@ Write@@ back@@ Job@@ s . remove ( 0 ) ; } } if ( j == null ) { break ; } else { j . join ( ) ; } } try { Data@@ Output out = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Output ( "@@ index@@ " ) ; if ( out == null ) { throw new DB@@ Write@@ Exception ( "" ) ; } writer . init ( out ) ; writer . writeString ( f@@ Base@@ Location ) ; List < String > tmp = new ArrayList < String > ( ) ; tmp . addAll ( f@@ File@@ Cache . keySet ( ) ) ; writer . write@@ String@@ List ( tmp ) ; List < Long > tim@@ estamp@@ _@@ list = new ArrayList < Long > ( ) ; for ( String path : f@@ File@@ Cache . keySet ( ) ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; tim@@ estamp@@ _@@ list . add ( cf@@ i . f@@ Last@@ Modified ) ; } writer . write@@ Long@@ List ( tim@@ estamp@@ _@@ list ) ; writer . close ( ) ; f@@ SV@@ DB@@ F@@ S . close@@ Output ( out ) ; out = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Output ( "@@ index@@ _@@ data@@ " ) ; writer . init ( out ) ; writer . writeObject ( f@@ Index@@ Data . getClass ( ) , f@@ Index@@ Data ) ; writer . close ( ) ; f@@ SV@@ DB@@ F@@ S . close@@ Output ( out ) ; } catch ( DB@@ Write@@ Exception e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Writer ( writer ) ; } } private ID@@ B@@ Reader alloc@@ Reader ( ) { ID@@ B@@ Reader reader = null ; synchronized ( f@@ Persistence@@ R@@ dr@@ Set ) { if ( f@@ Persistence@@ R@@ dr@@ Set . size ( ) > 0 ) { reader = f@@ Persistence@@ R@@ dr@@ Set . remove ( f@@ Persistence@@ R@@ dr@@ Set . size ( ) - 1 ) ; } } if ( reader == null ) { reader = new SV@@ DB@@ Persistence@@ R@@ W ( ) ; } return reader ; } private void f@@ ree@@ Reader ( ID@@ B@@ Reader reader ) { synchronized ( f@@ Persistence@@ R@@ dr@@ Set ) { f@@ Persistence@@ R@@ dr@@ Set . add ( reader ) ; } } private ID@@ B@@ Writer alloc@@ Writer ( ) { ID@@ B@@ Writer writer = null ; synchronized ( f@@ Persistence@@ Writer@@ Set ) { if ( f@@ Persistence@@ Writer@@ Set . size ( ) > 0 ) { writer = f@@ Persistence@@ Writer@@ Set . remove ( f@@ Persistence@@ Writer@@ Set . size ( ) - 1 ) ; } } if ( writer == null ) { writer = new SV@@ DB@@ Persistence@@ R@@ W ( ) ; } return writer ; } private void f@@ ree@@ Writer ( ID@@ B@@ Writer writer ) { synchronized ( f@@ Persistence@@ Writer@@ Set ) { f@@ Persistence@@ Writer@@ Set . add ( writer ) ; } } private void write@@ Back@@ Pre@@ Proc@@ File ( Cache@@ FileInfo info , String path , SV@@ DB@@ File file ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; String file@@ _@@ path = target@@ _@@ dir + "/@@ pre@@ Proc@@ File@@ " ; I@@ Job@@ Mgr job@@ _@@ m@@ gr = SV@@ Core@@ Plugin . getJob@@ Mgr ( ) ; I@@ Job job = job@@ _@@ m@@ gr . create@@ Job ( ) ; job . init ( "" , new Write@@ Back@@ File@@ Runnable ( job , info , target@@ _@@ dir , file@@ _@@ path , file ) ) ; job . set@@ Priority ( 1 ) ; synchronized ( f@@ Write@@ back@@ Job@@ s ) { f@@ Write@@ back@@ Job@@ s . add ( job ) ; } job@@ _@@ m@@ gr . queue@@ Job ( job ) ; } private void write@@ Back@@ File ( Cache@@ FileInfo info , String path , SV@@ DB@@ File file ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; String file@@ _@@ path = target@@ _@@ dir + "/@@ file@@ " ; I@@ Job@@ Mgr job@@ _@@ m@@ gr = SV@@ Core@@ Plugin . getJob@@ Mgr ( ) ; I@@ Job job = job@@ _@@ m@@ gr . create@@ Job ( ) ; job . init ( "" , new Write@@ Back@@ File@@ Runnable ( job , info , target@@ _@@ dir , file@@ _@@ path , file ) ) ; job . set@@ Priority ( 1 ) ; synchronized ( f@@ Write@@ back@@ Job@@ s ) { f@@ Write@@ back@@ Job@@ s . add ( job ) ; } job@@ _@@ m@@ gr . queue@@ Job ( job ) ; } private void write@@ Back@@ File@@ Tree ( Cache@@ FileInfo info , String path , SV@@ DB@@ File@@ Tree file@@ _@@ tree ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; String file@@ _@@ path = target@@ _@@ dir + "/@@ file@@ Tree@@ Map@@ " ; I@@ Job@@ Mgr job@@ _@@ m@@ gr = SV@@ Core@@ Plugin . getJob@@ Mgr ( ) ; I@@ Job job = job@@ _@@ m@@ gr . create@@ Job ( ) ; job . init ( "" , new Write@@ Back@@ File@@ Tree@@ Runnable ( job , info , target@@ _@@ dir , file@@ _@@ path , file@@ _@@ tree ) ) ; job . set@@ Priority ( 1 ) ; synchronized ( f@@ Write@@ back@@ Job@@ s ) { f@@ Write@@ back@@ Job@@ s . add ( job ) ; } job@@ _@@ m@@ gr . queue@@ Job ( job ) ; } private void write@@ Back@@ Mar@@ ker@@ List ( Cache@@ FileInfo info , String path , List < SV@@ DB@@ Marker > mark@@ ers ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; String file@@ _@@ path = target@@ _@@ dir + "/@@ mar@@ ker@@ s" ; I@@ Job@@ Mgr job@@ _@@ m@@ gr = SV@@ Core@@ Plugin . getJob@@ Mgr ( ) ; I@@ Job job = job@@ _@@ m@@ gr . create@@ Job ( ) ; job . init ( "" , new Write@@ Back@@ Mar@@ ker@@ List@@ Runnable ( job , info , target@@ _@@ dir , file@@ _@@ path , mark@@ ers ) ) ; job . set@@ Priority ( 1 ) ; synchronized ( f@@ Write@@ back@@ Job@@ s ) { f@@ Write@@ back@@ Job@@ s . add ( job ) ; } job@@ _@@ m@@ gr . queue@@ Job ( job ) ; } private class Write@@ Back@@ File@@ Runnable implements Runnable { private I@@ Job f@@ Job ; private Cache@@ FileInfo f@@ Info ; private String f@@ Target@@ Dir ; private String f@@ FilePath ; private SV@@ DB@@ File f@@ File ; public Write@@ Back@@ File@@ Runnable ( I@@ Job job , Cache@@ FileInfo info , String target@@ _@@ dir , String file@@ _@@ path , SV@@ DB@@ File file ) { f@@ Job = job ; f@@ Info = info ; f@@ Target@@ Dir = target@@ _@@ dir ; f@@ FilePath = file@@ _@@ path ; f@@ File = file ; } public void run ( ) { ID@@ B@@ Writer writer = alloc@@ Writer ( ) ; f@@ SV@@ DB@@ F@@ S . mk@@ dirs ( f@@ Target@@ Dir ) ; try { Data@@ Output out = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Output ( f@@ FilePath ) ; writer . init ( out ) ; writer . writeObject ( f@@ File . getClass ( ) , f@@ File ) ; writer . close ( ) ; f@@ SV@@ DB@@ F@@ S . close@@ Output ( out ) ; } catch ( DB@@ Write@@ Exception e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Writer ( writer ) ; f@@ Info . f@@ SV@@ DB@@ File@@ Ref = null ; synchronized ( f@@ Write@@ back@@ Job@@ s ) { f@@ Write@@ back@@ Job@@ s . remove ( f@@ Job ) ; } } } } private class Write@@ Back@@ File@@ Tree@@ Runnable implements Runnable { private I@@ Job f@@ Job ; private Cache@@ FileInfo f@@ Info ; private String f@@ Target@@ Dir ; private String f@@ FilePath ; private SV@@ DB@@ File@@ Tree f@@ File@@ Tree ; public Write@@ Back@@ File@@ Tree@@ Runnable ( I@@ Job job , Cache@@ FileInfo info , String target@@ _@@ dir , String file@@ _@@ path , SV@@ DB@@ File@@ Tree ft ) { f@@ Job = job ; f@@ Info = info ; f@@ Target@@ Dir = target@@ _@@ dir ; f@@ FilePath = file@@ _@@ path ; f@@ File@@ Tree = ft ; } public void run ( ) { f@@ SV@@ DB@@ F@@ S . mk@@ dirs ( f@@ Target@@ Dir ) ; ID@@ B@@ Writer writer = alloc@@ Writer ( ) ; try { Data@@ Output out = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Output ( f@@ FilePath ) ; writer . init ( out ) ; synchronized ( f@@ File@@ Tree ) { writer . writeObject ( f@@ File@@ Tree . getClass ( ) , f@@ File@@ Tree ) ; } writer . close ( ) ; f@@ SV@@ DB@@ F@@ S . close@@ Output ( out ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Writer ( writer ) ; f@@ Info . f@@ SV@@ DB@@ File@@ Tree@@ Ref = null ; synchronized ( f@@ Write@@ back@@ Job@@ s ) { f@@ Write@@ back@@ Job@@ s . remove ( f@@ Job ) ; } } } } private class Write@@ Back@@ Mar@@ ker@@ List@@ Runnable implements Runnable { private I@@ Job f@@ Job ; private Cache@@ FileInfo f@@ Info ; private String f@@ Target@@ Dir ; private String f@@ FilePath ; private List < SV@@ DB@@ Marker > f@@ Mark@@ ers ; public Write@@ Back@@ Mar@@ ker@@ List@@ Runnable ( I@@ Job job , Cache@@ FileInfo info , String target@@ _@@ dir , String file@@ _@@ path , List < SV@@ DB@@ Marker > mark@@ ers ) { f@@ Job = job ; f@@ Info = info ; f@@ Target@@ Dir = target@@ _@@ dir ; f@@ FilePath = file@@ _@@ path ; f@@ Mark@@ ers = mark@@ ers ; } public void run ( ) { f@@ SV@@ DB@@ F@@ S . mk@@ dirs ( f@@ Target@@ Dir ) ; ID@@ B@@ Writer writer = alloc@@ Writer ( ) ; try { Data@@ Output out = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Output ( f@@ FilePath ) ; writer . init ( out ) ; writer . write@@ Item@@ List ( f@@ Mark@@ ers ) ; writer . close ( ) ; f@@ SV@@ DB@@ F@@ S . close@@ Output ( out ) ; } catch ( DB@@ Write@@ Exception e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Writer ( writer ) ; f@@ Info . f@@ Mar@@ ker@@ s@@ Ref = null ; synchronized ( f@@ Write@@ back@@ Job@@ s ) { f@@ Write@@ back@@ Job@@ s . remove ( f@@ Job ) ; } } } } private Reference create@@ Ref ( Object obj ) { if ( f@@ Use@@ So@@ ft@@ Ref ) { return new So@@ ft@@ Reference ( obj ) ; } else { return new W@@ eak@@ Reference ( obj ) ; } } private void debug ( String msg ) { } private void add@@ Element@@ To@@ Ta@@ il ( Cache@@ FileInfo info ) { synchronized ( SV@@ DB@@ Thread@@ ed@@ File@@ Index@@ Cache . class ) { info . f@@ Cach@@ ed = true ; info . f@@ SV@@ DB@@ File@@ Ref = info . f@@ SV@@ DB@@ File . get ( ) ; info . f@@ SV@@ DB@@ File@@ Tree@@ Ref = info . f@@ SV@@ DB@@ File@@ Tree . get ( ) ; info . f@@ SV@@ DB@@ Pre@@ Proc@@ File@@ Ref = info . f@@ SV@@ DB@@ Pre@@ Proc@@ File . get ( ) ; if ( f@@ Cache@@ H@@ ead == null ) { f@@ Cache@@ H@@ ead = info ; f@@ Cache@@ Ta@@ il = info ; info . f@@ Pre@@ v = null ; info . f@@ Next = null ; } else { f@@ Cache@@ Ta@@ il . f@@ Next = info ; info . f@@ Pre@@ v = f@@ Cache@@ Ta@@ il ; f@@ Cache@@ Ta@@ il = info ; info . f@@ Next = null ; } f@@ Cache@@ Size ++ ; while ( f@@ Cache@@ Size > f@@ Max@@ Cache@@ Size ) { remove@@ Element ( f@@ Cache@@ H@@ ead ) ; } } } private void move@@ Element@@ To@@ Ta@@ il ( Cache@@ FileInfo info ) { synchronized ( SV@@ DB@@ Thread@@ ed@@ File@@ Index@@ Cache . class ) { if ( f@@ Cache@@ Ta@@ il != info ) { if ( info . f@@ Pre@@ v == null ) { f@@ Cache@@ H@@ ead = info . f@@ Next ; } else { info . f@@ Pre@@ v . f@@ Next = info . f@@ Next ; } if ( info . f@@ Next == null ) { f@@ Cache@@ Ta@@ il = info . f@@ Pre@@ v ; } else { info . f@@ Next . f@@ Pre@@ v = info . f@@ Pre@@ v ; } if ( f@@ Cache@@ H@@ ead == null ) { f@@ Cache@@ H@@ ead = info ; f@@ Cache@@ Ta@@ il = info ; info . f@@ Pre@@ v = null ; info . f@@ Next = null ; } else { f@@ Cache@@ Ta@@ il . f@@ Next = info ; info . f@@ Pre@@ v = f@@ Cache@@ Ta@@ il ; f@@ Cache@@ Ta@@ il = info ; info . f@@ Next = null ; } } } } private void remove@@ Element ( Cache@@ FileInfo info ) { synchronized ( SV@@ DB@@ Thread@@ ed@@ File@@ Index@@ Cache . class ) { if ( info . f@@ Pre@@ v == null ) { f@@ Cache@@ H@@ ead = info . f@@ Next ; } else { info . f@@ Pre@@ v . f@@ Next = info . f@@ Next ; } if ( info . f@@ Next == null ) { f@@ Cache@@ Ta@@ il = info . f@@ Pre@@ v ; } else { info . f@@ Next . f@@ Pre@@ v = info . f@@ Pre@@ v ; } if ( info . f@@ SV@@ DB@@ File@@ Ref != null ) { write@@ Back@@ File ( info , info . f@@ Path , info . f@@ SV@@ DB@@ File@@ Ref ) ; } if ( info . f@@ SV@@ DB@@ File@@ Tree@@ Ref != null ) { write@@ Back@@ File@@ Tree ( info , info . f@@ Path , info . f@@ SV@@ DB@@ File@@ Tree@@ Ref ) ; } if ( info . f@@ SV@@ DB@@ Pre@@ Proc@@ File@@ Ref != null ) { write@@ Back@@ Pre@@ Proc@@ File ( info , info . f@@ Path , info . f@@ SV@@ DB@@ Pre@@ Proc@@ File@@ Ref ) ; } if ( info . f@@ Mark@@ ers != null ) { write@@ Back@@ Mar@@ ker@@ List ( info , info . f@@ Path , info . f@@ Mar@@ ker@@ s@@ Ref ) ; } info . f@@ Cach@@ ed = false ; f@@ Cache@@ Size -- ; } } } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccess@@ File ; import java . nio . ByteBuffer ; import java . nio . channels . File@@ Channel ; import java . nio . channels . File@@ Channel . Map@@ Mode ; public class Mapp@@ ed@@ Byte@@ Buffer@@ InputStream extends InputStream { private RandomAccess@@ File f@@ In ; private ByteBuffer f@@ ByteBuffer ; private int f@@ Buffer@@ Idx ; private byte f@@ T@@ mp [ ] = new byte [ 1 ] ; public Mapp@@ ed@@ Byte@@ Buffer@@ InputStream ( File path ) throws IOException { f@@ In = new RandomAccess@@ File ( path , "r@@ " ) ; File@@ Channel channel = f@@ In . get@@ Channel ( ) ; f@@ ByteBuffer = channel . map ( Map@@ Mode . READ_@@ ONLY , 0 , channel . size ( ) ) ; f@@ Buffer@@ Idx = 0 ; } @ Override public int available ( ) throws IOException { return ( f@@ ByteBuffer . limit ( ) - f@@ Buffer@@ Idx ) ; } @ Override public void close ( ) throws IOException { f@@ In . close ( ) ; } @ Override public boolean mark@@ Supported ( ) { return false ; } @ Override public int read ( ) throws IOException { int ret = read ( f@@ T@@ mp , 0 , 1 ) ; if ( ret <= 0 ) { return - 1 ; } else { return f@@ T@@ mp [ 0 ] ; } } @ Override public int read ( byte [ ] b , int off , int len ) throws IOException { int ret = - 1 ; if ( f@@ ByteBuffer . remaining ( ) > 0 ) { ret = ( f@@ ByteBuffer . remaining ( ) >= len ) ? len : f@@ ByteBuffer . remaining ( ) ; f@@ ByteBuffer . get ( b , off , ret ) ; System . out . println ( "@@ Read " + ret + " bytes@@ " ) ; } return ret ; } @ Override public int read ( byte [ ] b ) throws IOException { return read ( b , 0 , b . length ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . io . Data@@ Input ; import java . io . Data@@ Output ; import java . io . File ; import java . lang . ref . Reference ; import java . lang . ref . So@@ ft@@ Reference ; import java . lang . ref . W@@ eak@@ Reference ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import net . sf . sv@@ editor . core . SV@@ FileUtils ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Marker ; import net . sf . sv@@ editor . core . db . index . SV@@ DB@@ Base@@ Index@@ Cache@@ Data ; import net . sf . sv@@ editor . core . db . index . SV@@ DB@@ File@@ Tree ; import net . sf . sv@@ editor . core . db . persistence . DB@@ FormatException ; import net . sf . sv@@ editor . core . db . persistence . DB@@ Write@@ Exception ; import net . sf . sv@@ editor . core . db . persistence . ID@@ B@@ Reader ; import net . sf . sv@@ editor . core . db . persistence . ID@@ B@@ Writer ; import net . sf . sv@@ editor . core . db . persistence . SV@@ DB@@ Persistence@@ R@@ W ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Handle ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level@@ Listener ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; @ SuppressWarnings ( { "raw@@ types" , "unchecked" } ) public class SV@@ DB@@ File@@ Index@@ Cache implements IS@@ V@@ DB@@ Index@@ Cache , I@@ Log@@ Level@@ Listener { private String f@@ Base@@ Location ; private Map < String , Cache@@ FileInfo > f@@ File@@ Cache ; private IS@@ V@@ DB@@ F@@ S f@@ SV@@ DB@@ F@@ S ; private Object f@@ Index@@ Data ; private Log@@ Handle f@@ Log ; private List < ID@@ B@@ Reader > f@@ Persistence@@ R@@ dr@@ Set ; private List < ID@@ B@@ Writer > f@@ Persistence@@ Writer@@ Set ; private long f@@ Num@@ Files@@ Read = 0 ; private boolean f@@ Debug@@ E@@ n = false ; private int f@@ Max@@ Cache@@ Size = 100 ; private static Cache@@ FileInfo f@@ Cache@@ H@@ ead ; private static Cache@@ FileInfo f@@ Cache@@ Ta@@ il ; private static int f@@ Cache@@ Size ; private boolean f@@ Use@@ So@@ ft@@ Ref = true ; final class Cache@@ FileInfo { public boolean f@@ Cach@@ ed ; public Cache@@ FileInfo f@@ Pre@@ v ; public Cache@@ FileInfo f@@ Next ; public Reference < SV@@ DB@@ File > f@@ SV@@ DB@@ Pre@@ Proc@@ File ; public SV@@ DB@@ File f@@ SV@@ DB@@ Pre@@ Proc@@ File@@ Ref ; public Reference < SV@@ DB@@ File@@ Tree > f@@ SV@@ DB@@ File@@ Tree ; public SV@@ DB@@ File@@ Tree f@@ SV@@ DB@@ File@@ Tree@@ Ref ; public Reference < SV@@ DB@@ File > f@@ SV@@ DB@@ File ; public SV@@ DB@@ File f@@ SV@@ DB@@ File@@ Ref ; public Reference < List < SV@@ DB@@ Marker > > f@@ Mark@@ ers ; public List < SV@@ DB@@ Marker > f@@ Mar@@ ker@@ s@@ Ref ; public long f@@ Last@@ Modified ; public Cache@@ FileInfo ( ) { f@@ SV@@ DB@@ Pre@@ Proc@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( null ) ; f@@ SV@@ DB@@ File@@ Tree = ( Reference < SV@@ DB@@ File@@ Tree > ) create@@ Ref ( null ) ; f@@ SV@@ DB@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( null ) ; f@@ Mark@@ ers = ( Reference < List < SV@@ DB@@ Marker > > ) create@@ Ref ( null ) ; f@@ Last@@ Modified = - 1 ; } } final class Write@@ Back@@ Info { public static final int SV@@ DB_@@ FILE = 0 , SV@@ DB_@@ FILE_@@ T@@ RE@@ E = 1 , MAR@@ K@@ ER@@ S = 2 ; public int f@@ Type ; public SV@@ DB@@ File f@@ File ; public SV@@ DB@@ File@@ Tree f@@ File@@ Tree ; public List < SV@@ DB@@ Marker > f@@ Mark@@ ers ; public String f@@ FilePath ; public String f@@ Target@@ Dir ; public Write@@ Back@@ Info ( String target@@ _@@ dir , String file@@ _@@ path , SV@@ DB@@ File file ) { f@@ Target@@ Dir = target@@ _@@ dir ; f@@ FilePath = file@@ _@@ path ; f@@ File = file ; f@@ Type = SV@@ DB_@@ FILE ; } public Write@@ Back@@ Info ( String target@@ _@@ dir , String file@@ _@@ path , SV@@ DB@@ File@@ Tree file ) { f@@ Target@@ Dir = target@@ _@@ dir ; f@@ FilePath = file@@ _@@ path ; f@@ File@@ Tree = file ; f@@ Type = SV@@ DB_@@ FILE_@@ T@@ RE@@ E ; } public Write@@ Back@@ Info ( String target@@ _@@ dir , String file@@ _@@ path , List < SV@@ DB@@ Marker > mark@@ ers ) { f@@ Target@@ Dir = target@@ _@@ dir ; f@@ FilePath = file@@ _@@ path ; f@@ Mark@@ ers = mark@@ ers ; f@@ Type = MAR@@ K@@ ER@@ S ; } } public SV@@ DB@@ File@@ Index@@ Cache ( IS@@ V@@ DB@@ F@@ S fs ) { f@@ SV@@ DB@@ F@@ S = fs ; f@@ File@@ Cache = new HashMap < String , SV@@ DB@@ File@@ Index@@ Cache . Cache@@ FileInfo > ( ) ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; f@@ Debug@@ E@@ n = f@@ Log . isEnabled ( ) ; f@@ Log . add@@ Log@@ Level@@ Listener ( this ) ; f@@ Persistence@@ R@@ dr@@ Set = new ArrayList < ID@@ B@@ Reader > ( ) ; f@@ Persistence@@ Writer@@ Set = new ArrayList < ID@@ B@@ Writer > ( ) ; } public void log@@ Level@@ Changed ( I@@ Log@@ Handle handle ) { f@@ Debug@@ E@@ n = handle . isEnabled ( ) ; } public long num@@ Files@@ Read ( ) { return f@@ Num@@ Files@@ Read ; } public void remove@@ Storage@@ Path ( List < File > db@@ _@@ path@@ _@@ list ) { f@@ SV@@ DB@@ F@@ S . remove@@ Storage@@ Path ( db@@ _@@ path@@ _@@ list ) ; } public void set@@ Index@@ Data ( Object data ) { f@@ Index@@ Data = data ; } public Object getIndex@@ Data ( ) { return f@@ Index@@ Data ; } public boolean isValid ( ) { return true ; } public void clear ( I@@ ProgressMonitor monitor ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" ) ; } monitor . begin@@ Task ( "C@@ le@@ ar Cache@@ " , 1 ) ; f@@ File@@ Cache . clear ( ) ; f@@ SV@@ DB@@ F@@ S . delete ( monitor , "" ) ; monitor . done ( ) ; } public void add@@ File ( String path ) { getC@@ ache@@ FileInfo ( path , true ) ; } private Cache@@ FileInfo getC@@ ache@@ FileInfo ( String path , boolean create ) { synchronized ( f@@ File@@ Cache ) { Cache@@ FileInfo file = null ; if ( ! f@@ File@@ Cache . containsKey ( path ) ) { if ( create ) { file = new Cache@@ FileInfo ( ) ; f@@ File@@ Cache . put ( path , file ) ; } } else { file = f@@ File@@ Cache . get ( path ) ; } if ( file != null ) { if ( file . f@@ Cach@@ ed ) { move@@ Element@@ To@@ Ta@@ il ( file ) ; } else { add@@ Element@@ To@@ Ta@@ il ( file ) ; } } return file ; } } public void set@@ Mark@@ ers ( String path , List < SV@@ DB@@ Marker > mark@@ ers ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; cf@@ i . f@@ Mark@@ ers = ( Reference < List < SV@@ DB@@ Marker > > ) create@@ Ref ( mark@@ ers ) ; cf@@ i . f@@ Mar@@ ker@@ s@@ Ref = mark@@ ers ; write@@ Back@@ Mar@@ ker@@ List ( path , mark@@ ers ) ; } public List < SV@@ DB@@ Marker > getM@@ ar@@ k@@ ers ( String path ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , false ) ; List < SV@@ DB@@ Marker > m = ( cf@@ i != null ) ? cf@@ i . f@@ Mark@@ ers . get ( ) : null ; if ( m == null ) { String parent@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; String target@@ _@@ file = parent@@ _@@ dir + "/@@ mar@@ ker@@ s" ; if ( f@@ SV@@ DB@@ F@@ S . file@@ Exists ( target@@ _@@ file ) ) { cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; m = read@@ Mar@@ ker@@ List ( target@@ _@@ file ) ; cf@@ i . f@@ Mark@@ ers = ( Reference < List < SV@@ DB@@ Marker > > ) create@@ Ref ( m ) ; cf@@ i . f@@ Mar@@ ker@@ s@@ Ref = m ; } } if ( m == null ) { m = new ArrayList < SV@@ DB@@ Marker > ( ) ; } return m ; } public boolean init ( I@@ ProgressMonitor monitor , Object index@@ _data ) { boolean valid = false ; f@@ File@@ Cache . clear ( ) ; f@@ Base@@ Location = "" ; f@@ Index@@ Data = index@@ _data ; ID@@ B@@ Reader r@@ dr = alloc@@ Reader ( ) ; try { Data@@ Input in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( "@@ index@@ " ) ; if ( in != null ) { r@@ dr . init ( in ) ; f@@ Base@@ Location = r@@ dr . readString ( ) ; List < String > file@@ _@@ list = r@@ dr . read@@ String@@ List ( ) ; List < Long > tim@@ estamp@@ _@@ list = r@@ dr . read@@ Long@@ List ( ) ; for ( int i = 0 ; i < file@@ _@@ list . size ( ) ; i ++ ) { String path = file@@ _@@ list . get ( i ) ; Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; cf@@ i . f@@ Last@@ Modified = tim@@ estamp@@ _@@ list . get ( i ) ; } f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; } in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( "@@ index@@ _@@ data@@ " ) ; if ( in != null ) { r@@ dr . init ( in ) ; r@@ dr . readObject ( null , index@@ _data . getClass ( ) , index@@ _data ) ; if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "@@ Cache " + f@@ SV@@ DB@@ F@@ S . getRoot ( ) + " h@@ as base " + ( ( SV@@ DB@@ Base@@ Index@@ Cache@@ Data ) index@@ _data ) . getBase@@ Location ( ) ) ; } f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; valid = true ; } else { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" ) ; } } } catch ( DB@@ FormatException e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Reader ( r@@ dr ) ; } return valid ; } public void init@@ Load ( I@@ ProgressMonitor monitor ) { } public Set < String > getFile@@ List ( ) { return f@@ File@@ Cache . keySet ( ) ; } public long getLast@@ Modified ( String path ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , false ) ; if ( cf@@ i != null ) { return cf@@ i . f@@ Last@@ Modified ; } else { System . out . println ( "@@ File \"" + path + "" ) ; } return - 1 ; } public void setLast@@ Modified ( String path , long timestamp ) { if ( timestamp == - 1 ) { try { throw new Exception ( ) ; } catch ( Exception e ) { System . out . println ( "" ) ; e . printStackTrace ( ) ; } } Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; cf@@ i . f@@ Last@@ Modified = timestamp ; } public SV@@ DB@@ File getPre@@ Proc@@ File ( I@@ ProgressMonitor monitor , String path ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , false ) ; SV@@ DB@@ File pp@@ _@@ file = ( cf@@ i != null ) ? cf@@ i . f@@ SV@@ DB@@ Pre@@ Proc@@ File . get ( ) : null ; if ( pp@@ _@@ file == null ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; if ( f@@ SV@@ DB@@ F@@ S . file@@ Exists ( target@@ _@@ dir + "/@@ pre@@ Proc@@ File@@ " ) ) { cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; Data@@ Input in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( target@@ _@@ dir + "/@@ pre@@ Proc@@ File@@ " ) ; pp@@ _@@ file = read@@ File ( in , path ) ; f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; cf@@ i . f@@ SV@@ DB@@ Pre@@ Proc@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( pp@@ _@@ file ) ; cf@@ i . f@@ SV@@ DB@@ Pre@@ Proc@@ File@@ Ref = pp@@ _@@ file ; } } return pp@@ _@@ file ; } public SV@@ DB@@ File getFile ( I@@ ProgressMonitor monitor , String path ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , false ) ; SV@@ DB@@ File file = ( cf@@ i != null ) ? cf@@ i . f@@ SV@@ DB@@ File . get ( ) : null ; if ( file == null ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; if ( f@@ SV@@ DB@@ F@@ S . file@@ Exists ( target@@ _@@ dir + "/@@ file@@ " ) ) { cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; Data@@ Input in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( target@@ _@@ dir + "/@@ file@@ " ) ; file = read@@ File ( in , path ) ; f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; cf@@ i . f@@ SV@@ DB@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( file ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Ref = file ; f@@ Num@@ Files@@ Read ++ ; } } return file ; } public void set@@ Pre@@ Proc@@ File ( String path , SV@@ DB@@ File file ) { if ( file == null ) { try { throw new Exception ( "" + path + "\" is null@@ " ) ; } catch ( Exception e ) { f@@ Log . error ( "" + path + "\" is null@@ " , e ) ; } } Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; cf@@ i . f@@ SV@@ DB@@ Pre@@ Proc@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( file ) ; cf@@ i . f@@ SV@@ DB@@ Pre@@ Proc@@ File@@ Ref = file ; write@@ Back@@ Pre@@ Proc@@ File ( path , file ) ; } public void set@@ File ( String path , SV@@ DB@@ File file ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; if ( file == null ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MA@@ X , "@@ set@@ File \"" + path + "\" == NUL@@ L@@ " ) ; } cf@@ i . f@@ SV@@ DB@@ File = new W@@ eak@@ Reference < SV@@ DB@@ File > ( null ) ; String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; f@@ SV@@ DB@@ F@@ S . delete ( null , target@@ _@@ dir + "/@@ file@@ " ) ; } else { cf@@ i . f@@ SV@@ DB@@ File = ( Reference < SV@@ DB@@ File > ) create@@ Ref ( file ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Ref = file ; write@@ Back@@ File ( path , file ) ; } } public void set@@ File@@ Tree ( String path , SV@@ DB@@ File@@ Tree file@@ _@@ tree ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Tree = ( Reference < SV@@ DB@@ File@@ Tree > ) create@@ Ref ( file@@ _@@ tree ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Tree@@ Ref = file@@ _@@ tree ; if ( path == null ) { System . out . println ( "@@ Null path@@ " ) ; } write@@ Back@@ File@@ Tree ( path , file@@ _@@ tree ) ; } public SV@@ DB@@ File@@ Tree getFile@@ Tree ( I@@ ProgressMonitor monitor , String path ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , false ) ; SV@@ DB@@ File@@ Tree ft = ( cf@@ i != null ) ? cf@@ i . f@@ SV@@ DB@@ File@@ Tree . get ( ) : null ; if ( ft == null ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; if ( f@@ SV@@ DB@@ F@@ S . file@@ Exists ( target@@ _@@ dir + "/@@ file@@ Tree@@ Map@@ " ) ) { cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; Data@@ Input in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( target@@ _@@ dir + "/@@ file@@ Tree@@ Map@@ " ) ; ft = read@@ File@@ Tree ( in ) ; f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Tree = ( Reference < SV@@ DB@@ File@@ Tree > ) create@@ Ref ( ft ) ; cf@@ i . f@@ SV@@ DB@@ File@@ Tree@@ Ref = ft ; } } return ft ; } public void remove@@ File ( String path ) { Cache@@ FileInfo file = f@@ File@@ Cache . get ( path ) ; f@@ File@@ Cache . remove ( path ) ; remove@@ Element ( file ) ; String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; f@@ SV@@ DB@@ F@@ S . delete ( null , target@@ _@@ dir ) ; } private String compute@@ Path@@ Dir ( String path ) { return SV@@ FileUtils . compute@@ MD@@ 5 ( path ) ; } private SV@@ DB@@ File read@@ File ( Data@@ Input in , String path ) { ID@@ B@@ Reader reader = alloc@@ Reader ( ) ; reader . init ( in ) ; SV@@ DB@@ File ret = new SV@@ DB@@ File ( ) ; try { reader . readObject ( null , ret . getClass ( ) , ret ) ; } catch ( DB@@ FormatException e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Reader ( reader ) ; } return ret ; } private SV@@ DB@@ File@@ Tree read@@ File@@ Tree ( Data@@ Input in ) { ID@@ B@@ Reader reader = alloc@@ Reader ( ) ; reader . init ( in ) ; SV@@ DB@@ File@@ Tree ret = new SV@@ DB@@ File@@ Tree ( ) ; try { reader . readObject ( null , ret . getClass ( ) , ret ) ; } catch ( DB@@ FormatException e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Reader ( reader ) ; } return ret ; } private List < SV@@ DB@@ Marker > read@@ Mar@@ ker@@ List ( String path ) { Data@@ Input in = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Input ( path ) ; ID@@ B@@ Reader reader = alloc@@ Reader ( ) ; reader . init ( in ) ; List < SV@@ DB@@ Marker > ret = null ; try { ret = ( List < SV@@ DB@@ Marker > ) reader . read@@ Item@@ List ( null ) ; } catch ( DB@@ FormatException e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Reader ( reader ) ; } f@@ SV@@ DB@@ F@@ S . close@@ Input ( in ) ; return ret ; } public void sync ( ) { ID@@ B@@ Writer writer = alloc@@ Writer ( ) ; try { Data@@ Output out = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Output ( "@@ index@@ " ) ; if ( out == null ) { throw new DB@@ Write@@ Exception ( "" ) ; } writer . init ( out ) ; writer . writeString ( f@@ Base@@ Location ) ; List < String > tmp = new ArrayList < String > ( ) ; tmp . addAll ( f@@ File@@ Cache . keySet ( ) ) ; writer . write@@ String@@ List ( tmp ) ; List < Long > tim@@ estamp@@ _@@ list = new ArrayList < Long > ( ) ; for ( String path : f@@ File@@ Cache . keySet ( ) ) { Cache@@ FileInfo cf@@ i = getC@@ ache@@ FileInfo ( path , true ) ; tim@@ estamp@@ _@@ list . add ( cf@@ i . f@@ Last@@ Modified ) ; } writer . write@@ Long@@ List ( tim@@ estamp@@ _@@ list ) ; writer . close ( ) ; f@@ SV@@ DB@@ F@@ S . close@@ Output ( out ) ; out = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Output ( "@@ index@@ _@@ data@@ " ) ; writer . init ( out ) ; writer . writeObject ( f@@ Index@@ Data . getClass ( ) , f@@ Index@@ Data ) ; writer . close ( ) ; f@@ SV@@ DB@@ F@@ S . close@@ Output ( out ) ; } catch ( DB@@ Write@@ Exception e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Writer ( writer ) ; } } private ID@@ B@@ Reader alloc@@ Reader ( ) { ID@@ B@@ Reader reader = null ; synchronized ( f@@ Persistence@@ R@@ dr@@ Set ) { if ( f@@ Persistence@@ R@@ dr@@ Set . size ( ) > 0 ) { reader = f@@ Persistence@@ R@@ dr@@ Set . remove ( f@@ Persistence@@ R@@ dr@@ Set . size ( ) - 1 ) ; } } if ( reader == null ) { reader = new SV@@ DB@@ Persistence@@ R@@ W ( ) ; } return reader ; } private void f@@ ree@@ Reader ( ID@@ B@@ Reader reader ) { synchronized ( f@@ Persistence@@ R@@ dr@@ Set ) { f@@ Persistence@@ R@@ dr@@ Set . add ( reader ) ; } } private ID@@ B@@ Writer alloc@@ Writer ( ) { ID@@ B@@ Writer writer = null ; synchronized ( f@@ Persistence@@ Writer@@ Set ) { if ( f@@ Persistence@@ Writer@@ Set . size ( ) > 0 ) { writer = f@@ Persistence@@ Writer@@ Set . remove ( f@@ Persistence@@ Writer@@ Set . size ( ) - 1 ) ; } } if ( writer == null ) { writer = new SV@@ DB@@ Persistence@@ R@@ W ( ) ; } return writer ; } private void f@@ ree@@ Writer ( ID@@ B@@ Writer writer ) { synchronized ( f@@ Persistence@@ Writer@@ Set ) { f@@ Persistence@@ Writer@@ Set . add ( writer ) ; } } private void write@@ Back@@ Pre@@ Proc@@ File ( String path , SV@@ DB@@ File file ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; String file@@ _@@ path = target@@ _@@ dir + "/@@ pre@@ Proc@@ File@@ " ; write@@ Back@@ File@@ Worker ( target@@ _@@ dir , file@@ _@@ path , file ) ; } private void write@@ Back@@ File ( String path , SV@@ DB@@ File file ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; String file@@ _@@ path = target@@ _@@ dir + "/@@ file@@ " ; write@@ Back@@ File@@ Worker ( target@@ _@@ dir , file@@ _@@ path , file ) ; } private void write@@ Back@@ File@@ Tree ( String path , SV@@ DB@@ File@@ Tree file@@ _@@ tree ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; String file@@ _@@ path = target@@ _@@ dir + "/@@ file@@ Tree@@ Map@@ " ; write@@ Back@@ File@@ Tree@@ Worker ( target@@ _@@ dir , file@@ _@@ path , file@@ _@@ tree ) ; } private void write@@ Back@@ Mar@@ ker@@ List ( String path , List < SV@@ DB@@ Marker > mark@@ ers ) { String target@@ _@@ dir = compute@@ Path@@ Dir ( path ) ; String file@@ _@@ path = target@@ _@@ dir + "/@@ mar@@ ker@@ s" ; write@@ Back@@ Mar@@ ker@@ List@@ Worker ( target@@ _@@ dir , file@@ _@@ path , mark@@ ers ) ; } private void write@@ Back@@ File@@ Worker ( String target@@ _@@ dir , String file@@ _@@ path , SV@@ DB@@ File file ) { ID@@ B@@ Writer writer = alloc@@ Writer ( ) ; f@@ SV@@ DB@@ F@@ S . mk@@ dirs ( target@@ _@@ dir ) ; try { Data@@ Output out = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Output ( file@@ _@@ path ) ; writer . init ( out ) ; writer . writeObject ( file . getClass ( ) , file ) ; writer . close ( ) ; f@@ SV@@ DB@@ F@@ S . close@@ Output ( out ) ; } catch ( DB@@ Write@@ Exception e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Writer ( writer ) ; } } private void write@@ Back@@ File@@ Tree@@ Worker ( String target@@ _@@ dir , String file@@ _@@ path , SV@@ DB@@ File@@ Tree file@@ _@@ tree ) { f@@ SV@@ DB@@ F@@ S . mk@@ dirs ( target@@ _@@ dir ) ; ID@@ B@@ Writer writer = alloc@@ Writer ( ) ; try { Data@@ Output out = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Output ( file@@ _@@ path ) ; writer . init ( out ) ; synchronized ( file@@ _@@ tree ) { writer . writeObject ( file@@ _@@ tree . getClass ( ) , file@@ _@@ tree ) ; } writer . close ( ) ; f@@ SV@@ DB@@ F@@ S . close@@ Output ( out ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Writer ( writer ) ; } } private void write@@ Back@@ Mar@@ ker@@ List@@ Worker ( String target@@ _@@ dir , String file@@ _@@ path , List < SV@@ DB@@ Marker > mark@@ ers ) { f@@ SV@@ DB@@ F@@ S . mk@@ dirs ( target@@ _@@ dir ) ; ID@@ B@@ Writer writer = alloc@@ Writer ( ) ; try { Data@@ Output out = f@@ SV@@ DB@@ F@@ S . open@@ Data@@ Output ( file@@ _@@ path ) ; writer . init ( out ) ; writer . write@@ Item@@ List ( mark@@ ers ) ; writer . close ( ) ; f@@ SV@@ DB@@ F@@ S . close@@ Output ( out ) ; } catch ( DB@@ Write@@ Exception e ) { e . printStackTrace ( ) ; } finally { f@@ ree@@ Writer ( writer ) ; } } private Reference create@@ Ref ( Object obj ) { if ( f@@ Use@@ So@@ ft@@ Ref ) { return new So@@ ft@@ Reference ( obj ) ; } else { return new W@@ eak@@ Reference ( obj ) ; } } private void add@@ Element@@ To@@ Ta@@ il ( Cache@@ FileInfo info ) { synchronized ( SV@@ DB@@ File@@ Index@@ Cache . class ) { info . f@@ Cach@@ ed = true ; info . f@@ SV@@ DB@@ File@@ Ref = info . f@@ SV@@ DB@@ File . get ( ) ; info . f@@ SV@@ DB@@ File@@ Tree@@ Ref = info . f@@ SV@@ DB@@ File@@ Tree . get ( ) ; info . f@@ SV@@ DB@@ Pre@@ Proc@@ File@@ Ref = info . f@@ SV@@ DB@@ Pre@@ Proc@@ File . get ( ) ; if ( f@@ Cache@@ H@@ ead == null ) { f@@ Cache@@ H@@ ead = info ; f@@ Cache@@ Ta@@ il = info ; info . f@@ Pre@@ v = null ; info . f@@ Next = null ; } else { f@@ Cache@@ Ta@@ il . f@@ Next = info ; info . f@@ Pre@@ v = f@@ Cache@@ Ta@@ il ; f@@ Cache@@ Ta@@ il = info ; info . f@@ Next = null ; } f@@ Cache@@ Size ++ ; while ( f@@ Cache@@ Size > f@@ Max@@ Cache@@ Size ) { remove@@ Element ( f@@ Cache@@ H@@ ead ) ; } } } private void move@@ Element@@ To@@ Ta@@ il ( Cache@@ FileInfo info ) { synchronized ( SV@@ DB@@ File@@ Index@@ Cache . class ) { if ( f@@ Cache@@ Ta@@ il != info ) { if ( info . f@@ Pre@@ v == null ) { f@@ Cache@@ H@@ ead = info . f@@ Next ; } else { info . f@@ Pre@@ v . f@@ Next = info . f@@ Next ; } if ( info . f@@ Next == null ) { f@@ Cache@@ Ta@@ il = info . f@@ Pre@@ v ; } else { info . f@@ Next . f@@ Pre@@ v = info . f@@ Pre@@ v ; } if ( f@@ Cache@@ H@@ ead == null ) { f@@ Cache@@ H@@ ead = info ; f@@ Cache@@ Ta@@ il = info ; info . f@@ Pre@@ v = null ; info . f@@ Next = null ; } else { f@@ Cache@@ Ta@@ il . f@@ Next = info ; info . f@@ Pre@@ v = f@@ Cache@@ Ta@@ il ; f@@ Cache@@ Ta@@ il = info ; info . f@@ Next = null ; } } } } private void remove@@ Element ( Cache@@ FileInfo info ) { synchronized ( SV@@ DB@@ File@@ Index@@ Cache . class ) { if ( info . f@@ Pre@@ v == null ) { f@@ Cache@@ H@@ ead = info . f@@ Next ; } else { info . f@@ Pre@@ v . f@@ Next = info . f@@ Next ; } if ( info . f@@ Next == null ) { f@@ Cache@@ Ta@@ il = info . f@@ Pre@@ v ; } else { info . f@@ Next . f@@ Pre@@ v = info . f@@ Pre@@ v ; } info . f@@ SV@@ DB@@ File@@ Ref = null ; info . f@@ SV@@ DB@@ File@@ Tree@@ Ref = null ; info . f@@ SV@@ DB@@ Pre@@ Proc@@ File@@ Ref = null ; info . f@@ Cach@@ ed = false ; f@@ Cache@@ Size -- ; } } } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . io . IOException ; import java . io . OutputStream ; public class Mapp@@ ed@@ Byte@@ Buffer@@ OutputStream extends OutputStream { @ Override public void write ( int b ) throws IOException { } } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . io . Data@@ Input ; import java . io . Data@@ Output ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . RandomAccess@@ File ; import java . nio . Mapp@@ ed@@ ByteBuffer ; import java . util . List ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public class SV@@ DB@@ File@@ F@@ S implements IS@@ V@@ DB@@ F@@ S { private RandomAccess@@ File f@@ Storage ; private class Block { protected long f@@ Block@@ Pt@@ r ; private long f@@ Next@@ Block@@ Pt@@ r ; public Block ( long ptr ) { f@@ Block@@ Pt@@ r = ptr ; } public long getNext@@ Block ( ) { return f@@ Next@@ Block@@ Pt@@ r ; } public void set@@ Next@@ Block ( long next ) { f@@ Next@@ Block@@ Pt@@ r = next ; } Block ( Data@@ Input in ) throws IOException { f@@ Next@@ Block@@ Pt@@ r = in . read@@ Long ( ) ; } } private class Root@@ Block { private long f@@ Di@@ rent@@ Pt@@ r ; private long f@@ Bitmap@@ Pt@@ r ; } private class Dir@@ ent extends Block { Dir@@ ent ( Data@@ Input in ) throws IOException { super ( in ) ; } } private class File@@ Entry { } private class Block@@ Bitmap { private Mapp@@ ed@@ ByteBuffer f@@ Block ; Block@@ Bitmap ( Mapp@@ ed@@ ByteBuffer block ) { f@@ Block = block ; } } private List < Block@@ Bitmap > f@@ Block@@ Bitmap@@ List ; public SV@@ DB@@ File@@ F@@ S ( ) { RandomAccess@@ File f ; } public String getRoot ( ) { return "" ; } public void remove@@ Storage@@ Path ( List < File > db@@ _@@ file@@ _@@ list ) { } public InputStream open@@ File@@ Read ( String path ) throws IOException { return null ; } public RandomAccess@@ File open@@ Channel@@ Read ( String path ) { return null ; } public RandomAccess@@ File open@@ Channel@@ Write ( String path ) { return null ; } public void close@@ Channel ( RandomAccess@@ File ch ) { } public void close ( InputStream in ) { } public long lastModified ( String path ) { return 0 ; } public OutputStream open@@ File@@ Write ( String path ) { return null ; } public boolean file@@ Exists ( String path ) { return false ; } public void sync ( ) throws IOException { } public void delete ( I@@ ProgressMonitor monitor , String path ) { } public void mk@@ dirs ( String path ) { } public Data@@ Input open@@ Data@@ Input ( String path ) { return null ; } public void close@@ Input ( Data@@ Input in ) { } public Data@@ Output open@@ Data@@ Output ( String path ) { return null ; } public void close@@ Output ( Data@@ Output out ) { } } </s>
<s> package net . sf . sv@@ editor . core . db . index . cache ; import java . io . Data@@ Input ; import java . io . Data@@ Output ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . RandomAccess@@ File ; import java . util . List ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public interface IS@@ V@@ DB@@ F@@ S { String getRoot ( ) ; void remove@@ Storage@@ Path ( List < File > db@@ _@@ file@@ _@@ list ) ; InputStream open@@ File@@ Read ( String path ) throws IOException ; RandomAccess@@ File open@@ Channel@@ Read ( String path ) ; Data@@ Input open@@ Data@@ Input ( String path ) ; void close@@ Channel ( RandomAccess@@ File ch ) ; void close ( InputStream in ) ; void close@@ Input ( Data@@ Input in ) ; OutputStream open@@ File@@ Write ( String path ) ; RandomAccess@@ File open@@ Channel@@ Write ( String path ) ; Data@@ Output open@@ Data@@ Output ( String path ) ; void close@@ Output ( Data@@ Output out ) ; boolean file@@ Exists ( String path ) ; long lastModified ( String path ) ; void delete ( I@@ ProgressMonitor monitor , String path ) ; void mk@@ dirs ( String path ) ; void sync ( ) throws IOException ; } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache ; public interface IS@@ V@@ DB@@ Index@@ Factory { String KEY_@@ Global@@ Defin@@ e@@ Map = "" ; IS@@ V@@ DB@@ Index create@@ SV@@ DB@@ Index ( String project@@ _name , String base@@ _@@ location , IS@@ V@@ DB@@ Index@@ Cache cache , SV@@ DB@@ Index@@ Config config ) ; } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . util . ArrayList ; import java . util . List ; import java . util . Set ; import net . sf . sv@@ editor . core . SV@@ FileUtils ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache ; import net . sf . sv@@ editor . core . files@@ et . Abstract@@ SV@@ File@@ Matcher ; import net . sf . sv@@ editor . core . log . LogFactory ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public class SV@@ DB@@ Source@@ Collection@@ Index extends Abstract@@ SV@@ DB@@ Index { private List < Abstract@@ SV@@ File@@ Matcher > f@@ File@@ Match@@ er@@ List ; static { LogFactory . get@@ Log@@ Handle ( "" ) ; } SV@@ DB@@ Source@@ Collection@@ Index ( String project , String root , List < Abstract@@ SV@@ File@@ Matcher > match@@ er@@ _@@ list , IS@@ V@@ DB@@ File@@ System@@ Provider f@@ s_@@ provider , IS@@ V@@ DB@@ Index@@ Cache cache , SV@@ DB@@ Index@@ Config config ) { super ( project , root , f@@ s_@@ provider , cache , config ) ; f@@ File@@ Match@@ er@@ List = match@@ er@@ _@@ list ; } @ Override protected String get@@ Log@@ Name ( ) { return "" ; } @ Override protected boolean check@@ Cache@@ Valid ( ) { boolean valid = super . check@@ Cache@@ Valid ( ) ; if ( valid ) { for ( int i = 0 ; i < f@@ File@@ Match@@ er@@ List . size ( ) ; i ++ ) { Abstract@@ SV@@ File@@ Matcher matcher = f@@ File@@ Match@@ er@@ List . get ( i ) ; List < String > file@@ _@@ path@@ s = matcher . find@@ Inclu@@ ded@@ Paths ( ) ; Set < String > cache@@ _@@ files = getC@@ ache ( ) . getFile@@ List ( ) ; List < String > tmp@@ _c@@ ache@@ _@@ files = new ArrayList < String > ( ) ; tmp@@ _c@@ ache@@ _@@ files . addAll ( cache@@ _@@ files ) ; for ( String path : file@@ _@@ path@@ s ) { if ( cache@@ _@@ files . contains ( path ) ) { long f@@ s_@@ timestamp = getFile@@ System@@ Provider ( ) . getLast@@ Modified@@ Time ( path ) ; long cache@@ _@@ timestamp = getC@@ ache ( ) . getLast@@ Modified ( path ) ; if ( cache@@ _@@ timestamp < f@@ s_@@ timestamp ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path + ": file@@ =" + f@@ s_@@ timestamp + " cache@@ =" + cache@@ _@@ timestamp ) ; } valid = false ; break ; } tmp@@ _c@@ ache@@ _@@ files . remove ( path ) ; } else { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path ) ; } valid = false ; break ; } } if ( valid ) { for ( String path : tmp@@ _c@@ ache@@ _@@ files ) { if ( getFile@@ System@@ Provider ( ) . file@@ Exists ( path ) ) { long f@@ s_@@ timestamp = getFile@@ System@@ Provider ( ) . getLast@@ Modified@@ Time ( path ) ; long cache@@ _@@ timestamp = getC@@ ache ( ) . getLast@@ Modified ( path ) ; if ( cache@@ _@@ timestamp < f@@ s_@@ timestamp ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path + ": file@@ =" + f@@ s_@@ timestamp + " cache@@ =" + cache@@ _@@ timestamp ) ; } valid = false ; break ; } } else { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path ) ; } valid = false ; break ; } } } } } if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + ( ( valid ) ? "@@ valid@@ " : "@@ invalid@@ " ) ) ; } return valid ; } @ Override protected void dis@@ cover@@ Root@@ Files ( I@@ ProgressMonitor monitor ) { for ( int i = 0 ; i < f@@ File@@ Match@@ er@@ List . size ( ) ; i ++ ) { Abstract@@ SV@@ File@@ Matcher matcher = f@@ File@@ Match@@ er@@ List . get ( i ) ; List < String > file@@ _@@ path@@ s = matcher . find@@ Inclu@@ ded@@ Paths ( ) ; f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" ) ; for ( String path : file@@ _@@ path@@ s ) { String r@@ p = resolve@@ Path ( path , f@@ In@@ Work@@ space@@ O@@ k ) ; f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + r@@ p + "\"" ) ; add@@ File ( r@@ p ) ; add@@ Inclu@@ de@@ Path ( SV@@ FileUtils . getPath@@ Parent ( r@@ p ) ) ; } } } public String getType@@ ID ( ) { return SV@@ DB@@ Source@@ Collection@@ Index@@ Factory . TYPE ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . util . HashMap ; import java . util . Map ; public class SV@@ DB@@ Index@@ Config extends HashMap < String , Object > { private static final long serialVersionUID = 1L ; public static boolean equals ( SV@@ DB@@ Index@@ Config c1 , SV@@ DB@@ Index@@ Config c2 ) { if ( c1 == null || c2 == null ) { return ( c1 == c2 ) ; } else { boolean equals = c1 . size ( ) == c2 . size ( ) ; if ( equals ) { for ( Map . Entry < String , Object > c@@ 1_@@ e : c1 . entrySet ( ) ) { if ( c2 . containsKey ( c@@ 1_@@ e . getKey ( ) ) ) { Object o1 = c1 . get ( c@@ 1_@@ e . getKey ( ) ) ; Object o2 = c2 . get ( c@@ 1_@@ e . getKey ( ) ) ; if ( o1 == null || o2 == null ) { equals &@@ = ( o1 == o2 ) ; } else { equals &@@ = o1 . equals ( o2 ) ; } } else { equals = false ; } if ( ! equals ) { break ; } } } return equals ; } } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; public interface IS@@ V@@ DB@@ Item@@ Iterator { boolean hasNext ( SV@@ DB@@ Item@@ Type ... type@@ _@@ list ) ; IS@@ V@@ DB@@ Item@@ Base next@@ Item ( SV@@ DB@@ Item@@ Type ... type@@ _@@ list ) ; } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Search@@ Result ; public interface IS@@ V@@ DB@@ Inclu@@ de@@ File@@ Provider { SV@@ DB@@ Search@@ Result < SV@@ DB@@ File > find@@ Inclu@@ ded@@ File ( String le@@ af ) ; } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache ; public class SV@@ DB@@ Arg@@ File@@ Index@@ Factory implements IS@@ V@@ DB@@ Index@@ Factory { public static final String TYPE = "" ; public IS@@ V@@ DB@@ Index create@@ SV@@ DB@@ Index ( String project@@ Name , String base@@ _@@ location , IS@@ V@@ DB@@ Index@@ Cache cache , SV@@ DB@@ Index@@ Config config ) { IS@@ V@@ DB@@ File@@ System@@ Provider f@@ s_@@ provider ; f@@ s_@@ provider = new SV@@ DB@@ WS@@ File@@ System@@ Provider ( ) ; SV@@ DB@@ Arg@@ File@@ Index index = new SV@@ DB@@ Arg@@ File@@ Index ( project@@ Name , base@@ _@@ location , f@@ s_@@ provider , cache , config ) ; return index ; } public IS@@ V@@ DB@@ Index create@@ SV@@ DB@@ Index ( String project@@ Name , String base@@ _@@ location , StringBuilder arguments , IS@@ V@@ DB@@ Index@@ Cache cache , SV@@ DB@@ Index@@ Config config ) { IS@@ V@@ DB@@ File@@ System@@ Provider f@@ s_@@ provider ; f@@ s_@@ provider = new SV@@ DB@@ WS@@ File@@ System@@ Provider ( ) ; SV@@ DB@@ Arg@@ File@@ Index index = new SV@@ DB@@ Arg@@ File@@ Index ( project@@ Name , base@@ _@@ location , arguments , f@@ s_@@ provider , cache , config ) ; return index ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public interface IS@@ V@@ DB@@ Index@@ Iterator extends IS@@ V@@ DB@@ Decl@@ Cache { IS@@ V@@ DB@@ Item@@ Iterator getItem@@ Iterator ( I@@ ProgressMonitor monitor ) ; } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . String@@ Iterable@@ Iterator ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . re@@ fs . IS@@ V@@ DB@@ Ref@@ Matcher ; import net . sf . sv@@ editor . core . db . re@@ fs . SV@@ DB@@ Ref@@ Cache@@ Item ; import net . sf . sv@@ editor . core . db . search . IS@@ V@@ DB@@ Find@@ Name@@ Matcher ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; public class SV@@ DB@@ Index@@ List@@ Iterator implements IS@@ V@@ DB@@ Index@@ Iterator { private List < IS@@ V@@ DB@@ Index@@ Iterator > f@@ Index@@ Iterator@@ List ; public SV@@ DB@@ Index@@ List@@ Iterator ( ) { f@@ Index@@ Iterator@@ List = new ArrayList < IS@@ V@@ DB@@ Index@@ Iterator > ( ) ; } public void add@@ Index@@ Iterator ( IS@@ V@@ DB@@ Index@@ Iterator it ) { f@@ Index@@ Iterator@@ List . add ( it ) ; } public IS@@ V@@ DB@@ Item@@ Iterator getItem@@ Iterator ( I@@ ProgressMonitor monitor ) { return new SV@@ DB@@ Index@@ Item@@ It@@ Iterator ( f@@ Index@@ Iterator@@ List . iterator ( ) , monitor ) ; } public List < SV@@ DB@@ Decl@@ Cache@@ Item > find@@ Global@@ Scope@@ Decl ( I@@ ProgressMonitor monitor , String name , IS@@ V@@ DB@@ Find@@ Name@@ Matcher matcher ) { List < SV@@ DB@@ Decl@@ Cache@@ Item > ret = new ArrayList < SV@@ DB@@ Decl@@ Cache@@ Item > ( ) ; for ( IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it : f@@ Index@@ Iterator@@ List ) { List < SV@@ DB@@ Decl@@ Cache@@ Item > tmp = index@@ _@@ it . find@@ Global@@ Scope@@ Decl ( monitor , name , matcher ) ; ret . addAll ( tmp ) ; } return ret ; } public List < SV@@ DB@@ Ref@@ Cache@@ Item > find@@ Reference@@ s ( I@@ ProgressMonitor monitor , String name , IS@@ V@@ DB@@ Ref@@ Matcher matcher ) { List < SV@@ DB@@ Ref@@ Cache@@ Item > ret = new ArrayList < SV@@ DB@@ Ref@@ Cache@@ Item > ( ) ; for ( IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it : f@@ Index@@ Iterator@@ List ) { List < SV@@ DB@@ Ref@@ Cache@@ Item > r = index@@ _@@ it . find@@ Reference@@ s ( monitor , name , matcher ) ; ret . addAll ( r ) ; } return ret ; } public Iterable < String > getFile@@ List ( I@@ ProgressMonitor monitor ) { String@@ Iterable@@ Iterator ret = new String@@ Iterable@@ Iterator ( ) ; for ( IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it : f@@ Index@@ Iterator@@ List ) { ret . add@@ Iterable ( index@@ _@@ it . getFile@@ List ( new Null@@ ProgressMonitor ( ) ) ) ; } return ret ; } public SV@@ DB@@ File find@@ File ( I@@ ProgressMonitor monitor , String path ) { SV@@ DB@@ File ret = null ; synchronized ( f@@ Index@@ Iterator@@ List ) { for ( IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it : f@@ Index@@ Iterator@@ List ) { ret = index@@ _@@ it . find@@ File ( monitor , path ) ; if ( ret != null ) { break ; } } } return ret ; } public SV@@ DB@@ File find@@ Pre@@ Proc@@ File ( I@@ ProgressMonitor monitor , String path ) { SV@@ DB@@ File ret = null ; synchronized ( f@@ Index@@ Iterator@@ List ) { for ( IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it : f@@ Index@@ Iterator@@ List ) { ret = index@@ _@@ it . find@@ Pre@@ Proc@@ File ( monitor , path ) ; if ( ret != null ) { break ; } } } return ret ; } public List < SV@@ DB@@ Decl@@ Cache@@ Item > find@@ Package@@ Decl ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item pk@@ g_@@ item ) { List < SV@@ DB@@ Decl@@ Cache@@ Item > ret = new ArrayList < SV@@ DB@@ Decl@@ Cache@@ Item > ( ) ; for ( IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it : f@@ Index@@ Iterator@@ List ) { List < SV@@ DB@@ Decl@@ Cache@@ Item > tmp = index@@ _@@ it . find@@ Package@@ Decl ( monitor , pk@@ g_@@ item ) ; ret . addAll ( tmp ) ; } return ret ; } public SV@@ DB@@ File get@@ Decl@@ File ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item item ) { for ( IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it : f@@ Index@@ Iterator@@ List ) { SV@@ DB@@ File tmp = index@@ _@@ it . get@@ Decl@@ File ( monitor , item ) ; if ( tmp != null ) { return tmp ; } } return null ; } public SV@@ DB@@ File get@@ Decl@@ File@@ P@@ P ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item item ) { for ( IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it : f@@ Index@@ Iterator@@ List ) { SV@@ DB@@ File tmp = index@@ _@@ it . get@@ Decl@@ File@@ P@@ P ( monitor , item ) ; if ( tmp != null ) { return tmp ; } } return null ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . util . List ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . re@@ fs . IS@@ V@@ DB@@ Ref@@ Matcher ; import net . sf . sv@@ editor . core . db . re@@ fs . SV@@ DB@@ Ref@@ Cache@@ Entry ; import net . sf . sv@@ editor . core . db . re@@ fs . SV@@ DB@@ Ref@@ Cache@@ Item ; import net . sf . sv@@ editor . core . db . re@@ fs . SV@@ DB@@ Ref@@ Item ; import net . sf . sv@@ editor . core . db . search . IS@@ V@@ DB@@ Find@@ Name@@ Matcher ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public interface IS@@ V@@ DB@@ Decl@@ Cache { List < SV@@ DB@@ Decl@@ Cache@@ Item > find@@ Global@@ Scope@@ Decl ( I@@ ProgressMonitor monitor , String name , IS@@ V@@ DB@@ Find@@ Name@@ Matcher matcher ) ; Iterable < String > getFile@@ List ( I@@ ProgressMonitor monitor ) ; SV@@ DB@@ File find@@ File ( I@@ ProgressMonitor monitor , String filename ) ; SV@@ DB@@ File find@@ Pre@@ Proc@@ File ( I@@ ProgressMonitor monitor , String filename ) ; List < SV@@ DB@@ Decl@@ Cache@@ Item > find@@ Package@@ Decl ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item pk@@ g_@@ item ) ; SV@@ DB@@ File get@@ Decl@@ File ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item item ) ; SV@@ DB@@ File get@@ Decl@@ File@@ P@@ P ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item item ) ; List < SV@@ DB@@ Ref@@ Cache@@ Item > find@@ Reference@@ s ( I@@ ProgressMonitor monitor , String name , IS@@ V@@ DB@@ Ref@@ Matcher matcher ) ; } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . util . ArrayList ; import java . util . List ; public class SV@@ DB@@ Arg@@ File@@ Index@@ Cache@@ Data extends SV@@ DB@@ Base@@ Index@@ Cache@@ Data { public List < String > f@@ Arg@@ File@@ Paths ; public List < Long > f@@ Arg@@ File@@ Timestamp@@ s ; public SV@@ DB@@ Arg@@ File@@ Index@@ Cache@@ Data ( String base@@ _@@ location ) { super ( base@@ _@@ location ) ; f@@ Arg@@ File@@ Timestamp@@ s = new ArrayList < Long > ( ) ; f@@ Arg@@ File@@ Paths = new ArrayList < String > ( ) ; } public List < Long > get@@ Arg@@ File@@ Timestamp@@ s ( ) { return f@@ Arg@@ File@@ Timestamp@@ s ; } public List < String > get@@ Arg@@ File@@ Paths ( ) { return f@@ Arg@@ File@@ Paths ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . io . InputStream ; import java . util . List ; import java . util . Map . Entry ; import java . util . Set ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache ; import net . sf . sv@@ editor . core . scan@@ utils . I@@ Text@@ Scanner ; import net . sf . sv@@ editor . core . scan@@ utils . Input@@ Stream@@ Text@@ Scanner ; import net . sf . sv@@ editor . core . sv@@ f_@@ scanner . SV@@ F@@ Scanner ; import org . apache . tools . ant . filters . String@@ InputStream ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; import org . eclipse . core . runtime . Sub@@ ProgressMonitor ; public class SV@@ DB@@ Arg@@ File@@ Index extends Abstract@@ SV@@ DB@@ Index { private StringBuilder f@@ Arguments ; public SV@@ DB@@ Arg@@ File@@ Index ( String project , String root , IS@@ V@@ DB@@ File@@ System@@ Provider f@@ s_@@ provider , IS@@ V@@ DB@@ Index@@ Cache cache , SV@@ DB@@ Index@@ Config config ) { super ( project , root , f@@ s_@@ provider , cache , config ) ; f@@ In@@ Work@@ space@@ O@@ k = ( root . startsWith ( "" ) ) ; } public SV@@ DB@@ Arg@@ File@@ Index ( String project , String root , StringBuilder arguments , IS@@ V@@ DB@@ File@@ System@@ Provider f@@ s_@@ provider , IS@@ V@@ DB@@ Index@@ Cache cache , SV@@ DB@@ Index@@ Config config ) { super ( project , root , f@@ s_@@ provider , cache , config ) ; f@@ Arguments = arguments ; f@@ In@@ Work@@ space@@ O@@ k = ( root . startsWith ( "" ) ) ; } @ Override protected String get@@ Log@@ Name ( ) { return "" ; } public String getType@@ ID ( ) { return SV@@ DB@@ Arg@@ File@@ Index@@ Factory . TYPE ; } @ Override protected SV@@ DB@@ Base@@ Index@@ Cache@@ Data create@@ Index@@ Cache@@ Data ( ) { return new SV@@ DB@@ Arg@@ File@@ Index@@ Cache@@ Data ( getBase@@ Location ( ) ) ; } @ Override protected boolean check@@ Cache@@ Valid ( ) { SV@@ DB@@ Arg@@ File@@ Index@@ Cache@@ Data cd = ( SV@@ DB@@ Arg@@ File@@ Index@@ Cache@@ Data ) getC@@ ache@@ Data ( ) ; int i = 0 ; for ( String arg@@ _@@ file : cd . get@@ Arg@@ File@@ Paths ( ) ) { long ts = getFile@@ System@@ Provider ( ) . getLast@@ Modified@@ Time ( arg@@ _@@ file ) ; long t@@ s_@@ c = cd . get@@ Arg@@ File@@ Timestamp@@ s ( ) . get ( i ) ; if ( ts > t@@ s_@@ c ) { f@@ Log . debug ( "" + arg@@ _@@ file + " ts@@ =" + ts + " cached ts@@ =" + t@@ s_@@ c ) ; return false ; } i ++ ; } return super . check@@ Cache@@ Valid ( ) ; } @ Override protected void dis@@ cover@@ Root@@ Files ( I@@ ProgressMonitor monitor ) { f@@ Log . debug ( "" + getBase@@ Location ( ) ) ; clear@@ Files@@ List ( ) ; clear@@ Inclu@@ de@@ Paths ( ) ; clear@@ Defin@@ es ( ) ; monitor . begin@@ Task ( "" , 4 ) ; SV@@ DB@@ Arg@@ File@@ Index@@ Cache@@ Data cd = ( SV@@ DB@@ Arg@@ File@@ Index@@ Cache@@ Data ) getC@@ ache@@ Data ( ) ; cd . get@@ Arg@@ File@@ Timestamp@@ s ( ) . clear ( ) ; cd . get@@ Arg@@ File@@ Paths ( ) . clear ( ) ; add@@ Inclu@@ de@@ Path ( get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) ) ; process@@ Arg@@ File ( new Sub@@ ProgressMonitor ( monitor , 4 ) , get@@ Resol@@ ved@@ Base@@ Location ( ) ) ; monitor . done ( ) ; } private void process@@ Arg@@ File ( I@@ ProgressMonitor monitor , String path ) { InputStream in = null ; if ( f@@ Arguments != null ) { in = new String@@ InputStream ( f@@ Arguments . toString ( ) ) ; } else if ( getFile@@ System@@ Provider ( ) . file@@ Exists ( path ) ) { in = getFile@@ System@@ Provider ( ) . open@@ Stream ( path ) ; } else if ( getFile@@ System@@ Provider ( ) . file@@ Exists ( get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) + "/" + path ) ) { in = getFile@@ System@@ Provider ( ) . open@@ Stream ( get@@ Resol@@ ved@@ Base@@ Location@@ Dir ( ) + "/" + path ) ; } monitor . begin@@ Task ( "" + path , 4 ) ; if ( in != null ) { SV@@ DB@@ Arg@@ File@@ Index@@ Cache@@ Data cd = ( SV@@ DB@@ Arg@@ File@@ Index@@ Cache@@ Data ) getC@@ ache@@ Data ( ) ; cd . get@@ Arg@@ File@@ Paths ( ) . add ( path ) ; cd . get@@ Arg@@ File@@ Timestamp@@ s ( ) . add ( getFile@@ System@@ Provider ( ) . getLast@@ Modified@@ Time ( path ) ) ; I@@ Text@@ Scanner sc = new Input@@ Stream@@ Text@@ Scanner ( in , path ) ; SV@@ F@@ Scanner scanner = new SV@@ F@@ Scanner ( ) ; monitor . wor@@ ked ( 1 ) ; try { scanner . sc@@ an ( sc ) ; } catch ( Exception e ) { f@@ Log . error ( "" + get@@ Resol@@ ved@@ Base@@ Location ( ) + "\"" , e ) ; } monitor . wor@@ ked ( 1 ) ; for ( String f : scanner . getFile@@ Paths ( ) ) { String exp@@ _@@ f = SV@@ DB@@ Index@@ Util . expand@@ Vars ( f , f@@ Project@@ Name , f@@ In@@ Work@@ space@@ O@@ k ) ; f@@ Log . debug ( "[@@ FILE PAT@@ H@@ ] " + f + " (" + exp@@ _@@ f + ")" ) ; String res@@ _@@ f = resolve@@ Path ( exp@@ _@@ f , f@@ In@@ Work@@ space@@ O@@ k ) ; if ( getFile@@ System@@ Provider ( ) . file@@ Exists ( res@@ _@@ f ) ) { add@@ File ( res@@ _@@ f ) ; } else { f@@ Log . error ( "" + exp@@ _@@ f + "" ) ; } } for ( String lib@@ _@@ p : scanner . getL@@ ib@@ Paths ( ) ) { String exp@@ _@@ p = SV@@ DB@@ Index@@ Util . expand@@ Vars ( lib@@ _@@ p , f@@ Project@@ Name , f@@ In@@ Work@@ space@@ O@@ k ) ; f@@ Log . debug ( "[@@ LI@@ B PAT@@ H@@ ] " + lib@@ _@@ p + " (" + exp@@ _@@ p + ")" ) ; String res@@ _@@ p = resolve@@ Path ( exp@@ _@@ p , f@@ In@@ Work@@ space@@ O@@ k ) ; if ( getFile@@ System@@ Provider ( ) . is@@ Dir ( res@@ _@@ p ) ) { List < String > path@@ s = getFile@@ System@@ Provider ( ) . get@@ Files ( res@@ _@@ p ) ; Set < String > ext@@ s = scanner . getS@@ rc@@ Ex@@ ts ( ) ; for ( String file@@ _@@ p : path@@ s ) { int last@@ _@@ do@@ t = file@@ _@@ p . lastIndexOf ( '.' ) ; if ( last@@ _@@ do@@ t != - 1 ) { String ext = file@@ _@@ p . substring ( last@@ _@@ do@@ t ) ; if ( ext@@ s . contains ( ext ) ) { add@@ File ( file@@ _@@ p ) ; } } } } else { f@@ Log . error ( "" + exp@@ _@@ p + "" ) ; } } monitor . wor@@ ked ( 1 ) ; for ( String in@@ c : scanner . getIn@@ clu@@ de@@ Paths ( ) ) { String inc@@ _@@ path = SV@@ DB@@ Index@@ Util . expand@@ Vars ( in@@ c , f@@ Project@@ Name , f@@ In@@ Work@@ space@@ O@@ k ) ; f@@ Log . debug ( "[@@ IN@@ C PAT@@ H@@ ] " + in@@ c + " (" + inc@@ _@@ path + ")" ) ; add@@ Inclu@@ de@@ Path ( inc@@ _@@ path ) ; } monitor . wor@@ ked ( 1 ) ; for ( Entry < String , String > entry : scanner . get@@ Defin@@ e@@ Map ( ) . entrySet ( ) ) { f@@ Log . debug ( "[@@ DE@@ FIN@@ E@@ ] " + entry . getKey ( ) + "=" + entry . getValue ( ) ) ; add@@ Defin@@ e ( entry . getKey ( ) , entry . getValue ( ) ) ; } getFile@@ System@@ Provider ( ) . close@@ Stream ( in ) ; for ( String arg@@ _@@ file : scanner . get@@ Arg@@ File@@ Paths ( ) ) { arg@@ _@@ file = SV@@ DB@@ Index@@ Util . expand@@ Vars ( arg@@ _@@ file , f@@ Project@@ Name , f@@ In@@ Work@@ space@@ O@@ k ) ; if ( ! cd . get@@ Arg@@ File@@ Paths ( ) . contains ( arg@@ _@@ file ) ) { process@@ Arg@@ File ( new Sub@@ ProgressMonitor ( monitor , 4 ) , arg@@ _@@ file ) ; } } monitor . done ( ) ; } else { monitor . done ( ) ; f@@ Log . error ( "" + path + "\"" ) ; } } @ Override public void dispose ( ) { SV@@ DB@@ Arg@@ File@@ Index@@ Cache@@ Data cd = ( SV@@ DB@@ Arg@@ File@@ Index@@ Cache@@ Data ) getC@@ ache@@ Data ( ) ; cd . get@@ Arg@@ File@@ Timestamp@@ s ( ) . clear ( ) ; for ( String arg@@ _@@ file : cd . get@@ Arg@@ File@@ Paths ( ) ) { long ts = getFile@@ System@@ Provider ( ) . getLast@@ Modified@@ Time ( arg@@ _@@ file ) ; f@@ Log . debug ( "" + arg@@ _@@ file + "=" + ts ) ; cd . get@@ Arg@@ File@@ Timestamp@@ s ( ) . add ( ts ) ; } super . dispose ( ) ; } @ Override public void file@@ Changed ( String path ) { f@@ Log . debug ( "" + path ) ; if ( path . equals ( get@@ Resol@@ ved@@ Base@@ Location ( ) ) ) { in@@ validate@@ Index ( new Null@@ ProgressMonitor ( ) , "" + path , false ) ; } super . file@@ Changed ( path ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . util . ArrayList ; import java . util . List ; import java . util . Set ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . SV@@ FileUtils ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache ; import net . sf . sv@@ editor . core . files@@ et . Abstract@@ SV@@ File@@ Matcher ; import net . sf . sv@@ editor . core . job@@ _@@ m@@ gr . I@@ Job ; import net . sf . sv@@ editor . core . job@@ _@@ m@@ gr . I@@ Job@@ Mgr ; import net . sf . sv@@ editor . core . log . LogFactory ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public class SV@@ DB@@ Thread@@ ed@@ Source@@ Collection@@ Index extends Abstract@@ Thread@@ ed@@ SV@@ DB@@ Index { private List < Abstract@@ SV@@ File@@ Matcher > f@@ File@@ Match@@ er@@ List ; static { LogFactory . get@@ Log@@ Handle ( "" ) ; } public SV@@ DB@@ Thread@@ ed@@ Source@@ Collection@@ Index ( String project , String root , List < Abstract@@ SV@@ File@@ Matcher > match@@ er@@ _@@ list , IS@@ V@@ DB@@ File@@ System@@ Provider f@@ s_@@ provider , IS@@ V@@ DB@@ Index@@ Cache cache , SV@@ DB@@ Index@@ Config config ) { super ( project , root , f@@ s_@@ provider , cache , config ) ; f@@ File@@ Match@@ er@@ List = match@@ er@@ _@@ list ; } @ Override protected String get@@ Log@@ Name ( ) { return "" ; } @ Override protected boolean check@@ Cache@@ Valid ( ) { boolean valid = super . check@@ Cache@@ Valid ( ) ; if ( valid ) { for ( int i = 0 ; i < f@@ File@@ Match@@ er@@ List . size ( ) ; i ++ ) { Abstract@@ SV@@ File@@ Matcher matcher = f@@ File@@ Match@@ er@@ List . get ( i ) ; List < String > file@@ _@@ path@@ s = matcher . find@@ Inclu@@ ded@@ Paths ( ) ; Set < String > cache@@ _@@ files = getC@@ ache ( ) . getFile@@ List ( ) ; List < String > tmp@@ _c@@ ache@@ _@@ files = new ArrayList < String > ( ) ; tmp@@ _c@@ ache@@ _@@ files . addAll ( cache@@ _@@ files ) ; for ( String path : file@@ _@@ path@@ s ) { if ( cache@@ _@@ files . contains ( path ) ) { long f@@ s_@@ timestamp = getFile@@ System@@ Provider ( ) . getLast@@ Modified@@ Time ( path ) ; long cache@@ _@@ timestamp = getC@@ ache ( ) . getLast@@ Modified ( path ) ; if ( cache@@ _@@ timestamp < f@@ s_@@ timestamp ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path + ": file@@ =" + f@@ s_@@ timestamp + " cache@@ =" + cache@@ _@@ timestamp ) ; } valid = false ; break ; } tmp@@ _c@@ ache@@ _@@ files . remove ( path ) ; } else { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path ) ; } valid = false ; break ; } } if ( valid ) { for ( String path : tmp@@ _c@@ ache@@ _@@ files ) { if ( getFile@@ System@@ Provider ( ) . file@@ Exists ( path ) ) { long f@@ s_@@ timestamp = getFile@@ System@@ Provider ( ) . getLast@@ Modified@@ Time ( path ) ; long cache@@ _@@ timestamp = getC@@ ache ( ) . getLast@@ Modified ( path ) ; if ( cache@@ _@@ timestamp < f@@ s_@@ timestamp ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path + ": file@@ =" + f@@ s_@@ timestamp + " cache@@ =" + cache@@ _@@ timestamp ) ; } valid = false ; break ; } } else { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path ) ; } valid = false ; break ; } } } } } if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + ( ( valid ) ? "@@ valid@@ " : "@@ invalid@@ " ) ) ; } return valid ; } @ Override protected void dis@@ cover@@ Root@@ Files ( List < I@@ Job > job@@ s ) { I@@ Job@@ Mgr job@@ _@@ m@@ gr = SV@@ Core@@ Plugin . getJob@@ Mgr ( ) ; for ( int i = 0 ; i < f@@ File@@ Match@@ er@@ List . size ( ) ; i ++ ) { Abstract@@ SV@@ File@@ Matcher matcher = f@@ File@@ Match@@ er@@ List . get ( i ) ; List < String > file@@ _@@ path@@ s = matcher . find@@ Inclu@@ ded@@ Paths ( ) ; f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" ) ; for ( String path : file@@ _@@ path@@ s ) { I@@ Job job = job@@ _@@ m@@ gr . create@@ Job ( ) ; job . init ( path , new Dis@@ cover@@ Files@@ Job ( path ) ) ; job@@ s . add ( job ) ; job@@ _@@ m@@ gr . queue@@ Job ( job ) ; } } } private class Dis@@ cover@@ Files@@ Job implements Runnable { private String f@@ Path ; public Dis@@ cover@@ Files@@ Job ( String path ) { f@@ Path = path ; } public void run ( ) { String r@@ p = resolve@@ Path ( f@@ Path , f@@ In@@ Work@@ space@@ O@@ k ) ; f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + r@@ p + "\"" ) ; add@@ File ( r@@ p ) ; add@@ Inclu@@ de@@ Path ( SV@@ FileUtils . getPath@@ Parent ( r@@ p ) ) ; } } public String getType@@ ID ( ) { return SV@@ DB@@ Source@@ Collection@@ Index@@ Factory . TYPE ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . io . File ; public class SV@@ DB@@ Persistence@@ Descriptor { private File f@@ DB@@ File ; private String f@@ Base@@ Location ; public SV@@ DB@@ Persistence@@ Descriptor ( File file , String base@@ _@@ location ) { f@@ DB@@ File = file ; f@@ Base@@ Location = base@@ _@@ location ; } public File get@@ DB@@ File ( ) { return f@@ DB@@ File ; } public String getBase@@ Location ( ) { return f@@ Base@@ Location ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . io . InputStream ; import java . util . List ; import net . sf . sv@@ editor . core . Tuple ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Parent ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Named@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Marker ; import net . sf . sv@@ editor . core . db . index . cache . IS@@ V@@ DB@@ Index@@ Cache ; import net . sf . sv@@ editor . core . db . re@@ fs . IS@@ V@@ DB@@ Ref@@ Matcher ; import net . sf . sv@@ editor . core . db . re@@ fs . SV@@ DB@@ Ref@@ Cache@@ Item ; import net . sf . sv@@ editor . core . db . search . IS@@ V@@ DB@@ Find@@ Name@@ Matcher ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Search@@ Result ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; public class SV@@ DB@@ File@@ Overri@@ de@@ Index implements IS@@ V@@ DB@@ Index , IS@@ V@@ DB@@ Index@@ Iterator , I@@ Log@@ Level { private SV@@ DB@@ File f@@ File ; private SV@@ DB@@ File f@@ File@@ P@@ P ; private IS@@ V@@ DB@@ Index f@@ Index ; private IS@@ V@@ DB@@ Index@@ Iterator f@@ Super@@ Iterator ; private List < SV@@ DB@@ Marker > f@@ Mark@@ ers ; private Log@@ Handle f@@ Log ; public SV@@ DB@@ File@@ Overri@@ de@@ Index ( SV@@ DB@@ File file , SV@@ DB@@ File file@@ _p@@ p , IS@@ V@@ DB@@ Index index , IS@@ V@@ DB@@ Index@@ Iterator ite@@ m_@@ it , List < SV@@ DB@@ Marker > mark@@ ers ) { f@@ File = file ; f@@ File@@ P@@ P = file@@ _p@@ p ; f@@ Index = index ; f@@ Super@@ Iterator = ite@@ m_@@ it ; f@@ Mark@@ ers = mark@@ ers ; f@@ Log = LogFactory . get@@ Log@@ Handle ( getClass ( ) . getName ( ) ) ; } public void set@@ File ( SV@@ DB@@ File file ) { f@@ File = file ; } public void set@@ File@@ P@@ P ( SV@@ DB@@ File file ) { f@@ File@@ P@@ P = file ; } public IS@@ V@@ DB@@ Item@@ Iterator getItem@@ Iterator ( I@@ ProgressMonitor monitor ) { if ( f@@ Super@@ Iterator != null ) { IS@@ V@@ DB@@ Item@@ Iterator super@@ _@@ it = f@@ Super@@ Iterator . getItem@@ Iterator ( monitor ) ; if ( super@@ _@@ it instanceof SV@@ DB@@ Index@@ Collection@@ Item@@ Iterator ) { SV@@ DB@@ Index@@ Collection@@ Item@@ Iterator it = ( SV@@ DB@@ Index@@ Collection@@ Item@@ Iterator ) super@@ _@@ it ; it . set@@ Override ( f@@ Index , f@@ File ) ; return it ; } else { return super@@ _@@ it ; } } else { return SV@@ Empty@@ Item@@ Iterator ; } } private IS@@ V@@ DB@@ Item@@ Iterator SV@@ Empty@@ Item@@ Iterator = new IS@@ V@@ DB@@ Item@@ Iterator ( ) { public IS@@ V@@ DB@@ Item@@ Base next@@ Item ( SV@@ DB@@ Item@@ Type ... type@@ _@@ list ) { return null ; } public boolean hasNext ( SV@@ DB@@ Item@@ Type ... type@@ _@@ list ) { return false ; } } ; public List < SV@@ DB@@ Decl@@ Cache@@ Item > find@@ Global@@ Scope@@ Decl ( I@@ ProgressMonitor monitor , String name , IS@@ V@@ DB@@ Find@@ Name@@ Matcher matcher ) { List < SV@@ DB@@ Decl@@ Cache@@ Item > ret = f@@ Super@@ Iterator . find@@ Global@@ Scope@@ Decl ( monitor , name , matcher ) ; for ( int i = 0 ; i < ret . size ( ) ; i ++ ) { if ( ret . get ( i ) == null ) { System . out . println ( "@@ Element " + i + " is null@@ " ) ; } if ( ret . get ( i ) . getFile ( ) == null ) { System . out . println ( "@@ Element " + i + "" ) ; continue ; } else if ( ret . get ( i ) . getFile ( ) . getFile@@ Path ( ) == null ) { System . out . println ( "" + i + "" ) ; continue ; } if ( f@@ File == null ) { System . out . println ( "" ) ; } if ( f@@ File . getFile@@ Path ( ) == null ) { System . out . println ( "" ) ; } String file@@ path = ret . get ( i ) . getFile ( ) . getFile@@ Path ( ) ; String file@@ path@@ _@@ f = f@@ File . getFile@@ Path ( ) ; if ( file@@ path != null && file@@ path . equals ( file@@ path@@ _@@ f ) ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + ret . get ( i ) . getName ( ) + "" ) ; ret . remove ( i ) ; i -- ; } } find@@ Decl ( ret , f@@ File , name , matcher ) ; return ret ; } private void find@@ Decl ( List < SV@@ DB@@ Decl@@ Cache@@ Item > result , IS@@ V@@ DB@@ Child@@ Parent scope , String name , IS@@ V@@ DB@@ Find@@ Name@@ Matcher matcher ) { for ( IS@@ V@@ DB@@ Child@@ Item item : scope . getChildren ( ) ) { if ( item . getType ( ) . is@@ Elem@@ Of ( SV@@ DB@@ Item@@ Type . Package@@ Decl , SV@@ DB@@ Item@@ Type . Function , SV@@ DB@@ Item@@ Type . Task , SV@@ DB@@ Item@@ Type . Class@@ Decl , SV@@ DB@@ Item@@ Type . Module@@ Decl , SV@@ DB@@ Item@@ Type . Interface@@ Decl , SV@@ DB@@ Item@@ Type . Program@@ Decl , SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt , SV@@ DB@@ Item@@ Type . M@@ ac@@ ro@@ Def ) ) { if ( item instanceof IS@@ V@@ DB@@ Named@@ Item ) { boolean is_@@ ft = item . getType ( ) . is@@ Elem@@ Of ( SV@@ DB@@ Item@@ Type . M@@ ac@@ ro@@ Def ) ; IS@@ V@@ DB@@ Named@@ Item n@@ i = ( IS@@ V@@ DB@@ Named@@ Item ) item ; if ( matcher . match ( n@@ i , name ) ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "@@ Add item \"" + n@@ i . getName ( ) + "\" to result@@ " ) ; result . add ( new SV@@ DB@@ Decl@@ Cache@@ Item ( this , f@@ File . getFile@@ Path ( ) , n@@ i . getName ( ) , n@@ i . getType ( ) , is_@@ ft ) ) ; } } if ( item . getType ( ) == SV@@ DB@@ Item@@ Type . Package@@ Decl ) { find@@ Decl ( result , ( IS@@ V@@ DB@@ Child@@ Parent ) item , name , matcher ) ; } } else if ( item . getType ( ) == SV@@ DB@@ Item@@ Type . Pre@@ Proc@@ Con@@ d ) { find@@ Decl ( result , ( IS@@ V@@ DB@@ Child@@ Parent ) item , name , matcher ) ; } } } public List < SV@@ DB@@ Decl@@ Cache@@ Item > find@@ Package@@ Decl ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item pk@@ g_@@ item ) { return f@@ Super@@ Iterator . find@@ Package@@ Decl ( monitor , pk@@ g_@@ item ) ; } public SV@@ DB@@ File get@@ Decl@@ File ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item item ) { if ( item . get@@ Filename ( ) . equals ( f@@ File . getFile@@ Path ( ) ) ) { return f@@ File ; } else { return f@@ Super@@ Iterator . get@@ Decl@@ File ( monitor , item ) ; } } public SV@@ DB@@ File get@@ Decl@@ File@@ P@@ P ( I@@ ProgressMonitor monitor , SV@@ DB@@ Decl@@ Cache@@ Item item ) { if ( item . get@@ Filename ( ) . equals ( f@@ File . getFile@@ Path ( ) ) ) { return f@@ File ; } else { return f@@ Super@@ Iterator . get@@ Decl@@ File@@ P@@ P ( monitor , item ) ; } } public List < SV@@ DB@@ Ref@@ Cache@@ Item > find@@ Reference@@ s ( I@@ ProgressMonitor monitor , String name , IS@@ V@@ DB@@ Ref@@ Matcher matcher ) { return f@@ Super@@ Iterator . find@@ Reference@@ s ( monitor , name , matcher ) ; } public SV@@ DB@@ Search@@ Result < SV@@ DB@@ File > find@@ Inclu@@ ded@@ File ( String le@@ af ) { return f@@ Index . find@@ Inclu@@ ded@@ File ( le@@ af ) ; } public void init ( I@@ ProgressMonitor monitor ) { f@@ Index . init ( monitor ) ; } public Tuple < SV@@ DB@@ File , SV@@ DB@@ File > parse ( I@@ ProgressMonitor monitor , InputStream in , String path , List < SV@@ DB@@ Marker > mark@@ ers ) { return f@@ Index . parse ( monitor , in , path , mark@@ ers ) ; } public void set@@ Enable@@ Auto@@ Re@@ build ( boolean en ) { f@@ Index . set@@ Enable@@ Auto@@ Re@@ build ( en ) ; } public boolean is@@ Dir@@ ty ( ) { return f@@ Index . is@@ Dir@@ ty ( ) ; } public void dispose ( ) { f@@ Index . dispose ( ) ; } public String getBase@@ Location ( ) { return f@@ Index . getBase@@ Location ( ) ; } public String get@@ Project ( ) { return f@@ Index . get@@ Project ( ) ; } public void set@@ Global@@ Defin@@ e ( String key , String val ) { f@@ Index . set@@ Global@@ Defin@@ e ( key , val ) ; } public void clear@@ Global@@ Defin@@ es ( ) { f@@ Index . clear@@ Global@@ Defin@@ es ( ) ; } public String getType@@ ID ( ) { return f@@ Index . getType@@ ID ( ) ; } public void set@@ Inclu@@ de@@ File@@ Provider ( IS@@ V@@ DB@@ Inclu@@ de@@ File@@ Provider inc@@ _@@ provider ) { f@@ Index . set@@ Inclu@@ de@@ File@@ Provider ( inc@@ _@@ provider ) ; } public Iterable < String > getFile@@ List ( I@@ ProgressMonitor monitor ) { return f@@ Super@@ Iterator . getFile@@ List ( monitor ) ; } public SV@@ DB@@ File find@@ File ( I@@ ProgressMonitor monitor , String path ) { return find@@ File ( path ) ; } public SV@@ DB@@ File find@@ Pre@@ Proc@@ File ( I@@ ProgressMonitor monitor , String path ) { return find@@ Pre@@ Proc@@ File ( path ) ; } public List < SV@@ DB@@ Marker > getM@@ ar@@ k@@ ers ( String path ) { if ( f@@ File . getFile@@ Path ( ) . equals ( path ) ) { return f@@ Mark@@ ers ; } else { return f@@ Index . getM@@ ar@@ k@@ ers ( path ) ; } } public SV@@ DB@@ File find@@ File ( String path ) { if ( f@@ File . getFile@@ Path ( ) . equals ( path ) ) { return f@@ File ; } else { return f@@ Super@@ Iterator . find@@ File ( new Null@@ ProgressMonitor ( ) , path ) ; } } public SV@@ DB@@ File find@@ Pre@@ Proc@@ File ( String path ) { if ( f@@ File . getFile@@ Path ( ) . equals ( path ) ) { return f@@ File@@ P@@ P ; } else { return f@@ Super@@ Iterator . find@@ Pre@@ Proc@@ File ( new Null@@ ProgressMonitor ( ) , path ) ; } } public void re@@ build@@ Index ( I@@ ProgressMonitor monitor ) { f@@ Index . re@@ build@@ Index ( monitor ) ; } public void add@@ ChangeListener ( IS@@ V@@ DB@@ Index@@ ChangeListener l ) { f@@ Index . add@@ ChangeListener ( l ) ; } public void remove@@ ChangeListener ( IS@@ V@@ DB@@ Index@@ ChangeListener l ) { f@@ Index . remove@@ ChangeListener ( l ) ; } public IS@@ V@@ DB@@ Index@@ Cache getC@@ ache ( ) { return f@@ Index . getC@@ ache ( ) ; } public void load@@ Index ( I@@ ProgressMonitor monitor ) { f@@ Index . load@@ Index ( monitor ) ; } public boolean is@@ Loaded ( ) { return f@@ Index . is@@ Loaded ( ) ; } public boolean is@@ File@@ List@@ Loaded ( ) { return f@@ Index . is@@ File@@ List@@ Loaded ( ) ; } public SV@@ DB@@ Index@@ Config getConfig ( ) { return f@@ Index . getConfig ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db . index ; import java . lang . ref . Reference ; import java . lang . ref . W@@ eak@@ Reference ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; import org . eclipse . core . runtime . Sub@@ ProgressMonitor ; public class SV@@ DB@@ Index@@ Collection@@ Mgr { private List < Reference < SV@@ DB@@ Index@@ Collection > > f@@ Index@@ Collection@@ List ; private boolean f@@ Create@@ Sh@@ ad@@ ow@@ Index@@ es ; public SV@@ DB@@ Index@@ Collection@@ Mgr ( ) { f@@ Index@@ Collection@@ List = new ArrayList < Reference < SV@@ DB@@ Index@@ Collection > > ( ) ; } public void add@@ Index@@ Collection ( SV@@ DB@@ Index@@ Collection c ) { f@@ Index@@ Collection@@ List . add ( new W@@ eak@@ Reference < SV@@ DB@@ Index@@ Collection > ( c ) ) ; } public void set@@ Create@@ Sh@@ ad@@ ow@@ Index@@ es ( boolean create ) { boolean fir@@ e = ( f@@ Create@@ Sh@@ ad@@ ow@@ Index@@ es != create ) ; if ( fir@@ e ) { for ( int i = 0 ; i < f@@ Index@@ Collection@@ List . size ( ) ; i ++ ) { if ( f@@ Index@@ Collection@@ List . get ( i ) . get ( ) != null ) { f@@ Index@@ Collection@@ List . get ( i ) . get ( ) . sett@@ ing@@ s@@ Changed ( ) ; } else { f@@ Index@@ Collection@@ List . remove ( i ) ; i -- ; } } } f@@ Create@@ Sh@@ ad@@ ow@@ Index@@ es = create ; } public boolean getCre@@ ate@@ Sh@@ ad@@ ow@@ Index@@ es ( ) { return f@@ Create@@ Sh@@ ad@@ ow@@ Index@@ es ; } public void load@@ Index ( I@@ ProgressMonitor monitor ) { Sub@@ ProgressMonitor sm = new Sub@@ ProgressMonitor ( monitor , 1 ) ; synchronized ( f@@ Index@@ Collection@@ List ) { sm . begin@@ Task ( "@@ load@@ Index@@ " , f@@ Index@@ Collection@@ List . size ( ) ) ; for ( int i = 0 ; i < f@@ Index@@ Collection@@ List . size ( ) ; i ++ ) { if ( f@@ Index@@ Collection@@ List . get ( i ) . get ( ) == null ) { f@@ Index@@ Collection@@ List . remove ( i ) ; i -- ; } else { f@@ Index@@ Collection@@ List . get ( i ) . get ( ) . load@@ Index ( new Sub@@ ProgressMonitor ( sm , 1 ) ) ; } } } sm . done ( ) ; } } </s>
