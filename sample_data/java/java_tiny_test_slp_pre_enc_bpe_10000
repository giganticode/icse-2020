<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . dem@@ o ; import java . io . BufferedReader ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Cl@@ ar@@ a ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . Layout@@ In@@ fl@@ ater@@ Exception ; import com . vaadin . Application ; import com . vaadin . termin@@ al . Th@@ em@@ e@@ Resource ; import com . vaadin . ui . Button ; import com . vaadin . ui . Button . Click@@ Event ; import com . vaadin . ui . Component ; import com . vaadin . ui . Embed@@ ded ; import com . vaadin . ui . Horizontal@@ Layout ; import com . vaadin . ui . Horizontal@@ Split@@ Panel ; import com . vaadin . ui . TextArea ; import com . vaadin . ui . Vertical@@ Layout ; import com . vaadin . ui . Window ; import com . vaadin . ui . Window . Notification ; @ SuppressWarnings ( "@@ serial@@ " ) public class Demo@@ Application extends Application { private Demo@@ Controller controller ; private TextArea xml@@ Area ; private Horizontal@@ Split@@ Panel split = new Horizontal@@ Split@@ Panel ( ) ; private Window main@@ Window ; @ Override public void init ( ) { set@@ Th@@ eme ( "@@ cl@@ ar@@ a" ) ; set@@ Main@@ Window ( main@@ Window = new Window ( ) ) ; controller = new Demo@@ Controller ( main@@ Window ) ; main@@ Window . set@@ Content ( split ) ; Vertical@@ Layout editor = new Vertical@@ Layout ( ) ; editor . set@@ Spac@@ ing ( true ) ; editor . set@@ Margin ( false , false , false , true ) ; editor . set@@ Height ( "100@@ %@@ " ) ; editor . addComponent ( xml@@ Area = create@@ Xml@@ Area ( ) ) ; editor . set@@ Expand@@ Ratio ( xml@@ Area , 1.0f ) ; editor . addComponent ( create@@ Update@@ Button ( ) ) ; Horizontal@@ Layout wrapper = new Horizontal@@ Layout ( ) ; wrapper . set@@ Margin ( true ) ; wrapper . set@@ Size@@ F@@ ull ( ) ; wrapper . addComponent ( create@@ Log@@ o ( ) ) ; wrapper . addComponent ( editor ) ; wrapper . set@@ Expand@@ Ratio ( editor , 1.0f ) ; split . set@@ First@@ Component ( wrapper ) ; update@@ Layout ( ) ; } private Component create@@ Log@@ o ( ) { Embed@@ ded log@@ o = new Embed@@ ded ( null , new Th@@ em@@ e@@ Resource ( "" ) ) ; log@@ o . set@@ Height ( "@@ 9@@ 0@@ p@@ x" ) ; log@@ o . setWidth ( "@@ 9@@ 0@@ p@@ x" ) ; return log@@ o ; } private TextArea create@@ Xml@@ Area ( ) { TextArea area = new TextArea ( ) ; area . set@@ StyleName ( "@@ xml@@ -@@ area@@ " ) ; area . set@@ Size@@ F@@ ull ( ) ; area . setValue ( read@@ Start@@ ing@@ Point ( ) ) ; return area ; } private Button create@@ Update@@ Button ( ) { return new Button ( "@@ Update@@ " , new Button . ClickListener ( ) { public void button@@ Click ( Click@@ Event event ) { update@@ Layout ( ) ; } } ) ; } private String read@@ Start@@ ing@@ Point ( ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( getClass ( ) . getClassLoader ( ) . getResourceAsStream ( "" ) ) ) ; StringBuilder xml = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { xml . append ( line ) ; xml . append ( "n" ) ; } return xml . toString ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return null ; } private void update@@ Layout ( ) { try { Component c = Cl@@ ar@@ a . create ( new ByteArrayInputStream ( xml@@ Area . getValue ( ) . toString ( ) . getBytes ( ) ) , controller ) ; split . replace@@ Component ( split . getSec@@ ond@@ Component ( ) , c ) ; } catch ( Layout@@ In@@ fl@@ ater@@ Exception e ) { main@@ Window . show@@ Notification ( e . getMessage ( ) , Notification . TYPE_@@ ERROR_@@ MESSAGE ) ; } } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . dem@@ o ; import java . util . Date ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . DataSource ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . EventHandler ; import com . vaadin . data . Container ; import com . vaadin . data . Property ; import com . vaadin . data . Property . Value@@ ChangeEvent ; import com . vaadin . data . util . Indexed@@ Container ; import com . vaadin . data . util . Object@@ Property ; import com . vaadin . ui . Button . Click@@ Event ; import com . vaadin . ui . Window ; public class Demo@@ Controller { private Window window ; public Demo@@ Controller ( Window window ) { this . window = window ; } @ DataSource ( "@@ date@@ " ) public Property get@@ Date@@ Property ( ) { return new Object@@ Property < Date > ( new Date ( ) ) ; } @ DataSource ( "@@ person@@ -@@ list@@ " ) public Container get@@ Person@@ Container ( ) { Indexed@@ Container container = new Indexed@@ Container ( ) ; container . add@@ Container@@ Property ( "@@ Name" , String . class , "" ) ; container . add@@ Container@@ Property ( "A@@ ge@@ " , Integer . class , 0 ) ; Object item@@ Id = container . add@@ Item ( ) ; container . getItem ( item@@ Id ) . getItem@@ Property ( "@@ Name" ) . setValue ( "" ) ; container . getItem ( item@@ Id ) . getItem@@ Property ( "A@@ ge@@ " ) . setValue ( 32 ) ; item@@ Id = container . add@@ Item ( ) ; container . getItem ( item@@ Id ) . getItem@@ Property ( "@@ Name" ) . setValue ( "J@@ oh@@ n Sm@@ ith@@ " ) ; container . getItem ( item@@ Id ) . getItem@@ Property ( "A@@ ge@@ " ) . setValue ( 35 ) ; return container ; } @ EventHandler ( "@@ button@@ " ) public void handle@@ Button@@ Click ( Click@@ Event event ) { window . show@@ Notification ( "" ) ; } @ EventHandler ( "" ) public void handle@@ An@@ other@@ Button@@ Click ( Click@@ Event event ) { window . show@@ Notification ( "" ) ; } @ EventHandler ( "value@@ -@@ field@@ " ) public void s@@ ome@@ Value@@ Changed ( Value@@ ChangeEvent event ) { window . show@@ Notification ( "" + event . getProperty ( ) . getValue ( ) ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import org . junit . Before ; import org . junit . Test ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . Primitive@@ Attribute@@ Parser ; public class Primitive@@ Attribute@@ Parser@@ Test { private Primitive@@ Attribute@@ Parser handler ; @ Before public void setUp ( ) { handler = new Primitive@@ Attribute@@ Parser ( ) ; } @ Test public void test@@ Boolean ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Boolean . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Boolean . class ) ) ; assertEquals ( true , handler . getValue@@ A@@ s ( "true" , Boolean . TYPE ) ) ; assertEquals ( false , handler . getValue@@ A@@ s ( "false" , Boolean . TYPE ) ) ; assertEquals ( true , handler . getValue@@ A@@ s ( "true" , Boolean . class ) ) ; assertEquals ( false , handler . getValue@@ A@@ s ( "false" , Boolean . class ) ) ; } @ Test public void test@@ Integer ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Integer . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Integer . class ) ) ; assertEquals ( 10 , handler . getValue@@ A@@ s ( "@@ 10" , Integer . TYPE ) ) ; assertEquals ( - 10 , handler . getValue@@ A@@ s ( "-@@ 10" , Integer . TYPE ) ) ; assertEquals ( 20 , handler . getValue@@ A@@ s ( "@@ 20@@ " , Integer . class ) ) ; assertEquals ( - 20 , handler . getValue@@ A@@ s ( "-@@ 20@@ " , Integer . class ) ) ; } @ Test public void test@@ Byte ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Byte . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Byte . class ) ) ; assertEquals ( ( byte ) 10 , handler . getValue@@ A@@ s ( "@@ 10" , Byte . TYPE ) ) ; assertEquals ( ( byte ) - 10 , handler . getValue@@ A@@ s ( "-@@ 10" , Byte . TYPE ) ) ; assertEquals ( ( byte ) 20 , handler . getValue@@ A@@ s ( "@@ 20@@ " , Byte . class ) ) ; assertEquals ( ( byte ) - 20 , handler . getValue@@ A@@ s ( "-@@ 20@@ " , Byte . class ) ) ; } @ Test public void test@@ Short ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Short . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Short . class ) ) ; assertEquals ( ( short ) 10 , handler . getValue@@ A@@ s ( "@@ 10" , Short . TYPE ) ) ; assertEquals ( ( short ) - 10 , handler . getValue@@ A@@ s ( "-@@ 10" , Short . TYPE ) ) ; assertEquals ( ( short ) 20 , handler . getValue@@ A@@ s ( "@@ 20@@ " , Short . class ) ) ; assertEquals ( ( short ) - 20 , handler . getValue@@ A@@ s ( "-@@ 20@@ " , Short . class ) ) ; } @ Test public void test@@ Long ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Long . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Long . class ) ) ; assertEquals ( ( long ) 10 , handler . getValue@@ A@@ s ( "@@ 10" , Long . TYPE ) ) ; assertEquals ( ( long ) - 10 , handler . getValue@@ A@@ s ( "-@@ 10" , Long . TYPE ) ) ; assertEquals ( ( long ) 20 , handler . getValue@@ A@@ s ( "@@ 20@@ " , Long . class ) ) ; assertEquals ( ( long ) - 20 , handler . getValue@@ A@@ s ( "-@@ 20@@ " , Long . class ) ) ; } @ Test public void test@@ Character ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Character . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Character . class ) ) ; assertEquals ( 'a' , handler . getValue@@ A@@ s ( "a" , Character . TYPE ) ) ; assertEquals ( '@@ b@@ ' , handler . getValue@@ A@@ s ( "b" , Character . class ) ) ; } @ Test public void test@@ Float ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Float . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Float . class ) ) ; assertEquals ( 1.0f , handler . getValue@@ A@@ s ( "@@ 1.@@ 0" , Float . TYPE ) ) ; assertEquals ( 1.0f , handler . getValue@@ A@@ s ( "@@ 1.@@ 0" , Float . class ) ) ; } @ Test public void test@@ Double ( ) throws Exception { assertTrue ( handler . is@@ Supported ( Double . TYPE ) ) ; assertTrue ( handler . is@@ Supported ( Double . class ) ) ; assertEquals ( 2.0@@ d , handler . getValue@@ A@@ s ( "@@ 2.0@@ " , Double . TYPE ) ) ; assertEquals ( 2.0@@ d , handler . getValue@@ A@@ s ( "@@ 2.0@@ " , Double . class ) ) ; } @ Test public void test@@ String ( ) throws Exception { assertTrue ( handler . is@@ Supported ( String . class ) ) ; assertEquals ( "@@ Hel@@ l@@ o world@@ !" , handler . getValue@@ A@@ s ( "@@ Hel@@ l@@ o world@@ !" , String . class ) ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . util ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import org . junit . Test ; import com . vaadin . ui . Button ; public class Reflection@@ Util@@ s@@ Test { public static class Class@@ To@@ Ex@@ am@@ ine { public void set@@ Foo@@ Bar ( ) { } public void set@@ Foo@@ Bar ( String foo ) { } public void set@@ Foo@@ Bar ( int foo ) { } public void set@@ Foo@@ Bar ( String foo , int bar ) { } } @ Test public void test_@@ get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( ) { assertEquals ( 1 , Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class@@ To@@ Ex@@ am@@ ine . class , "@@ set@@ Foo@@ Bar@@ " , 0 ) . size ( ) ) ; assertEquals ( 2 , Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class@@ To@@ Ex@@ am@@ ine . class , "@@ set@@ Foo@@ Bar@@ " , 1 ) . size ( ) ) ; assertEquals ( 1 , Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class@@ To@@ Ex@@ am@@ ine . class , "@@ set@@ Foo@@ Bar@@ " , 2 ) . size ( ) ) ; assertEquals ( 0 , Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class@@ To@@ Ex@@ am@@ ine . class , "@@ set@@ Foo@@ Bar@@ " , 3 ) . size ( ) ) ; assertEquals ( 0 , Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class@@ To@@ Ex@@ am@@ ine . class , "" , 1 ) . size ( ) ) ; } @ Test public void test_@@ is@@ Component ( ) { assertTrue ( Reflection@@ Utils . is@@ Component ( Button . class ) ) ; assertFalse ( Reflection@@ Utils . is@@ Component ( Class@@ To@@ Ex@@ am@@ ine . class ) ) ; assertFalse ( Reflection@@ Utils . is@@ Component ( null ) ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import org . junit . Before ; import org . junit . Test ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . LayoutInflater ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . Layout@@ In@@ fl@@ ater@@ Exception ; import com . vaadin . ui . Button ; import com . vaadin . ui . Component ; import com . vaadin . ui . Vertical@@ Layout ; public class Layout@@ In@@ fl@@ ater@@ Test { private LayoutInflater in@@ flater ; @ Before public void setUp ( ) { in@@ flater = new LayoutInflater ( ) ; } private InputStream get@@ Xml ( String fileName ) { return getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; } @ Test public void in@@ fl@@ ate@@ _@@ single@@ Button@@ _@@ button@@ Instanti@@ ated ( ) { Button button = ( Button ) in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; assertEquals ( com . vaadin . ui . Button . class , button . getClass ( ) ) ; assertEquals ( "M@@ y Button@@ " , button . getCap@@ tion ( ) ) ; assertEquals ( true , button . is@@ ReadOnly ( ) ) ; } @ Test public void in@@ fl@@ ate@@ _@@ single@@ Button@@ No@@ Namespace@@ _@@ button@@ Instanti@@ ated ( ) { Component button = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; assertEquals ( com . vaadin . ui . Button . class , button . getClass ( ) ) ; assertEquals ( "M@@ y Button@@ " , button . getCap@@ tion ( ) ) ; assertEquals ( true , button . is@@ ReadOnly ( ) ) ; } @ Test public void in@@ fl@@ ate@@ _@@ single@@ Layout@@ _@@ layout@@ With@@ Marg@@ in@@ s@@ Instanti@@ ated ( ) { Component layout = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; assertEquals ( com . vaadin . ui . Vertical@@ Layout . class , layout . getClass ( ) ) ; assertTrue ( ( ( Vertical@@ Layout ) layout ) . getM@@ arg@@ in ( ) . has@@ Top ( ) ) ; assertFalse ( ( ( Vertical@@ Layout ) layout ) . getM@@ arg@@ in ( ) . has@@ Right ( ) ) ; assertFalse ( ( ( Vertical@@ Layout ) layout ) . getM@@ arg@@ in ( ) . has@@ Bottom ( ) ) ; assertTrue ( ( ( Vertical@@ Layout ) layout ) . getM@@ arg@@ in ( ) . has@@ Left ( ) ) ; } @ Test public void in@@ fl@@ ate@@ _@@ layout@@ Attributes@@ _@@ layout@@ Attributes@@ App@@ li@@ ed ( ) { Component layout = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; assertEquals ( com . vaadin . ui . Vertical@@ Layout . class , layout . getClass ( ) ) ; Vertical@@ Layout ver@@ tical@@ Layout = ( Vertical@@ Layout ) layout ; Component button = ver@@ tical@@ Layout . getComponent@@ Iterator ( ) . next ( ) ; assertEquals ( 1.0f , ver@@ tical@@ Layout . get@@ Expand@@ Ratio ( button ) , 0.0f ) ; } @ Test public void in@@ fl@@ ate@@ _@@ component@@ Has@@ Width@@ _@@ width@@ Attribute@@ App@@ li@@ ed ( ) { Component layout = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( layout , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( 200@@ .0f , button@@ 200@@ p@@ x . getWidth ( ) , 0.0f ) ; } @ Test public void in@@ fl@@ ate@@ _@@ add@@ Attribute@@ Interceptor@@ _@@ value@@ Intercep@@ ted@@ Cor@@ rect@@ ly ( ) { LayoutInflater intercep@@ ting@@ Inflater = new LayoutInflater ( ) ; Attribute@@ Interceptor interceptor = new Attribute@@ Interceptor ( ) { @ Override public void intercep@@ t ( Attribute@@ Context attribute@@ Context ) { if ( attribute@@ Context . getValue ( ) . getClass ( ) == String . class ) { String value = ( String ) attribute@@ Context . getValue ( ) ; if ( value . startsWith ( "{@@ i18@@ n@@ :" ) ) { attribute@@ Context . setValue ( "" ) ; } } try { attribute@@ Context . pro@@ ce@@ ed ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ; intercep@@ ting@@ Inflater . add@@ Interceptor ( interceptor ) ; Component intercep@@ ted@@ View = intercep@@ ting@@ Inflater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; Component view = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( intercep@@ ted@@ View , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( view , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "{@@ i18@@ n@@ :@@ test@@ }" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; } @ Test public void in@@ fl@@ ate@@ _@@ single@@ Button@@ _@@ findBy@@ Id@@ Work@@ s ( ) { Component view = in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; assertEquals ( com . vaadin . ui . Button . class , Cl@@ ar@@ a . find@@ Component@@ ById ( view , "@@ my@@ -@@ button@@ " ) . getClass ( ) ) ; assertEquals ( null , Cl@@ ar@@ a . find@@ Component@@ ById ( view , "" ) ) ; } @ Test ( expected = Layout@@ In@@ fl@@ ater@@ Exception . class ) public void in@@ fl@@ ate@@ _@@ non@@ Component@@ _@@ exception@@ Throw@@ n ( ) { in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; } @ Test ( expected = Layout@@ In@@ fl@@ ater@@ Exception . class ) public void in@@ fl@@ ate@@ _d@@ uplic@@ ate@@ Id_@@ exception@@ Throw@@ n ( ) { in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; } @ Test ( expected = Layout@@ In@@ fl@@ ater@@ Exception . class ) public void in@@ fl@@ ate@@ _@@ IO@@ Exception@@ _@@ exception@@ Throw@@ n ( ) { in@@ flater . in@@ fl@@ ate ( new InputStream ( ) { @ Override public int read ( ) throws IOException { throw new IOException ( ) ; } } ) ; } @ Test ( expected = Layout@@ In@@ fl@@ ater@@ Exception . class ) public void in@@ fl@@ ate@@ _@@ invalid@@ Xml@@ _@@ exception@@ Throw@@ n ( ) { in@@ flater . in@@ fl@@ ate ( new ByteArrayInputStream ( "" . getBytes ( ) ) ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import java . io . InputStream ; import org . junit . Before ; import org . junit . Test ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . EventHandler ; import com . vaadin . ui . Button ; import com . vaadin . ui . Component ; public class Cl@@ ar@@ a@@ Integration@@ Test { private InputStream xml ; private Controller controller ; private Attribute@@ Interceptor first@@ Interceptor ; private Attribute@@ Interceptor second@@ Interceptor ; public static class Controller { private boolean c@@ lic@@ ked ; @ EventHandler ( "@@ button@@ 200@@ p@@ x" ) public void c@@ lic@@ ked ( Button . Click@@ Event event ) { c@@ lic@@ ked = true ; } } @ Before public void setUp ( ) { xml = get@@ Xml ( "" ) ; controller = new Controller ( ) ; first@@ Interceptor = get@@ Interceptor ( ) ; second@@ Interceptor = getSec@@ ond@@ Interceptor ( ) ; } @ Test public void test@@ Create@@ Method@@ _@@ us@@ ing@@ All@@ Parameter@@ sWith@@ Two@@ Interceptor@@ s_@@ intercep@@ tor@@ s@@ And@@ Controller@@ Called ( ) { Component layout = Cl@@ ar@@ a . create ( xml , controller , first@@ Interceptor , second@@ Interceptor ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( layout , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; assertFalse ( controller . c@@ lic@@ ked ) ; button@@ 200@@ p@@ x . c@@ lick ( ) ; assertTrue ( controller . c@@ lic@@ ked ) ; } @ Test public void test@@ Create@@ Method@@ _@@ us@@ ing@@ All@@ Parameter@@ s_@@ intercep@@ tor@@ And@@ Controller@@ Called ( ) { Component layout = Cl@@ ar@@ a . create ( xml , controller , first@@ Interceptor ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( layout , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; assertFalse ( controller . c@@ lic@@ ked ) ; button@@ 200@@ p@@ x . c@@ lick ( ) ; assertTrue ( controller . c@@ lic@@ ked ) ; } @ Test public void test@@ Create@@ Method@@ _@@ us@@ ing@@ Only@@ Controller@@ _@@ controll@@ er@@ Called ( ) { Component layout = Cl@@ ar@@ a . create ( xml , controller ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( layout , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "{@@ i18@@ n@@ :@@ test@@ }" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; assertFalse ( controller . c@@ lic@@ ked ) ; button@@ 200@@ p@@ x . c@@ lick ( ) ; assertTrue ( controller . c@@ lic@@ ked ) ; } @ Test public void test@@ Create@@ Method@@ _@@ us@@ ing@@ No@@ Parameter@@ s_@@ component@@ In@@ fl@@ ated@@ Cor@@ rect@@ ly ( ) { Component layout = Cl@@ ar@@ a . create ( xml ) ; Button button@@ 200@@ p@@ x = ( Button ) Cl@@ ar@@ a . find@@ Component@@ ById ( layout , "@@ button@@ 200@@ p@@ x" ) ; assertEquals ( "{@@ i18@@ n@@ :@@ test@@ }" , button@@ 200@@ p@@ x . getCap@@ tion ( ) ) ; } private InputStream get@@ Xml ( String fileName ) { return getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; } public Attribute@@ Interceptor get@@ Interceptor ( ) { return new Attribute@@ Interceptor ( ) { @ Override public void intercep@@ t ( Attribute@@ Context attribute@@ Context ) { if ( attribute@@ Context . getValue ( ) . getClass ( ) == String . class ) { String value = ( String ) attribute@@ Context . getValue ( ) ; if ( value . startsWith ( "{@@ i18@@ n@@ :" ) ) { attribute@@ Context . setValue ( "" ) ; } } try { attribute@@ Context . pro@@ ce@@ ed ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ; } public Attribute@@ Interceptor getSec@@ ond@@ Interceptor ( ) { return new Attribute@@ Interceptor ( ) { @ Override public void intercep@@ t ( Attribute@@ Context attribute@@ Context ) { if ( attribute@@ Context . getValue ( ) . getClass ( ) == String . class ) { String value = ( String ) attribute@@ Context . getValue ( ) ; if ( value . startsWith ( "" ) ) { attribute@@ Context . setValue ( "" ) ; } } try { attribute@@ Context . pro@@ ce@@ ed ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . util . Date ; import org . junit . Before ; import org . junit . Test ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . Binder ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . DataSource ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . EventHandler ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . LayoutInflater ; import com . vaadin . data . Property ; import com . vaadin . ui . Button ; import com . vaadin . ui . Button . Click@@ Event ; import com . vaadin . ui . Date@@ Field ; public class Bin@@ der@@ Test { private LayoutInflater in@@ flater ; private boolean c@@ lick@@ Called ; @ Before public void setUp ( ) { in@@ flater = new LayoutInflater ( ) ; } private InputStream get@@ Xml ( String fileName ) { return getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; } @ EventHandler ( "@@ my@@ -@@ button@@ " ) public void handle@@ Button@@ Click ( Click@@ Event event ) { c@@ lick@@ Called = true ; } @ DataSource ( "@@ my@@ -@@ date@@ field@@ " ) public Property get@@ DataSource ( ) { Date date = new Date ( 13@@ 37@@ 33@@ 7@@ 47@@ 7@@ 57@@ 8@@ L ) ; return new com . vaadin . data . util . Object@@ Property < Date > ( date ) ; } @ Test public void bin@@ d_@@ c@@ lick@@ Listener@@ _c@@ lick@@ Listener@@ Invo@@ ked ( ) { Button button = ( Button ) in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; Binder bin@@ der = new Binder ( ) ; bin@@ der . bind ( button , this ) ; c@@ lick@@ Called = false ; si@@ mul@@ ate@@ Button@@ Click ( button ) ; assertTrue ( "" , c@@ lick@@ Called ) ; } @ Test public void bin@@ d_@@ data@@ Source@@ _@@ data@@ Source@@ Attach@@ ed ( ) { Date@@ Field view = ( Date@@ Field ) in@@ flater . in@@ fl@@ ate ( get@@ Xml ( "" ) ) ; Binder bin@@ der = new Binder ( ) ; bin@@ der . bind ( view , this ) ; Date value = ( Date ) view . getValue ( ) ; assertEquals ( 13@@ 37@@ 33@@ 7@@ 47@@ 7@@ 57@@ 8@@ L , value . getTime ( ) ) ; } private void si@@ mul@@ ate@@ Button@@ Click ( Button button ) { Method fire@@ Click ; try { fire@@ Click = Button . class . getDeclared@@ Method ( "@@ fire@@ Click@@ " ) ; fire@@ Click . set@@ Accessible ( true ) ; fire@@ Click . invoke ( button ) ; } catch ( Exception e ) { throw new RuntimeException ( "" , e ) ; } } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import com . vaadin . ui . Component ; public interface Attribute@@ Interceptor { void intercep@@ t ( Attribute@@ Context invo@@ cation@@ Context ) ; } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import java . lang . reflect . Method ; public abstract class Attribute@@ Context { private Object value ; private Method set@@ ter ; public Attribute@@ Context ( Method set@@ ter , Object value ) { this . value = value ; this . set@@ ter = set@@ ter ; } public abstract void pro@@ ce@@ ed ( ) throws Exception ; public Object getValue ( ) { return value ; } public void setValue ( Object value ) { this . value = value ; } public Method get@@ Set@@ ter ( ) { return set@@ ter ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der ; import java . lang . reflect . Invocation@@ Handler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . Set ; import java . util . logging . Logger ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Cl@@ ar@@ a ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . DataSource ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation . EventHandler ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . util . Reflection@@ Utils ; import com . vaadin . data . Container ; import com . vaadin . data . Item ; import com . vaadin . data . Property ; import com . vaadin . ui . Component ; public class Binder { protected Logger getLogger ( ) { return Logger . getLogger ( Binder . class . getName ( ) ) ; } public void bind ( Component component@@ Root , Object controller ) { Method [ ] methods = controller . getClass ( ) . get@@ Methods ( ) ; for ( Method method : methods ) { if ( method . is@@ Annotation@@ Present ( DataSource . class ) ) { bind@@ DataSource ( component@@ Root , controller , method , method . get@@ Annotation ( DataSource . class ) ) ; } if ( method . is@@ Annotation@@ Present ( EventHandler . class ) ) { bind@@ EventHandler ( component@@ Root , controller , method , method . get@@ Annotation ( EventHandler . class ) ) ; } } } private void bind@@ EventHandler ( Component component@@ Root , Object controller , Method method , EventHandler event@@ Listener ) { String component@@ Id = event@@ Listener . value ( ) ; Component component = Cl@@ ar@@ a . find@@ Component@@ ById ( component@@ Root , component@@ Id ) ; Class < ? > event@@ Class = ( method . getParameter@@ Types ( ) . length > 0 ? method . getParameter@@ Types ( ) [ 0 ] : null ) ; if ( event@@ Class != null && component != null ) { Method add@@ Listener@@ Method = get@@ Add@@ Listener@@ Method ( component . getClass ( ) , event@@ Class ) ; if ( add@@ Listener@@ Method != null ) { try { Object listener = create@@ Listener@@ Proxy ( add@@ Listener@@ Method . getParameter@@ Types ( ) [ 0 ] , event@@ Class , method , controller ) ; add@@ Listener@@ Method . invoke ( component , listener ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } } } private Object create@@ Listener@@ Proxy ( Class < ? > listener@@ Class , final Class < ? > event@@ Class , final Method listener@@ Method , final Object controller ) { Object proxy = Proxy . new@@ Proxy@@ Instance ( listener@@ Class . getClassLoader ( ) , new Class < ? > [ ] { listener@@ Class } , new Invocation@@ Handler ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( args != null && args . length > 0 && event@@ Class . isAssignableFrom ( args [ 0 ] . getClass ( ) ) ) { getLogger ( ) . fin@@ e ( String . format ( "" , method . getName ( ) , listener@@ Method . getName ( ) ) ) ; return listener@@ Method . invoke ( controller , args ) ; } getLogger ( ) . fin@@ e ( String . format ( "" , method . getName ( ) , controller . getClass ( ) ) ) ; return method . invoke ( controller , args ) ; } } ) ; getLogger ( ) . fin@@ e ( String . format ( "" , listener@@ Class ) ) ; return proxy ; } private Method get@@ Add@@ Listener@@ Method ( Class < ? extends Component > component@@ Class , Class < ? > event@@ Class ) { Set < Method > methods = Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( component@@ Class , "@@ add@@ Listener@@ " , 1 ) ; for ( Method method : methods ) { Class < ? > listener@@ Class = method . getParameter@@ Types ( ) [ 0 ] ; Method [ ] listener@@ Methods = listener@@ Class . get@@ Methods ( ) ; for ( Method listener@@ Method : listener@@ Methods ) { if ( listener@@ Method . getParameter@@ Types ( ) . length == 1 && listener@@ Method . getParameter@@ Types ( ) [ 0 ] . equals ( event@@ Class ) ) { return method ; } } } return null ; } private void bind@@ DataSource ( Component component@@ Root , Object controller , Method method , DataSource dataSource ) { String component@@ Id = dataSource . value ( ) ; Component component = Cl@@ ar@@ a . find@@ Component@@ ById ( component@@ Root , component@@ Id ) ; Class < ? > data@@ Source@@ Class = method . get@@ ReturnType ( ) ; try { if ( is@@ Container ( data@@ Source@@ Class ) && component instanceof Container . Viewer ) { ( ( Container . Viewer ) component ) . set@@ Container@@ DataSource ( ( Container ) method . invoke ( controller ) ) ; } else if ( is@@ Property ( data@@ Source@@ Class ) && component instanceof Property . Viewer ) { ( ( Property . Viewer ) component ) . set@@ Property@@ DataSource ( ( Property ) method . invoke ( controller ) ) ; } else if ( is@@ Item ( data@@ Source@@ Class ) && component instanceof Item . Viewer ) { ( ( Item . Viewer ) component ) . set@@ Item@@ DataSource ( ( Item ) method . invoke ( controller ) ) ; } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } private boolean is@@ Container ( Class < ? > data@@ Source@@ Class ) { return Container . class . isAssignableFrom ( data@@ Source@@ Class ) ; } private boolean is@@ Item ( Class < ? > data@@ Source@@ Class ) { return Item . class . isAssignableFrom ( data@@ Source@@ Class ) ; } private boolean is@@ Property ( Class < ? > data@@ Source@@ Class ) { return Property . class . isAssignableFrom ( data@@ Source@@ Class ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import com . vaadin . ui . Button ; import com . vaadin . ui . Button . Click@@ Event ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD ) public @ interface EventHandler { String value ( ) ; } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import com . vaadin . data . Container ; import com . vaadin . data . Item ; import com . vaadin . data . Property ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD ) public @ interface DataSource { String value ( ) ; } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . util ; import java . lang . reflect . Method ; import java . util . HashSet ; import java . util . Set ; import com . vaadin . ui . Component ; public class Reflection@@ Utils { private Reflection@@ Utils ( ) { throw new Assertion@@ Error ( ) ; } public static Set < Method > get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( Class < ? > clazz , String methodName , int numberOf@@ Params ) { Set < Method > methods = new HashSet < Method > ( ) ; for ( Method method : clazz . get@@ Methods ( ) ) { if ( method . getName ( ) . equals ( methodName ) && method . getParameter@@ Types ( ) . length == numberOf@@ Params ) { methods . add ( method ) ; } } return methods ; } public static boolean is@@ Component ( Class < ? > component@@ Class ) { if ( component@@ Class != null ) { return Component . class . isAssignableFrom ( component@@ Class ) ; } else { return false ; } } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a ; import java . io . InputStream ; import java . util . Iterator ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . bin@@ der . Binder ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater . LayoutInflater ; import com . vaadin . ui . Component ; import com . vaadin . ui . Component@@ Container ; public class Cl@@ ar@@ a { public static Component create ( InputStream xml ) { return create ( xml , null ) ; } public static Component create ( InputStream xml , Object controller , Attribute@@ Interceptor ... intercep@@ tors ) { LayoutInflater in@@ flater = new LayoutInflater ( ) ; if ( intercep@@ tors != null ) { for ( Attribute@@ Interceptor interceptor : intercep@@ tors ) { in@@ flater . add@@ Interceptor ( interceptor ) ; } } Component result = in@@ flater . in@@ fl@@ ate ( xml ) ; if ( controller != null ) { Binder bin@@ der = new Binder ( ) ; bin@@ der . bind ( result , controller ) ; } return result ; } public static Component find@@ Component@@ ById ( Component root , String component@@ Id ) { if ( component@@ Id == null ) { throw new IllegalArgumentException ( "" ) ; } if ( component@@ Id . equals ( root . get@@ Debug@@ Id ( ) ) ) { return root ; } else if ( root instanceof Component@@ Container ) { for ( Iterator < Component > i = ( ( Component@@ Container ) root ) . getComponent@@ Iterator ( ) ; i . hasNext ( ) ; ) { Component c = find@@ Component@@ ById ( i . next ( ) , component@@ Id ) ; if ( c != null ) { return c ; } } } return null ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; public interface Attribute@@ Parser { boolean is@@ Supported ( Class < ? > value@@ Type ) ; Object getValue@@ A@@ s ( String value , Class < ? > value@@ Type ) ; } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . util . HashMap ; import java . util . Map ; import java . util . Stack ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helper@@ s . Default@@ Handler ; import com . vaadin . ui . Component ; import com . vaadin . ui . Component@@ Container ; class Layout@@ In@@ fl@@ ater@@ Content@@ Handler extends Default@@ Handler { private static final String UR@@ N_@@ NAMESP@@ ACE_@@ ID = "@@ package@@ " ; private static final String DEFAULT_@@ NAMESPACE = "@@ urn@@ :" + UR@@ N_@@ NAMESP@@ ACE_@@ ID + "" ; private static final String LAY@@ OUT_@@ ATTRIBUTE_@@ NAMESPACE = "" ; private Stack < Component > component@@ Stack = new Stack < Component > ( ) ; private Component@@ Container current@@ Container ; private Component current@@ Component ; private Component root ; private final Component@@ Manager component@@ Factory ; private final Map < String , Component > id@@ Map = new HashMap < String , Component > ( ) ; public Layout@@ In@@ fl@@ ater@@ Content@@ Handler ( Component@@ Manager component@@ Factory ) { this . component@@ Factory = component@@ Factory ; } public Component getRoot ( ) { return root ; } @ Override public void start@@ Element ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { super . start@@ Element ( uri , localName , qName , attributes ) ; if ( uri == null || uri . length ( ) == 0 ) { uri = DEFAULT_@@ NAMESPACE ; } current@@ Component = null ; if ( uri . startsWith ( "@@ urn@@ :" + UR@@ N_@@ NAMESP@@ ACE_@@ ID + ":" ) ) { String package@@ Name = uri . substring ( ( "@@ urn@@ :" + UR@@ N_@@ NAMESP@@ ACE_@@ ID + ":" ) . length ( ) ) ; String className = localName ; Map < String , String > attribute@@ Map = getAttribute@@ Map ( attributes ) ; Map < String , String > layout@@ Attribute@@ Map = get@@ Layout@@ Attribute@@ Map ( attributes ) ; current@@ Component = component@@ Factory . create@@ Component ( package@@ Name , className , attribute@@ Map ) ; if ( current@@ Component . get@@ Debug@@ Id ( ) != null ) { id@@ Map . put ( current@@ Component . get@@ Debug@@ Id ( ) , current@@ Component ) ; } if ( root == null ) { root = current@@ Component ; } if ( current@@ Container != null ) { current@@ Container . addComponent ( current@@ Component ) ; component@@ Factory . apply@@ Layout@@ Attributes ( current@@ Container , current@@ Component , layout@@ Attribute@@ Map ) ; } if ( current@@ Component instanceof Component@@ Container ) { current@@ Container = ( Component@@ Container ) current@@ Component ; } component@@ Stack . push ( current@@ Component ) ; } } private Map < String , String > getAttribute@@ Map ( Attributes attributes ) { Map < String , String > attribute@@ Map = new HashMap < String , String > ( attributes . getLength ( ) ) ; for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { if ( ! attributes . getURI ( i ) . equals ( LAY@@ OUT_@@ ATTRIBUTE_@@ NAMESPACE ) ) { String value = attributes . getValue ( i ) ; String name = attributes . getLocalName ( i ) ; if ( name . equals ( "id" ) ) { if ( id@@ Map . containsKey ( value ) ) { throw new Layout@@ In@@ fl@@ ater@@ Exception ( String . format ( "" , value ) ) ; } name = "@@ debug@@ Id" ; } attribute@@ Map . put ( name , value ) ; } } return attribute@@ Map ; } private Map < String , String > get@@ Layout@@ Attribute@@ Map ( Attributes attributes ) { Map < String , String > attribute@@ Map = new HashMap < String , String > ( attributes . getLength ( ) ) ; for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { if ( attributes . getURI ( i ) . equals ( LAY@@ OUT_@@ ATTRIBUTE_@@ NAMESPACE ) ) { String value = attributes . getValue ( i ) ; String name = attributes . getLocalName ( i ) ; attribute@@ Map . put ( name , value ) ; } } return attribute@@ Map ; } @ Override public void end@@ Element ( String uri , String localName , String qName ) throws SAXException { super . end@@ Element ( uri , localName , qName ) ; Component component = component@@ Stack . pop ( ) ; if ( component instanceof Component@@ Container ) { current@@ Container = ( Component@@ Container ) component . getParent ( ) ; } } public Map < String , Component > get@@ Id@@ Map ( ) { return id@@ Map ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . logging . Logger ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Attribute@@ Context ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Attribute@@ Interceptor ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . util . Reflection@@ Utils ; import com . vaadin . ui . Component ; import com . vaadin . ui . Component@@ Container ; public class Default@@ Component@@ Manager implements Component@@ Manager { private List < Attribute@@ Parser > attribute@@ Parser@@ s = new ArrayList < Attribute@@ Parser > ( ) ; private List < Attribute@@ Interceptor > intercep@@ tors = new ArrayList < Attribute@@ Interceptor > ( ) ; private Logger getLogger ( ) { return Logger . getLogger ( Default@@ Component@@ Manager . class . getName ( ) ) ; } public Default@@ Component@@ Manager ( ) { add@@ Attribute@@ Parser ( new Primitive@@ Attribute@@ Parser ( ) ) ; add@@ Attribute@@ Parser ( new V@@ aad@@ in@@ Attribute@@ Parser ( ) ) ; } public void add@@ Attribute@@ Parser ( Attribute@@ Parser handler ) { attribute@@ Parser@@ s . add ( handler ) ; } public void remove@@ Attribute@@ Parser ( Attribute@@ Parser handler ) { attribute@@ Parser@@ s . remove ( handler ) ; } public Component create@@ Component ( String namespace , String name , Map < String , String > attributes ) throws Component@@ Instanti@@ ationException { try { Class < ? extends Component > component@@ Class = resolve@@ Component@@ Class ( namespace , name ) ; Component new@@ Component = component@@ Class . newInstance ( ) ; handle@@ Attributes ( new@@ Component , attributes ) ; return new@@ Component ; } catch ( Exception e ) { throw create@@ Exception ( e , namespace , name ) ; } } protected Component@@ Instanti@@ ationException create@@ Exception ( Exception e , String namespace , String name ) { String message = String . format ( "" , namespace , name ) ; if ( e != null ) { return new Component@@ Instanti@@ ationException ( message , e ) ; } else { return new Component@@ Instanti@@ ationException ( message ) ; } } @ SuppressWarnings ( "unchecked" ) protected Class < ? extends Component > resolve@@ Component@@ Class ( String namespace , String name ) throws ClassNotFoundException { String quali@@ fied@@ ClassName = namespace + "." + name ; Class < ? > component@@ Class = null ; component@@ Class = Class . forName ( quali@@ fied@@ ClassName ) ; if ( Reflection@@ Utils . is@@ Component ( component@@ Class ) ) { return ( Class < ? extends Component > ) component@@ Class ; } else { throw new IllegalArgumentException ( String . format ( "" , component@@ Class . getName ( ) , Component . class . getName ( ) ) ) ; } } protected void handle@@ Attributes ( Component component , Map < String , String > attributes ) { getLogger ( ) . fin@@ e ( attributes . toString ( ) ) ; try { for ( Map . Entry < String , String > attribute : attributes . entrySet ( ) ) { Method set@@ ter = get@@ Set@@ ter ( attribute . getKey ( ) , component . getClass ( ) ) ; if ( set@@ ter != null ) { Attribute@@ Parser handler = get@@ Handler@@ For ( set@@ ter . getParameter@@ Types ( ) [ 0 ] ) ; if ( handler != null ) { String attribute@@ Value = attribute . getValue ( ) ; if ( attribute@@ Value == null || attribute@@ Value . length ( ) == 0 ) { invoke@@ With@@ Intercep@@ tors ( set@@ ter , component , attribute@@ Value ) ; } else { invoke@@ With@@ Intercep@@ tors ( set@@ ter , component , handler . getValue@@ A@@ s ( attribute@@ Value , set@@ ter . getParameter@@ Types ( ) [ 0 ] ) ) ; } } } } } catch ( SecurityException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } protected void invoke@@ With@@ Intercep@@ tors ( final Method method@@ To@@ Invo@@ ke , final Object obj , final Object ... args ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { if ( intercep@@ tors . isEmpty ( ) ) { method@@ To@@ Invo@@ ke . invoke ( obj , args ) ; } else { final LinkedList < Attribute@@ Interceptor > intercep@@ tor@@ s@@ Copy = new LinkedList < Attribute@@ Interceptor > ( intercep@@ tors ) ; Attribute@@ Interceptor interceptor = intercep@@ tor@@ s@@ Copy . pop ( ) ; interceptor . intercep@@ t ( new Attribute@@ Context ( method@@ To@@ Invo@@ ke , args . length > 1 ? args [ 1 ] : args [ 0 ] ) { @ Override public void pro@@ ce@@ ed ( ) throws Exception { if ( intercep@@ tor@@ s@@ Copy . size ( ) > 0 ) { intercep@@ tor@@ s@@ Copy . pop ( ) . intercep@@ t ( this ) ; } else { if ( args . length > 1 ) { method@@ To@@ Invo@@ ke . invoke ( obj , args [ 0 ] , this . getValue ( ) ) ; } else { method@@ To@@ Invo@@ ke . invoke ( obj , this . getValue ( ) ) ; } } } } ) ; } } protected Attribute@@ Parser get@@ Handler@@ For ( Class < ? > type ) { for ( Attribute@@ Parser handler : attribute@@ Parser@@ s ) { if ( handler . is@@ Supported ( type ) ) { return handler ; } } return null ; } public void apply@@ Layout@@ Attributes ( Component@@ Container container , Component component , Map < String , String > attributes ) { if ( ! component . getParent ( ) . equals ( container ) ) { throw new IllegalStateException ( "" ) ; } try { for ( Map . Entry < String , String > attribute : attributes . entrySet ( ) ) { Method layout@@ Method = get@@ Layout@@ Method ( container . getClass ( ) , attribute . getKey ( ) ) ; if ( layout@@ Method != null ) { Attribute@@ Parser handler = get@@ Handler@@ For ( layout@@ Method . getParameter@@ Types ( ) [ 1 ] ) ; if ( handler != null ) { invoke@@ With@@ Intercep@@ tors ( layout@@ Method , container , component , handler . getValue@@ A@@ s ( attribute . getValue ( ) , layout@@ Method . getParameter@@ Types ( ) [ 1 ] ) ) ; } } } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } private Method get@@ Set@@ ter ( String propertyName , Class < ? extends Component > component@@ Class ) { Set < Method > write@@ Methods = Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( component@@ Class , "@@ set@@ " + cap@@ it@@ alize ( propertyName ) , 1 ) ; return select@@ Preferred@@ Method ( write@@ Methods , 0 ) ; } private static String cap@@ it@@ alize ( String propertyName ) { if ( propertyName . length ( ) > 0 ) { return propertyName . substring ( 0 , 1 ) . toUpperCase ( ) + propertyName . substring ( 1 ) ; } return "" ; } private Method get@@ Layout@@ Method ( Class < ? extends Component@@ Container > layout@@ Class , String propertyName ) { String method@@ To@@ Look@@ For = "@@ set@@ " + propertyName . substring ( 0 , 1 ) . toUpperCase ( ) + propertyName . substring ( 1 ) ; Set < Method > set@@ ter@@ sWith@@ Two@@ Params = Reflection@@ Utils . get@@ Method@@ sBy@@ Name@@ And@@ Param@@ Count ( layout@@ Class , method@@ To@@ Look@@ For , 2 ) ; return select@@ Preferred@@ Method ( set@@ ter@@ sWith@@ Two@@ Params , 1 ) ; } private Method select@@ Preferred@@ Method ( Set < Method > methods , int data@@ Param@@ Index ) { Method candid@@ ate = null ; for ( Method method : methods ) { if ( data@@ Param@@ Index > 0 && ! Reflection@@ Utils . is@@ Component ( method . getParameter@@ Types ( ) [ 0 ] ) ) { continue ; } Class < ? > parameter@@ Type = method . getParameter@@ Types ( ) [ data@@ Param@@ Index ] ; Attribute@@ Parser handler = get@@ Handler@@ For ( parameter@@ Type ) ; if ( handler != null && ! ( handler instanceof Primitive@@ Attribute@@ Parser ) ) { return method ; } if ( method . is@@ Annotation@@ Present ( Deprecated . class ) || ! parameter@@ Type . equals ( String . class ) ) { candid@@ ate = method ; } else { return method ; } } return candid@@ ate ; } @ Override public void add@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) { intercep@@ tors . add ( attribute@@ Interceptor ) ; } @ Override public void remove@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) { intercep@@ tors . remove ( attribute@@ Interceptor ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; @ SuppressWarnings ( "@@ serial@@ " ) public class Layout@@ In@@ fl@@ ater@@ Exception extends RuntimeException { public Layout@@ In@@ fl@@ ater@@ Exception ( String message ) { super ( message ) ; } public Layout@@ In@@ fl@@ ater@@ Exception ( String message , Throwable e ) { super ( message , e ) ; } public Layout@@ In@@ fl@@ ater@@ Exception ( Throwable e ) { super ( e ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; @ SuppressWarnings ( "@@ serial@@ " ) public class Component@@ Instanti@@ ationException extends RuntimeException { public Component@@ Instanti@@ ationException ( ) { super ( ) ; } public Component@@ Instanti@@ ationException ( String message ) { super ( message ) ; } public Component@@ Instanti@@ ationException ( String message , Throwable e ) { super ( message , e ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . util . Arrays ; import java . util . List ; public class Primitive@@ Attribute@@ Parser implements Attribute@@ Parser { @ SuppressWarnings ( "unchecked" ) private static final List < Class < ? > > supported@@ Classes = Arrays . asList ( String . class , Object . class , Boolean . class , Integer . class , Byte . class , Short . class , Long . class , Character . class , Float . class , Double . class ) ; public boolean is@@ Supported ( Class < ? > value@@ Type ) { return value@@ Type != null && ( value@@ Type . is@@ Primitive ( ) || supported@@ Classes . contains ( value@@ Type ) ) ; } public Object getValue@@ A@@ s ( String value , Class < ? > type ) { if ( type == String . class || type == Object . class ) { return value ; } if ( type == Boolean . TYPE || type == Boolean . class ) { return Boolean . valueOf ( value ) ; } if ( type == Integer . TYPE || type == Integer . class ) { return Integer . valueOf ( value ) ; } if ( type == Byte . TYPE || type == Byte . class ) { return Byte . valueOf ( value ) ; } if ( type == Short . TYPE || type == Short . class ) { return Short . valueOf ( value ) ; } if ( type == Long . TYPE || type == Long . class ) { return Long . valueOf ( value ) ; } if ( type == Character . TYPE || type == Character . class ) { return value . charAt ( 0 ) ; } if ( type == Float . TYPE || type == Float . class ) { return Float . valueOf ( value ) ; } if ( type == Double . TYPE || type == Double . class ) { return Double . valueOf ( value ) ; } return null ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Attribute@@ Interceptor ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XML@@ Reader ; import org . xml . sax . helper@@ s . XML@@ Reader@@ Factory ; import com . vaadin . Application ; import com . vaadin . service . ApplicationContext ; import com . vaadin . ui . Component ; public class LayoutInflater { private Component@@ Manager component@@ Manager = new Default@@ Component@@ Manager ( ) ; public void set@@ Component@@ Manager ( Component@@ Manager component@@ Manager ) { this . component@@ Manager = component@@ Manager ; } public Component in@@ fl@@ ate ( Application app , String xml@@ File ) throws Layout@@ In@@ fl@@ ater@@ Exception { File layout@@ File = get@@ Layout@@ File ( app . getContext ( ) , xml@@ File ) ; try { return in@@ fl@@ ate ( new FileInputStream ( layout@@ File ) ) ; } catch ( FileNotFoundException e ) { throw new Layout@@ In@@ fl@@ ater@@ Exception ( "G@@ ive@@ n file " + layout@@ File . getAbsolutePath ( ) + "" ) ; } } public Component in@@ fl@@ ate ( InputStream xml ) throws Layout@@ In@@ fl@@ ater@@ Exception { try { Layout@@ In@@ fl@@ ater@@ Content@@ Handler handler = new Layout@@ In@@ fl@@ ater@@ Content@@ Handler ( component@@ Manager ) ; XML@@ Reader parser = XML@@ Reader@@ Factory . create@@ XML@@ Reader ( ) ; parser . setContent@@ Handler ( handler ) ; parser . parse ( new InputSource ( xml ) ) ; return handler . getRoot ( ) ; } catch ( SAXException e ) { throw new Layout@@ In@@ fl@@ ater@@ Exception ( e ) ; } catch ( IOException e ) { throw new Layout@@ In@@ fl@@ ater@@ Exception ( e ) ; } catch ( Component@@ Instanti@@ ationException e ) { throw new Layout@@ In@@ fl@@ ater@@ Exception ( e . getMessage ( ) , e ) ; } } public void add@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) { component@@ Manager . add@@ Interceptor ( attribute@@ Interceptor ) ; } public void remove@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) { component@@ Manager . remove@@ Interceptor ( attribute@@ Interceptor ) ; } private static File get@@ Layout@@ File ( ApplicationContext context , String file@@ path ) { return new File ( context . getBase@@ Directory ( ) . getAbsolute@@ File ( ) + File . separator + "@@ V@@ A@@ AD@@ IN@@ " + File . separator + "@@ layout@@ s" + File . separator + file@@ path ) ; } } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . util . Map ; import org . vaadin . te@@ em@@ u . cl@@ ar@@ a . Attribute@@ Interceptor ; import com . vaadin . ui . Component ; import com . vaadin . ui . Component@@ Container ; public interface Component@@ Manager { Component create@@ Component ( String namespace , String name , Map < String , String > attributes ) throws Component@@ Instanti@@ ationException ; void apply@@ Layout@@ Attributes ( Component@@ Container container , Component component , Map < String , String > attributes ) ; void add@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) ; void remove@@ Interceptor ( Attribute@@ Interceptor attribute@@ Interceptor ) ; } </s>
<s> package org . vaadin . te@@ em@@ u . cl@@ ar@@ a . in@@ flater ; import java . util . HashMap ; import java . util . Map ; import com . vaadin . ui . Alignment ; import com . vaadin . ui . Layout . Marg@@ in@@ Info ; public class V@@ aad@@ in@@ Attribute@@ Parser implements Attribute@@ Parser { protected static final Map < String , Alignment > align@@ ment@@ Map ; static { align@@ ment@@ Map = new HashMap < String , Alignment > ( ) ; align@@ ment@@ Map . put ( "" , Alignment . BO@@ T@@ TO@@ M_@@ CENTER ) ; align@@ ment@@ Map . put ( "@@ BO@@ T@@ TO@@ M_@@ LEF@@ T" , Alignment . BO@@ T@@ TO@@ M_@@ LEFT ) ; align@@ ment@@ Map . put ( "@@ BO@@ T@@ TO@@ M_@@ R@@ IG@@ HT@@ " , Alignment . BO@@ T@@ TO@@ M_@@ RIGHT ) ; align@@ ment@@ Map . put ( "" , Alignment . M@@ ID@@ D@@ LE_@@ CENTER ) ; align@@ ment@@ Map . put ( "M@@ ID@@ D@@ LE_@@ LEF@@ T" , Alignment . M@@ ID@@ D@@ LE_@@ LEFT ) ; align@@ ment@@ Map . put ( "M@@ ID@@ D@@ LE_@@ R@@ IG@@ HT@@ " , Alignment . M@@ ID@@ D@@ LE_@@ RIGHT ) ; align@@ ment@@ Map . put ( "@@ TO@@ P_@@ CEN@@ TER@@ " , Alignment . TO@@ P_@@ CENTER ) ; align@@ ment@@ Map . put ( "@@ TO@@ P_@@ LEF@@ T" , Alignment . TO@@ P_@@ LEFT ) ; align@@ ment@@ Map . put ( "@@ TO@@ P_@@ R@@ IG@@ HT@@ " , Alignment . TO@@ P_@@ RIGHT ) ; } public boolean is@@ Supported ( Class < ? > value@@ Type ) { return value@@ Type != null && ( value@@ Type == Marg@@ in@@ Info . class || value@@ Type == Alignment . class ) ; } public Object getValue@@ A@@ s ( String value , Class < ? > value@@ Type ) { if ( value@@ Type == Marg@@ in@@ Info . class ) { return parse@@ Marg@@ in@@ Info ( value ) ; } else if ( value@@ Type == Alignment . class ) { return parse@@ Alignment ( value ) ; } return null ; } private Object parse@@ Alignment ( String value ) { return align@@ ment@@ Map . get ( value ) ; } protected Marg@@ in@@ Info parse@@ Marg@@ in@@ Info ( String marg@@ in ) { if ( marg@@ in . length ( ) > 4 ) { String [ ] marg@@ ins = marg@@ in . split ( " " ) ; if ( marg@@ ins . length == 4 ) { return new Marg@@ in@@ Info ( Boolean . valueOf ( marg@@ ins [ 0 ] ) , Boolean . valueOf ( marg@@ ins [ 1 ] ) , Boolean . valueOf ( marg@@ ins [ 2 ] ) , Boolean . valueOf ( marg@@ ins [ 3 ] ) ) ; } } return new Marg@@ in@@ Info ( Boolean . valueOf ( marg@@ in ) ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import org . osgi . framework . Bundle ; public class Plugin@@ In@@ Stream@@ Provider implements IT@@ emp@@ late@@ In@@ Stream@@ Provider { Bundle f@@ Bundle ; public Plugin@@ In@@ Stream@@ Provider ( Bundle bundle ) { f@@ Bundle = bundle ; } public InputStream open@@ Stream ( String path ) { URL url = f@@ Bundle . get@@ Entry ( path ) ; InputStream in = null ; if ( url != null ) { try { in = url . open@@ Stream ( ) ; } catch ( IOException e ) { } } return in ; } public void close@@ Stream ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . util . List ; public interface I@@ External@@ Template@@ Path@@ Provider { List < String > get@@ External@@ Template@@ Path ( ) ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class Template@@ F@@ S@@ File@@ Creator implements IT@@ emp@@ late@@ File@@ Creator { private File f@@ Root ; public Template@@ F@@ S@@ File@@ Creator ( File root ) { f@@ Root = root ; } public void create@@ File ( String path , InputStream content ) { File file = new File ( f@@ Root , path ) ; byte tmp [ ] = new byte [ 16@@ 38@@ 4 ] ; int len ; if ( ! file . getParent@@ File ( ) . exists ( ) ) { file . getParent@@ File ( ) . mk@@ dirs ( ) ; } try { FileOutputStream fos = new FileOutputStream ( file ) ; while ( ( len = content . read ( tmp , 0 , tmp . length ) ) > 0 ) { fos . write ( tmp , 0 , len ) ; } fos . close ( ) ; } catch ( IOException e ) { } } public OutputStream open@@ Stream ( String path ) { File target = new File ( f@@ Root , path ) ; try { return new FileOutputStream ( target ) ; } catch ( IOException e ) { } return null ; } public void close@@ Stream ( OutputStream out ) { try { out . close ( ) ; } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . File ; import java . io . InputStream ; import java . util . List ; public abstract class Abstract@@ External@@ Template@@ Finder extends Abstract@@ Template@@ Finder { private IT@@ emp@@ late@@ In@@ Stream@@ Provider f@@ In@@ Provider ; public Abstract@@ External@@ Template@@ Finder ( IT@@ emp@@ late@@ In@@ Stream@@ Provider in_@@ provider ) { super ( ) ; f@@ In@@ Provider = in_@@ provider ; } @ Override public void find ( ) { List < String > path@@ s = find@@ Template@@ Paths ( ) ; for ( String path : path@@ s ) { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + path ) ; InputStream in = open@@ File ( path ) ; File tmp@@ l@@ _@@ dir = new File ( path ) . getParent@@ File ( ) ; if ( in == null ) { f@@ Log . error ( "" + path + "\"" ) ; continue ; } SV@@ T@@ Parser p = new SV@@ T@@ Parser ( tmp@@ l@@ _@@ dir . getPath ( ) , f@@ In@@ Provider ) ; try { p . parse ( in ) ; } catch ( Exception e ) { f@@ Log . error ( "" + path + "\@@ ": " + e . getMessage ( ) , e ) ; } for ( Template@@ Category c : p . getC@@ ateg@@ ories ( ) ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + c . getId ( ) + " name@@ =" + c . getName ( ) ) ; } f@@ Categ@@ ories . addAll ( p . getC@@ ateg@@ ories ( ) ) ; for ( Template@@ Info t@@ i : p . get@@ Template@@ s ( ) ) { f@@ Template@@ s . add ( t@@ i ) ; f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + t@@ i . getId ( ) + " name@@ =" + t@@ i . getName ( ) ) ; if ( ! t@@ i . get@@ Template@@ s ( ) . iterator ( ) . hasNext ( ) ) { List < String > files = list@@ Files ( tmp@@ l@@ _@@ dir . getPath ( ) ) ; for ( String file : files ) { File f = new File ( file ) ; if ( ! f . getName ( ) . endsWith ( ".@@ sv@@ t" ) && ! f . getName ( ) . startsWith ( "." ) ) { File fn = new File ( file ) ; t@@ i . add@@ Template ( file , fn . getName ( ) ) ; } } } } close@@ Stream ( in ) ; } } protected abstract List < String > find@@ Template@@ Paths ( ) ; protected abstract List < String > list@@ Files ( String path ) ; protected abstract InputStream open@@ File ( String path ) ; protected abstract void close@@ Stream ( InputStream in ) ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . InputStream ; public interface IT@@ emp@@ late@@ File@@ Creator { void create@@ File ( String path , InputStream content ) ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . log . LogFactory ; public class F@@ S@@ External@@ Template@@ Finder extends Abstract@@ External@@ Template@@ Finder { private File f@@ Path ; public F@@ S@@ External@@ Template@@ Finder ( File path ) { super ( new F@@ S@@ In@@ Stream@@ Provider ( ) ) ; f@@ Path = path ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; } @ Override protected List < String > find@@ Template@@ Paths ( ) { List < String > template@@ _@@ path@@ s = new ArrayList < String > ( ) ; find@@ Template@@ Paths ( template@@ _@@ path@@ s , f@@ Path ) ; return template@@ _@@ path@@ s ; } private void find@@ Template@@ Paths ( List < String > path@@ s , File path ) { File files [ ] = path . list@@ Files ( ) ; if ( files != null ) { for ( File file : files ) { if ( file . isDirectory ( ) ) { find@@ Template@@ Paths ( path@@ s , file ) ; } else if ( file . getName ( ) . endsWith ( ".@@ sv@@ t" ) ) { path@@ s . add ( file . getAbsolutePath ( ) ) ; } } } } @ Override protected List < String > list@@ Files ( String path ) { File file = new File ( path ) ; List < String > ret = new ArrayList < String > ( ) ; if ( file . isDirectory ( ) ) { File files [ ] = file . list@@ Files ( ) ; if ( files != null ) { for ( File f : files ) { if ( f . is@@ File ( ) ) { ret . add ( f . getAbsolutePath ( ) ) ; } } } } return ret ; } @ Override protected InputStream open@@ File ( String path ) { InputStream in = null ; try { in = new FileInputStream ( path ) ; } catch ( IOException e ) { } return in ; } @ Override protected void close@@ Stream ( InputStream in ) { try { if ( in != null ) { in . close ( ) ; } } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . InputStream ; public interface IT@@ emp@@ late@@ In@@ Stream@@ Provider { InputStream open@@ Stream ( String path ) ; void close@@ Stream ( InputStream in ) ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . xml . sax . Error@@ Handler ; import org . xml . sax . SAXException ; import org . xml . sax . SAX@@ ParseException ; public class SV@@ T@@ Parser { private Document f@@ Document ; private List < Template@@ Info > f@@ Template@@ s ; private List < Template@@ Category > f@@ Categ@@ ories ; private Log@@ Handle f@@ Log ; private IT@@ emp@@ late@@ In@@ Stream@@ Provider f@@ In@@ Provider ; private String f@@ Template@@ Base ; public SV@@ T@@ Parser ( String template@@ _@@ base , IT@@ emp@@ late@@ In@@ Stream@@ Provider in_@@ provider ) { f@@ Template@@ s = new ArrayList < Template@@ Info > ( ) ; f@@ Categ@@ ories = new ArrayList < Template@@ Category > ( ) ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "S@@ V@@ T@@ Parser@@ " ) ; f@@ In@@ Provider = in_@@ provider ; f@@ Template@@ Base = template@@ _@@ base ; } public void parse ( InputStream in ) throws Exception { DocumentBuilderFactory f = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder b = f . new@@ DocumentBuilder ( ) ; f@@ Template@@ s . clear ( ) ; f@@ Categ@@ ories . clear ( ) ; b . set@@ Error@@ Handler ( f@@ Error@@ Handler ) ; f@@ Document = b . parse ( in ) ; NodeList s@@ v_@@ template@@ _@@ list = f@@ Document . getElementsBy@@ TagName ( "s@@ v_@@ template@@ " ) ; if ( s@@ v_@@ template@@ _@@ list . getLength ( ) == 0 ) { return ; } Element s@@ v_@@ template = ( Element ) s@@ v_@@ template@@ _@@ list . item ( 0 ) ; NodeList category@@ _@@ list = s@@ v_@@ template . getElementsBy@@ TagName ( "c@@ ateg@@ ory@@ " ) ; for ( int i = 0 ; i < category@@ _@@ list . getLength ( ) ; i ++ ) { add@@ Category ( ( Element ) category@@ _@@ list . item ( i ) ) ; } NodeList template@@ _@@ list = s@@ v_@@ template . getElementsBy@@ TagName ( "@@ template@@ " ) ; for ( int i = 0 ; i < template@@ _@@ list . getLength ( ) ; i ++ ) { add@@ Template ( ( Element ) template@@ _@@ list . item ( i ) ) ; } } public List < Template@@ Category > getC@@ ateg@@ ories ( ) { return f@@ Categ@@ ories ; } public List < Template@@ Info > get@@ Template@@ s ( ) { return f@@ Template@@ s ; } private void add@@ Category ( Element category ) { String name = category . getAttribute ( "name" ) ; String id = category . getAttribute ( "id" ) ; String parent = category . getAttribute ( "@@ parent@@ " ) ; if ( parent == null ) { parent = "" ; } Template@@ Category c = new Template@@ Category ( id , name , parent ) ; NodeList d@@ l = category . getElementsBy@@ TagName ( "@@ descrip@@ tion" ) ; if ( d@@ l . getLength ( ) > 0 ) { Element desc = ( Element ) d@@ l . item ( 0 ) ; c . setDescription ( desc . getText@@ Content ( ) ) ; } if ( ! f@@ Categ@@ ories . contains ( c ) ) { f@@ Categ@@ ories . add ( c ) ; } } private void add@@ Template ( Element template ) { String name = template . getAttribute ( "name" ) ; String id = template . getAttribute ( "id" ) ; String category = template . getAttribute ( "c@@ ateg@@ ory@@ " ) ; Template@@ Info t = new Template@@ Info ( id , name , category , "" , f@@ In@@ Provider ) ; NodeList description = template . getElementsBy@@ TagName ( "@@ descrip@@ tion" ) ; if ( description . getLength ( ) > 0 ) { Element e = ( Element ) description . item ( 0 ) ; t . setDescription ( e . getText@@ Content ( ) ) ; } NodeList files = template . getElementsBy@@ TagName ( "@@ fil@@ es" ) ; if ( files . getLength ( ) > 0 ) { Element e = ( Element ) files . item ( 0 ) ; NodeList file@@ _@@ list = e . getElementsBy@@ TagName ( "file@@ " ) ; for ( int i = 0 ; i < file@@ _@@ list . getLength ( ) ; i ++ ) { Element file = ( Element ) file@@ _@@ list . item ( i ) ; String filename = file . getAttribute ( "name" ) ; String tmp@@ l@@ _@@ path = file . getAttribute ( "@@ template@@ " ) ; filename = filename . trim ( ) ; tmp@@ l@@ _@@ path = tmp@@ l@@ _@@ path . trim ( ) ; t . add@@ Template ( f@@ Template@@ Base + "/" + tmp@@ l@@ _@@ path , filename ) ; } } NodeList parameters = template . getElementsBy@@ TagName ( "parameter@@ s" ) ; if ( parameters . getLength ( ) > 0 ) { Element e = ( Element ) parameters . item ( 0 ) ; NodeList parameter@@ s_@@ list = e . getElementsBy@@ TagName ( "parameter@@ " ) ; for ( int i = 0 ; i < parameter@@ s_@@ list . getLength ( ) ; i ++ ) { Element parameter = ( Element ) parameter@@ s_@@ list . item ( i ) ; Template@@ Parameter@@ Type p@@ _type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Id ; String p@@ _name = parameter . getAttribute ( "name" ) ; String p_@@ type@@ _@@ s = parameter . getAttribute ( "type" ) ; String p@@ _d@@ fl@@ t = parameter . getAttribute ( "@@ default@@ " ) ; String p_@@ ext = parameter . getAttribute ( "@@ ext@@ end@@ s_@@ from@@ " ) ; String p_@@ res@@ tr = parameter . getAttribute ( "@@ res@@ tr@@ iction@@ s" ) ; if ( p_@@ type@@ _@@ s . equals ( "@@ class@@ " ) ) { p@@ _type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Class ; } else if ( p_@@ type@@ _@@ s . equals ( "id" ) ) { p@@ _type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Id ; } else if ( p_@@ type@@ _@@ s . equals ( "@@ int@@ " ) ) { p@@ _type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Int ; } Template@@ Parameter p = new Template@@ Parameter ( p@@ _type , p@@ _name , p@@ _d@@ fl@@ t , p_@@ ext ) ; if ( p_@@ res@@ tr != null && ! p_@@ res@@ tr . trim ( ) . equals ( "" ) ) { String res@@ tr [ ] = p_@@ res@@ tr . split ( "," ) ; for ( String r : res@@ tr ) { r = r . trim ( ) ; p . add@@ Value ( r ) ; } } t . add@@ Parameter ( p ) ; } } f@@ Template@@ s . add ( t ) ; } private Error@@ Handler f@@ Error@@ Handler = new Error@@ Handler ( ) { public void error ( SAX@@ ParseException arg0 ) throws SAXException { throw arg0 ; } public void f@@ at@@ al@@ Error ( SAX@@ ParseException arg0 ) throws SAXException { throw arg0 ; } public void warn@@ ing ( SAX@@ ParseException arg0 ) throws SAXException { } } ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; public class F@@ S@@ In@@ Stream@@ Provider implements IT@@ emp@@ late@@ In@@ Stream@@ Provider { public InputStream open@@ Stream ( String path ) { File file = new File ( path ) ; InputStream in = null ; try { in = new FileInputStream ( file ) ; } catch ( IOException e ) { } return in ; } public void close@@ Stream ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . log . LogFactory ; import org . eclipse . core . resources . I@@ Container ; import org . eclipse . core . resources . I@@ File ; import org . eclipse . core . resources . I@@ Resource ; import org . eclipse . core . resources . I@@ Work@@ space@@ Root ; import org . eclipse . core . resources . Resources@@ Plugin ; import org . eclipse . core . runtime . Core@@ Exception ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; import org . eclipse . core . runtime . Path ; public class WS@@ External@@ Template@@ Finder extends Abstract@@ External@@ Template@@ Finder { private I@@ Container f@@ Path ; public WS@@ External@@ Template@@ Finder ( I@@ Container path ) { super ( new WS@@ In@@ Stream@@ Provider ( ) ) ; f@@ Path = path ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; } @ Override protected List < String > find@@ Template@@ Paths ( ) { List < String > template@@ s = new ArrayList < String > ( ) ; find@@ Template@@ Paths ( template@@ s , f@@ Path ) ; return template@@ s ; } private void find@@ Template@@ Paths ( List < String > template@@ s , I@@ Container parent ) { I@@ Resource resources [ ] = null ; try { resources = parent . mem@@ bers ( ) ; } catch ( Core@@ Exception e ) { } if ( resources != null ) { for ( I@@ Resource r : resources ) { if ( r instanceof I@@ File && r . getName ( ) . endsWith ( ".@@ sv@@ t" ) ) { template@@ s . add ( ( ( I@@ File ) r ) . getFull@@ Path ( ) . to@@ O@@ S@@ String ( ) ) ; } else if ( r instanceof I@@ Container ) { find@@ Template@@ Paths ( template@@ s , ( I@@ Container ) r ) ; } } } } @ Override protected List < String > list@@ Files ( String path ) { List < String > files = new ArrayList < String > ( ) ; I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ Container c = null ; try { c = root . get@@ Folder ( new Path ( path ) ) ; } catch ( IllegalArgumentException e ) { } if ( c == null ) { if ( path . startsWith ( "/" ) ) { String p@@ name = path . substring ( 1 ) ; try { c = root . get@@ Project ( p@@ name ) ; } catch ( IllegalArgumentException e ) { } } } if ( c != null ) { I@@ Resource resources [ ] = null ; try { resources = c . mem@@ bers ( ) ; } catch ( Core@@ Exception e ) { } if ( resources != null ) { for ( I@@ Resource r : resources ) { if ( r instanceof I@@ File ) { files . add ( ( ( I@@ File ) r ) . getFull@@ Path ( ) . to@@ O@@ S@@ String ( ) ) ; } } } } return files ; } @ Override protected InputStream open@@ File ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; InputStream in = null ; I@@ File file = root . getFile ( new Path ( path ) ) ; if ( file . exists ( ) ) { for ( int i = 0 ; i < 2 ; i ++ ) { try { in = file . get@@ Contents ( ) ; break ; } catch ( Core@@ Exception e ) { f@@ Log . error ( "" + path + "\@@ ": " + e . getMessage ( ) , e ) ; if ( e . getMessage ( ) . contains ( "@@ out of syn@@ c" ) ) { try { file . getParent ( ) . refresh@@ Local ( I@@ Resource . DE@@ P@@ TH_@@ INF@@ IN@@ ITE , new Null@@ ProgressMonitor ( ) ) ; } catch ( Core@@ Exception e2 ) { } } } } } else { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "@@ File \"" + path + "" ) ; } return in ; } @ Override protected void close@@ Stream ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . IOException ; import java . io . InputStream ; import org . eclipse . core . resources . I@@ File ; import org . eclipse . core . resources . I@@ Work@@ space@@ Root ; import org . eclipse . core . resources . Resources@@ Plugin ; import org . eclipse . core . runtime . Core@@ Exception ; import org . eclipse . core . runtime . Path ; public class WS@@ In@@ Stream@@ Provider implements IT@@ emp@@ late@@ In@@ Stream@@ Provider { public InputStream open@@ Stream ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; InputStream in = null ; try { I@@ File file = root . getFile ( new Path ( path ) ) ; if ( file . exists ( ) ) { in = file . get@@ Contents ( ) ; } } catch ( Core@@ Exception e ) { } return in ; } public void close@@ Stream ( InputStream in ) { try { in . close ( ) ; } catch ( IOException e ) { } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Set ; public class Dynamic@@ Template@@ Parameter@@ Provider implements IT@@ emp@@ late@@ Parameter@@ Provider { public boolean pro@@ vi@@ des@@ Parameter ( String id ) { return ( id . equals ( "@@ date@@ " ) || id . equals ( "user@@ " ) ) ; } public String getParameter@@ Value ( String id , String arg ) { if ( id . equals ( "user@@ " ) ) { return System . getProperty ( "user@@ .@@ name" ) ; } else if ( id . equals ( "@@ date@@ " ) ) { SimpleDateFormat format ; if ( arg != null ) { format = new SimpleDateFormat ( arg ) ; } else { format = new SimpleDateFormat ( "M@@ M@@ /@@ dd@@ /@@ Y@@ Y@@ Y@@ Y@@ " ) ; } return format . format ( new Date ( ) ) ; } else { return null ; } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . Tuple ; import net . sf . sv@@ editor . core . log . LogFactory ; import org . eclipse . core . runtime . I@@ Configuration@@ Element ; import org . eclipse . core . runtime . I@@ Extension ; import org . eclipse . core . runtime . I@@ Extension@@ Point ; import org . eclipse . core . runtime . I@@ Extension@@ Registry ; import org . eclipse . core . runtime . P@@ latform ; import org . osgi . framework . Bundle ; public class Extension@@ Template@@ Finder extends Abstract@@ Template@@ Finder { public Extension@@ Template@@ Finder ( ) { super ( ) ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; } public void find ( ) { I@@ Extension@@ Registry ext@@ _r@@ g@@ y = P@@ latform . get@@ Extension@@ Registry ( ) ; I@@ Extension@@ Point ext@@ _p@@ t = ext@@ _r@@ g@@ y . get@@ Extension@@ Point ( SV@@ Core@@ Plugin . PL@@ UG@@ IN_@@ ID , "S@@ V@@ Temp@@ lat@@ es" ) ; I@@ Extension ext@@ _@@ list [ ] = ext@@ _p@@ t . get@@ Exten@@ sions ( ) ; for ( I@@ Extension ext : ext@@ _@@ list ) { I@@ Configuration@@ Element ce@@ _@@ l [ ] = ext . get@@ Configuration@@ Elements ( ) ; for ( I@@ Configuration@@ Element ce : ce@@ _@@ l ) { String name = ce . getName ( ) ; if ( name . equals ( "c@@ ateg@@ ory@@ " ) ) { add@@ Category ( ce ) ; } else if ( name . equals ( "@@ template@@ " ) ) { add@@ Template ( ce ) ; } else { f@@ Log . error ( "" + name + "\"" ) ; } } } } private void add@@ Category ( I@@ Configuration@@ Element ce ) { String id = ce . getAttribute ( "id" ) ; String name = ce . getAttribute ( "name" ) ; String parent = ce . getAttribute ( "@@ parent@@ " ) ; Template@@ Category c = new Template@@ Category ( id , name , parent ) ; for ( I@@ Configuration@@ Element ci : ce . getChildren ( ) ) { if ( ci . getName ( ) . equals ( "@@ descrip@@ tion" ) ) { c . setDescription ( ci . getValue ( ) ) ; } } f@@ Categ@@ ories . add ( c ) ; } private void add@@ Template ( I@@ Configuration@@ Element ce ) { String id = ce . getAttribute ( "id" ) ; String name = ce . getAttribute ( "name" ) ; String category = ce . getAttribute ( "c@@ ateg@@ ory@@ " ) ; String description = "" ; Bundle bundle = P@@ latform . get@@ Bundle ( ce . get@@ Con@@ tribut@@ or ( ) . getName ( ) ) ; for ( I@@ Configuration@@ Element ce@@ _@@ c : ce . getChildren ( ) ) { if ( ce@@ _@@ c . getName ( ) . equals ( "@@ descrip@@ tion" ) ) { description = ce@@ _@@ c . getValue ( ) ; } } Template@@ Info info = new Template@@ Info ( id , name , category , description , new Plugin@@ In@@ Stream@@ Provider ( bundle ) ) ; f@@ Template@@ s . add ( info ) ; for ( I@@ Configuration@@ Element ce@@ _@@ c : ce . getChildren ( ) ) { if ( ce@@ _@@ c . getName ( ) . equals ( "@@ fil@@ es" ) ) { for ( I@@ Configuration@@ Element tmp@@ l : ce@@ _@@ c . getChildren ( ) ) { String template = tmp@@ l . getAttribute ( "@@ template@@ " ) ; String tmp@@ l@@ _name = tmp@@ l . getAttribute ( "name" ) ; info . add@@ Template ( new Tuple < String , String > ( template , tmp@@ l@@ _name ) ) ; } } else if ( ce@@ _@@ c . getName ( ) . equals ( "parameter@@ s" ) ) { for ( I@@ Configuration@@ Element p : ce@@ _@@ c . getChildren ( ) ) { if ( p . getName ( ) . equals ( "parameter@@ " ) ) { String p@@ _type = p . getAttribute ( "type" ) ; String p@@ _name = p . getAttribute ( "name" ) ; String p@@ _d@@ fl@@ t = p . getAttribute ( "@@ default@@ " ) ; String p_@@ ext@@ _f@@ rom = p . getAttribute ( "@@ ext@@ end@@ s_@@ from@@ " ) ; String p_@@ res@@ tr = p . getAttribute ( "@@ res@@ tr@@ iction@@ s" ) ; Template@@ Parameter@@ Type type = null ; if ( p@@ _type . equals ( "@@ int@@ " ) ) { type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Int ; } else if ( p@@ _type . equals ( "id" ) ) { type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Id ; } else if ( p@@ _type . equals ( "@@ class@@ " ) ) { type = Template@@ Parameter@@ Type . Parameter@@ Type@@ _@@ Class ; } else { f@@ Log . error ( "" + p@@ _type + "\"" ) ; continue ; } Template@@ Parameter tp = new Template@@ Parameter ( type , p@@ _name , p@@ _d@@ fl@@ t , p_@@ ext@@ _f@@ rom ) ; if ( p_@@ res@@ tr != null && ! p_@@ res@@ tr . trim ( ) . equals ( "" ) ) { String r [ ] = p_@@ res@@ tr . split ( "," ) ; for ( String rs : r ) { rs = rs . trim ( ) ; if ( ! rs . equals ( "" ) ) { tp . add@@ Value ( rs ) ; } } } info . add@@ Parameter ( tp ) ; } } } } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import net . sf . sv@@ editor . core . Tuple ; public class Template@@ Info { private String f@@ Id ; private String f@@ Name ; private String f@@ Category@@ Id ; private String f@@ Description ; private List < Tuple < String , String > > f@@ Template@@ List ; private List < Template@@ Parameter > f@@ Parameters ; private IT@@ emp@@ late@@ In@@ Stream@@ Provider f@@ Stream@@ Provider ; public Template@@ Info ( String id , String name , String category@@ _id , String description , IT@@ emp@@ late@@ In@@ Stream@@ Provider stream@@ _@@ provider ) { f@@ Id = id ; f@@ Name = name ; f@@ Category@@ Id = ( category@@ _id != null ) ? category@@ _id : "" ; f@@ Description = description ; f@@ Template@@ List = new ArrayList < Tuple < String , String > > ( ) ; f@@ Parameters = new ArrayList < Template@@ Parameter > ( ) ; f@@ Stream@@ Provider = stream@@ _@@ provider ; } public String getId ( ) { return f@@ Id ; } public String getName ( ) { return f@@ Name ; } public String getC@@ ateg@@ ory@@ Id ( ) { return f@@ Category@@ Id ; } public void set@@ Category@@ Id ( String id ) { f@@ Category@@ Id = id ; } public void setDescription ( String description ) { f@@ Description = description ; } public String getDescription ( ) { return f@@ Description ; } public Iterable < Tuple < String , String > > get@@ Template@@ s ( ) { return new Iterable < Tuple < String , String > > ( ) { public Iterator < Tuple < String , String > > iterator ( ) { return f@@ Template@@ List . iterator ( ) ; } } ; } public void add@@ Template ( String template , String filename ) { add@@ Template ( new Tuple < String , String > ( template , filename ) ) ; } public void add@@ Template ( Tuple < String , String > template ) { f@@ Template@@ List . add ( template ) ; } public void add@@ Parameter ( Template@@ Parameter p ) { f@@ Parameters . add ( p ) ; } public List < Template@@ Parameter > getParameters ( ) { return f@@ Parameters ; } public InputStream open@@ Template ( String path ) { return f@@ Stream@@ Provider . open@@ Stream ( path ) ; } public void close@@ Template ( InputStream in ) { f@@ Stream@@ Provider . close@@ Stream ( in ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . util . ArrayList ; import java . util . List ; public class Template@@ Parameter { private Template@@ Parameter@@ Type f@@ Type ; private String f@@ Name ; private String f@@ Default ; private String f@@ Value ; private String f@@ Ext@@ From ; private List < String > f@@ Values ; public Template@@ Parameter ( Template@@ Parameter@@ Type type , String name , String d@@ fl@@ t , String ext@@ _f@@ rom ) { f@@ Type = type ; f@@ Name = name ; f@@ Default = d@@ fl@@ t ; f@@ Value = d@@ fl@@ t ; f@@ Ext@@ From = ext@@ _f@@ rom ; f@@ Values = new ArrayList < String > ( ) ; } public Template@@ Parameter@@ Type getType ( ) { return f@@ Type ; } public String getType@@ Name ( ) { switch ( f@@ Type ) { case Parameter@@ Type@@ _@@ Id : { if ( f@@ Values . size ( ) == 0 ) { return "@@ identi@@ fier@@ " ; } else { return "@@ cho@@ ice@@ " ; } } case Parameter@@ Type@@ _@@ Class : return "@@ class@@ " ; case Parameter@@ Type@@ _@@ Int : return "@@ integer@@ " ; default : return "un@@ kn@@ ow@@ n" ; } } public String getName ( ) { return f@@ Name ; } public String getDefault ( ) { return f@@ Default ; } public String getValue ( ) { return f@@ Value ; } public void setValue ( String val ) { f@@ Value = val ; } public String get@@ Ext@@ From ( ) { return f@@ Ext@@ From ; } public List < String > get@@ Values ( ) { return f@@ Values ; } public void add@@ Value ( String value ) { if ( ! f@@ Values . contains ( value ) ) { f@@ Values . add ( value ) ; } } public Template@@ Parameter d@@ uplic@@ ate ( ) { Template@@ Parameter p = new Template@@ Parameter ( f@@ Type , f@@ Name , f@@ Default , f@@ Ext@@ From ) ; p . setValue ( f@@ Value ) ; for ( String v : f@@ Values ) { p . add@@ Value ( v ) ; } return p ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; public enum Template@@ Parameter@@ Type { Parameter@@ Type@@ _@@ Id , Parameter@@ Type@@ _@@ Int , Parameter@@ Type@@ _@@ Class } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . File ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import net . sf . sv@@ editor . core . SV@@ FileUtils ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import org . eclipse . core . resources . I@@ Container ; public class Template@@ Registry implements I@@ Log@@ Level { private static Log@@ Handle f@@ Log ; private List < Template@@ Category > f@@ Categ@@ ories ; private List < Template@@ Info > f@@ Template@@ s ; private Map < String , List < Template@@ Info > > f@@ Category@@ Map ; private List < I@@ External@@ Template@@ Path@@ Provider > f@@ Path@@ Pro@@ viders ; private boolean f@@ Load@@ Ext@@ Points ; static { f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; } public Template@@ Registry ( boolean load@@ _@@ ext@@ s ) { f@@ Categ@@ ories = new ArrayList < Template@@ Category > ( ) ; f@@ Template@@ s = new ArrayList < Template@@ Info > ( ) ; f@@ Category@@ Map = new HashMap < String , List < Template@@ Info > > ( ) ; f@@ Path@@ Pro@@ viders = new ArrayList < I@@ External@@ Template@@ Path@@ Provider > ( ) ; f@@ Load@@ Ext@@ Points = load@@ _@@ ext@@ s ; load@@ _@@ extensions ( ) ; } public void add@@ Path@@ Provider ( I@@ External@@ Template@@ Path@@ Provider p ) { f@@ Path@@ Pro@@ viders . add ( p ) ; } public void clear@@ Path@@ Pro@@ viders ( ) { f@@ Path@@ Pro@@ viders . clear ( ) ; } public List < Template@@ Category > getC@@ ateg@@ ories ( ) { return f@@ Categ@@ ories ; } public List < String > getC@@ ateg@@ ory@@ Names ( ) { List < String > ret = new ArrayList < String > ( ) ; for ( Template@@ Category c : f@@ Categ@@ ories ) { ret . add ( c . getName ( ) ) ; } return ret ; } public List < String > getC@@ ateg@@ ory@@ IDs ( ) { List < String > ret = new ArrayList < String > ( ) ; for ( Template@@ Category c : f@@ Categ@@ ories ) { ret . add ( c . getId ( ) ) ; } return ret ; } public List < Template@@ Info > get@@ Template@@ s ( String id ) { List < Template@@ Info > ret = new ArrayList < Template@@ Info > ( ) ; if ( id == null ) { id = "" ; } if ( f@@ Category@@ Map . containsKey ( id ) ) { ret . addAll ( f@@ Category@@ Map . get ( id ) ) ; } return ret ; } public Template@@ Info find@@ Template ( String id ) { for ( Template@@ Info info : f@@ Template@@ s ) { if ( info . getId ( ) . equals ( id ) ) { return info ; } } return null ; } public void load@@ _@@ extensions ( ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" ) ; List < Abstract@@ Template@@ Finder > template@@ _@@ find@@ ers = new ArrayList < Abstract@@ Template@@ Finder > ( ) ; f@@ Template@@ s . clear ( ) ; f@@ Categ@@ ories . clear ( ) ; f@@ Category@@ Map . clear ( ) ; if ( f@@ Load@@ Ext@@ Points ) { template@@ _@@ find@@ ers . add ( new Extension@@ Template@@ Finder ( ) ) ; } if ( f@@ Path@@ Pro@@ viders . size ( ) > 0 ) { for ( I@@ External@@ Template@@ Path@@ Provider p : f@@ Path@@ Pro@@ viders ) { for ( String path : p . get@@ External@@ Template@@ Path ( ) ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + path + "\"" ) ; if ( path . startsWith ( "" ) ) { path = path . substring ( "" . length ( ) ) ; I@@ Container c = SV@@ FileUtils . get@@ Work@@ space@@ Folder ( path ) ; template@@ _@@ find@@ ers . add ( new WS@@ External@@ Template@@ Finder ( c ) ) ; } else { template@@ _@@ find@@ ers . add ( new F@@ S@@ External@@ Template@@ Finder ( new File ( path ) ) ) ; } } } } for ( Abstract@@ Template@@ Finder f : template@@ _@@ find@@ ers ) { f . find ( ) ; List < Template@@ Info > tmp@@ l@@ _@@ list = f . get@@ Template@@ s ( ) ; List < Template@@ Category > category@@ _@@ list = f . getC@@ ateg@@ ories ( ) ; f@@ Template@@ s . addAll ( tmp@@ l@@ _@@ list ) ; for ( Template@@ Category new_@@ c : category@@ _@@ list ) { if ( ! f@@ Categ@@ ories . contains ( new_@@ c ) ) { f@@ Categ@@ ories . add ( new_@@ c ) ; } } } for ( int i = 0 ; i < f@@ Categ@@ ories . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < f@@ Categ@@ ories . size ( ) ; j ++ ) { Template@@ Category c_@@ i = f@@ Categ@@ ories . get ( i ) ; Template@@ Category c_@@ j = f@@ Categ@@ ories . get ( j ) ; if ( c_@@ j . getName ( ) . compareTo ( c_@@ i . getName ( ) ) < 0 ) { f@@ Categ@@ ories . set ( j , c_@@ i ) ; f@@ Categ@@ ories . set ( i , c_@@ j ) ; } } } for ( Template@@ Info t : f@@ Template@@ s ) { if ( t . getC@@ ateg@@ ory@@ Id ( ) == null || t . getC@@ ateg@@ ory@@ Id ( ) . trim ( ) . equals ( "" ) ) { if ( ! f@@ Category@@ Map . containsKey ( "" ) ) { Template@@ Category c = new Template@@ Category ( "" , "@@ Oth@@ er" , "" ) ; c . setDescription ( "" ) ; t . set@@ Category@@ Id ( "" ) ; } } if ( ! f@@ Category@@ Map . containsKey ( t . getC@@ ateg@@ ory@@ Id ( ) ) ) { f@@ Category@@ Map . put ( t . getC@@ ateg@@ ory@@ Id ( ) , new ArrayList < Template@@ Info > ( ) ) ; } f@@ Category@@ Map . get ( t . getC@@ ateg@@ ory@@ Id ( ) ) . add ( t ) ; } for ( Entry < String , List < Template@@ Info > > c : f@@ Category@@ Map . entrySet ( ) ) { List < Template@@ Info > t = c . getValue ( ) ; for ( int i = 0 ; i < t . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < t . size ( ) ; j ++ ) { Template@@ Info t_@@ i = t . get ( i ) ; Template@@ Info t_@@ j = t . get ( j ) ; if ( t_@@ j . getName ( ) . compareTo ( t_@@ i . getName ( ) ) < 0 ) { t . set ( i , t_@@ j ) ; t . set ( j , t_@@ i ) ; } } } } } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; public class Default@@ Template@@ Parameter@@ Provider extends Template@@ Parameter@@ Provider { public static final String FILE_@@ HEA@@ DER = "file@@ _@@ header@@ " ; public static final String FILE_@@ HEADER_@@ DF@@ LT = "" + "" + "" ; public static final String FILE_@@ FO@@ O@@ TER = "file@@ _f@@ oo@@ ter@@ " ; public static final String FILE_@@ FO@@ O@@ TER_@@ DF@@ LT = "" ; public Default@@ Template@@ Parameter@@ Provider ( IT@@ emp@@ late@@ Parameter@@ Provider p ) { super ( ) ; set_@@ de@@ faults ( ) ; if ( p . pro@@ vi@@ des@@ Parameter ( FILE_@@ HEA@@ DER ) ) { set@@ Tag ( FILE_@@ HEA@@ DER , p . getParameter@@ Value ( FILE_@@ HEA@@ DER , null ) ) ; } if ( p . pro@@ vi@@ des@@ Parameter ( FILE_@@ FO@@ O@@ TER ) ) { set@@ Tag ( FILE_@@ HEA@@ DER , p . getParameter@@ Value ( FILE_@@ FO@@ O@@ TER , null ) ) ; } } private void set_@@ de@@ faults ( ) { set@@ Tag ( FILE_@@ HEA@@ DER , FILE_@@ HEADER_@@ DF@@ LT ) ; set@@ Tag ( FILE_@@ FO@@ O@@ TER , FILE_@@ FO@@ O@@ TER_@@ DF@@ LT ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; public class Template@@ Category implements Comparable < Template@@ Category > { private String f@@ Id ; private String f@@ Name ; private String f@@ Description ; private String f@@ Parent ; public Template@@ Category ( String id , String name , String parent ) { f@@ Id = id ; f@@ Name = name ; f@@ Description = "" ; f@@ Parent = parent ; } public String getId ( ) { return f@@ Id ; } public String getName ( ) { return f@@ Name ; } public String getDescription ( ) { return f@@ Description ; } public void setDescription ( String desc ) { f@@ Description = desc ; } public String getParent ( ) { return f@@ Parent ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof Template@@ Category ) { return f@@ Id . equals ( ( ( Template@@ Category ) obj ) . f@@ Id ) ; } else { return false ; } } public int compareTo ( Template@@ Category o ) { return f@@ Name . compareTo ( o . f@@ Name ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; public interface IT@@ emp@@ late@@ Parameter@@ Provider { boolean pro@@ vi@@ des@@ Parameter ( String id ) ; String getParameter@@ Value ( String id , String arg ) ; } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; public abstract class Abstract@@ Template@@ Finder implements I@@ Log@@ Level { protected Log@@ Handle f@@ Log ; protected List < Template@@ Info > f@@ Template@@ s ; protected List < Template@@ Category > f@@ Categ@@ ories ; public Abstract@@ Template@@ Finder ( ) { f@@ Template@@ s = new ArrayList < Template@@ Info > ( ) ; f@@ Categ@@ ories = new ArrayList < Template@@ Category > ( ) ; } public abstract void find ( ) ; public List < Template@@ Info > get@@ Template@@ s ( ) { return f@@ Template@@ s ; } public List < Template@@ Category > getC@@ ateg@@ ories ( ) { return f@@ Categ@@ ories ; } protected void add@@ Template ( Template@@ Info template ) { f@@ Template@@ s . add ( template ) ; } protected void add@@ Category ( Template@@ Category category ) { f@@ Categ@@ ories . add ( category ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . SV@@ Core@@ Plugin ; import net . sf . sv@@ editor . core . String@@ InputStream ; import net . sf . sv@@ editor . core . Tuple ; import net . sf . sv@@ editor . core . indent . IS@@ V@@ Ind@@ enter ; import net . sf . sv@@ editor . core . indent . SV@@ Ind@@ ent@@ Scanner ; import net . sf . sv@@ editor . core . scan@@ utils . Input@@ Stream@@ Text@@ Scanner ; import net . sf . sv@@ editor . core . text . Tag@@ Processor ; public class Template@@ Processor { private IT@@ emp@@ late@@ File@@ Creator f@@ Stream@@ Provider ; private static final String f@@ Default@@ File@@ Header = "" + "" + "" ; public Template@@ Processor ( IT@@ emp@@ late@@ File@@ Creator provider ) { f@@ Stream@@ Provider = provider ; } public static List < String > getOutput@@ Files ( Template@@ Info template , Tag@@ Processor pro@@ c ) { List < String > ret = new ArrayList < String > ( ) ; for ( Tuple < String , String > t : template . get@@ Template@@ s ( ) ) { String name = pro@@ c . process ( t . second ( ) ) ; ret . add ( name ) ; } return ret ; } public void process ( Template@@ Info template , Tag@@ Processor pro@@ c ) { Template@@ Parameter@@ Provider local@@ _@@ p = new Template@@ Parameter@@ Provider ( ) ; pro@@ c . add@@ Parameter@@ Provider ( local@@ _@@ p ) ; for ( Tuple < String , String > t : template . get@@ Template@@ s ( ) ) { int n@@ _@@ repl@@ ac@@ em@@ ents = 0 ; String temp@@ l = t . first ( ) ; String name = pro@@ c . process ( t . second ( ) ) ; name = name . trim ( ) ; local@@ _@@ p . set@@ Tag ( "@@ fil@@ ename@@ " , name ) ; InputStream in = template . open@@ Template ( temp@@ l ) ; ByteArrayInputStream in_@@ t = read@@ InputStream ( in ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; do { try { n@@ _@@ repl@@ ac@@ em@@ ents = pro@@ c . process ( in_@@ t , out ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } in_@@ t = new ByteArrayInputStream ( out . toByteArray ( ) ) ; out = new ByteArrayOutputStream ( ) ; } while ( n@@ _@@ repl@@ ac@@ em@@ ents > 0 ) ; InputStream in_@@ ind = null ; if ( sho@@ ul@@ d_@@ s@@ v_@@ indent ( name ) ) { SV@@ Ind@@ ent@@ Scanner scanner = new SV@@ Ind@@ ent@@ Scanner ( new Input@@ Stream@@ Text@@ Scanner ( in_@@ t , name ) ) ; IS@@ V@@ Ind@@ enter ind@@ enter = SV@@ Core@@ Plugin . getDefault ( ) . create@@ Ind@@ enter ( ) ; ind@@ enter . init ( scanner ) ; in_@@ ind = new String@@ InputStream ( ind@@ enter . indent ( ) ) ; } else { in_@@ ind = in_@@ t ; } f@@ Stream@@ Provider . create@@ File ( name , in_@@ ind ) ; template . close@@ Template ( in ) ; } pro@@ c . remove@@ Parameter@@ Provider ( local@@ _@@ p ) ; } private boolean sho@@ ul@@ d_@@ s@@ v_@@ indent ( String name ) { String ext = "" ; if ( name . lastIndexOf ( '.' ) != - 1 ) { ext = name . substring ( name . lastIndexOf ( '.' ) ) ; } List < String > ext@@ s = SV@@ Core@@ Plugin . getDefault ( ) . getDefault@@ SV@@ Ex@@ ts ( ) ; return ext@@ s . contains ( ext ) ; } private ByteArrayInputStream read@@ InputStream ( InputStream in ) { ByteArrayOutputStream bo@@ s = new ByteArrayOutputStream ( ) ; byte tmp [ ] = new byte [ 16@@ 38@@ 4 ] ; int len ; try { while ( ( len = in . read ( tmp , 0 , tmp . length ) ) > 0 ) { bo@@ s . write ( tmp , 0 , len ) ; } } catch ( IOException e ) { } return new ByteArrayInputStream ( bo@@ s . toByteArray ( ) ) ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class SV@@ T@@ Utils { public static boolean ensure@@ Expected@@ Sec@@ tions ( Document doc , Element s@@ v_@@ template ) { NodeList nl = s@@ v_@@ template . getChild@@ Nodes ( ) ; boolean ret = false ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; if ( n instanceof Element ) { Element e = ( Element ) n ; if ( e . getNode@@ Name ( ) . equals ( "@@ template@@ " ) ) { ret |= ensure@@ Expected@@ Template@@ Sec@@ tions ( doc , e ) ; } else if ( e . getNode@@ Name ( ) . equals ( "c@@ ateg@@ ory@@ " ) ) { ret |= ensure@@ Expected@@ Category@@ Sec@@ tions ( doc , e ) ; } } } return ret ; } private static boolean ensure@@ Expected@@ Template@@ Sec@@ tions ( Document doc , Element template ) { boolean ret = false ; ret |= add@@ Element@@ If@@ Missing ( doc , template , "@@ descrip@@ tion" ) ; ret |= add@@ Element@@ If@@ Missing ( doc , template , "parameter@@ s" ) ; ret |= add@@ Element@@ If@@ Missing ( doc , template , "@@ fil@@ es" ) ; return ret ; } private static boolean ensure@@ Expected@@ Category@@ Sec@@ tions ( Document doc , Element template ) { boolean ret = false ; ret |= add@@ Element@@ If@@ Missing ( doc , template , "@@ descrip@@ tion" ) ; return ret ; } private static boolean add@@ Element@@ If@@ Missing ( Document doc , Element e , String elem ) { NodeList nl = e . getChild@@ Nodes ( ) ; boolean found = false ; boolean ret = false ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; if ( n instanceof Element && ( ( Element ) n ) . getNode@@ Name ( ) . equals ( elem ) ) { found = true ; break ; } } if ( ! found ) { Element new_@@ e = doc . createElement ( elem ) ; e . appendChild ( new_@@ e ) ; ret = true ; } return ret ; } } </s>
<s> package net . sf . sv@@ editor . core . template@@ s ; import java . util . HashMap ; import java . util . Map ; public class Template@@ Parameter@@ Provider implements IT@@ emp@@ late@@ Parameter@@ Provider { private Map < String , String > f@@ Tag@@ Map ; public Template@@ Parameter@@ Provider ( ) { f@@ Tag@@ Map = new HashMap < String , String > ( ) ; } public Template@@ Parameter@@ Provider ( Map < String , String > init ) { this ( ) ; f@@ Tag@@ Map . put@@ All ( init ) ; } public Template@@ Parameter@@ Provider ( Template@@ Parameter@@ Provider init ) { this ( ) ; f@@ Tag@@ Map . put@@ All ( init . f@@ Tag@@ Map ) ; } public boolean pro@@ vi@@ des@@ Parameter ( String id ) { return f@@ Tag@@ Map . containsKey ( id ) ; } public String getParameter@@ Value ( String id , String arg ) { return get@@ Tag ( id ) ; } public void set@@ Tag ( String tag , String value ) { if ( f@@ Tag@@ Map . containsKey ( tag ) ) { f@@ Tag@@ Map . remove ( tag ) ; } f@@ Tag@@ Map . put ( tag , value ) ; } public void remove@@ Tag ( String tag ) { f@@ Tag@@ Map . remove ( tag ) ; } public boolean has@@ Tag ( String tag ) { return f@@ Tag@@ Map . containsKey ( tag ) ; } public String get@@ Tag ( String tag ) { return f@@ Tag@@ Map . get ( tag ) ; } public void append@@ Tag ( String tag , String value ) { String val ; if ( f@@ Tag@@ Map . containsKey ( tag ) ) { val = f@@ Tag@@ Map . get ( tag ) ; f@@ Tag@@ Map . remove ( tag ) ; } else { val = "" ; } val += value ; f@@ Tag@@ Map . put ( tag , val ) ; } } </s>
<s> package net . sf . sv@@ editor . core . content@@ _@@ assist ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item ; public class SV@@ CompletionPropos@@ al { private IS@@ V@@ DB@@ Item@@ Base f@@ Item ; private String f@@ Prefix ; private String f@@ Repl@@ acement ; private int f@@ Repl@@ ac@@ ement@@ Offset ; private int f@@ Repl@@ ac@@ ement@@ Length ; private SV@@ CompletionPropos@@ al@@ Type f@@ Type ; public SV@@ CompletionPropos@@ al ( IS@@ V@@ DB@@ Item@@ Base item , String prefix , int repl@@ ac@@ ement@@ Offset , int repl@@ ac@@ ement@@ Length ) { f@@ Item = item ; f@@ Prefix = prefix ; f@@ Repl@@ acement = SV@@ DB@@ Item . getName ( item ) ; f@@ Repl@@ ac@@ ement@@ Offset = repl@@ ac@@ ement@@ Offset ; f@@ Repl@@ ac@@ ement@@ Length = repl@@ ac@@ ement@@ Length ; f@@ Type = SV@@ CompletionPropos@@ al@@ Type . SV@@ Object ; } public String get@@ Prefix ( ) { return f@@ Prefix ; } public String get@@ Repl@@ acement ( ) { return f@@ Repl@@ acement ; } public void set@@ Repl@@ acement ( String repl@@ acement ) { f@@ Repl@@ acement = repl@@ acement ; } public SV@@ CompletionPropos@@ al ( String repl@@ acement , int start@@ Offset , int repl@@ ac@@ ement@@ Length ) { f@@ Repl@@ acement = repl@@ acement ; f@@ Repl@@ ac@@ ement@@ Offset = start@@ Offset ; f@@ Repl@@ ac@@ ement@@ Length = repl@@ ac@@ ement@@ Length ; f@@ Type = SV@@ CompletionPropos@@ al@@ Type . Un@@ known ; } public SV@@ CompletionPropos@@ al ( String repl@@ acement , int start@@ Offset , int repl@@ ac@@ ement@@ Length , SV@@ CompletionPropos@@ al@@ Type type ) { f@@ Repl@@ acement = repl@@ acement ; f@@ Repl@@ ac@@ ement@@ Offset = start@@ Offset ; f@@ Repl@@ ac@@ ement@@ Length = repl@@ ac@@ ement@@ Length ; f@@ Type = type ; } public IS@@ V@@ DB@@ Item@@ Base getItem ( ) { return f@@ Item ; } public SV@@ CompletionPropos@@ al@@ Type getType ( ) { return f@@ Type ; } public int get@@ Repl@@ ac@@ ement@@ Offset ( ) { return f@@ Repl@@ ac@@ ement@@ Offset ; } public int get@@ Repl@@ ac@@ ement@@ Length ( ) { return f@@ Repl@@ ac@@ ement@@ Length ; } } </s>
<s> package net . sf . sv@@ editor . core . content@@ _@@ assist ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . db . I@@ Field@@ Item@@ Attr ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Parent ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Item@@ Base ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Named@@ Item ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Scope@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Class@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ File ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Function ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Interface@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item@@ Type ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ If@@ c@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ If@@ c@@ In@@ st ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ port@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ port@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ port@@ Port@@ s@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ port@@ Simple@@ Port ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ port@@ Simple@@ Port@@ s@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Package@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Task ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ TypeInfo ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Type@@ Info@@ Enum ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator ; import net . sf . sv@@ editor . core . db . expr . SV@@ DB@@ Expr ; import net . sf . sv@@ editor . core . db . index . IS@@ V@@ DB@@ Index@@ Iterator ; import net . sf . sv@@ editor . core . db . index . SV@@ DB@@ Decl@@ Cache@@ Item ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ ByName ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ By@@ Name@@ In@@ Class@@ Hierarch@@ y ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ By@@ Name@@ In@@ Scop@@ es ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ By@@ Name@@ Matcher ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ Default@@ Name@@ Matcher ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ Inclu@@ ded@@ File ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c ; import net . sf . sv@@ editor . core . db . search . SV@@ DB@@ Find@@ Super@@ Class ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Param@@ Port@@ Decl ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Stmt ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Typed@@ ef@@ Stmt ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Var@@ Decl@@ Item ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Var@@ Decl@@ Stmt ; import net . sf . sv@@ editor . core . db . utils . SV@@ DB@@ Search@@ Utils ; import net . sf . sv@@ editor . core . expr@@ _@@ utils . SV@@ Content@@ As@@ sist@@ Expr@@ Visitor ; import net . sf . sv@@ editor . core . expr@@ _@@ utils . SV@@ Expr@@ Context ; import net . sf . sv@@ editor . core . expr@@ _@@ utils . SV@@ Expr@@ Context . Context@@ Type ; import net . sf . sv@@ editor . core . expr@@ _@@ utils . SV@@ Expr@@ Scanner ; import net . sf . sv@@ editor . core . expr@@ _@@ utils . SV@@ Expr@@ Util@@ s@@ Parser ; import net . sf . sv@@ editor . core . log . I@@ Log@@ Level ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import net . sf . sv@@ editor . core . parser . SV@@ ParseException ; import net . sf . sv@@ editor . core . scan@@ utils . IB@@ ID@@ I@@ Text@@ Scanner ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; public abstract class Abstract@@ Completion@@ Processor implements I@@ Log@@ Level { protected List < SV@@ CompletionPropos@@ al > f@@ CompletionPropos@@ als ; protected Log@@ Handle f@@ Log ; public Abstract@@ Completion@@ Processor ( ) { f@@ CompletionPropos@@ als = new ArrayList < SV@@ CompletionPropos@@ al > ( ) ; } protected abstract IS@@ V@@ DB@@ Index@@ Iterator getIndex@@ Iterator ( ) ; protected abstract SV@@ DB@@ File getS@@ V@@ DB@@ File ( ) ; protected void add@@ Propos@@ al ( SV@@ CompletionPropos@@ al p ) { boolean found = false ; synchronized ( f@@ CompletionPropos@@ als ) { for ( SV@@ CompletionPropos@@ al p_@@ t : f@@ CompletionPropos@@ als ) { if ( p_@@ t . equals ( p ) ) { found = true ; break ; } } if ( ! found ) { f@@ CompletionPropos@@ als . add ( p ) ; } } } public List < SV@@ CompletionPropos@@ al > get@@ CompletionPropos@@ als ( ) { return f@@ CompletionPropos@@ als ; } public void compute@@ Propos@@ als ( IB@@ ID@@ I@@ Text@@ Scanner scanner , SV@@ DB@@ File active@@ _@@ file , int lin@@ en@@ o ) { compute@@ Propos@@ als ( scanner , active@@ _@@ file , lin@@ en@@ o , - 1 ) ; } public void compute@@ Propos@@ als ( IB@@ ID@@ I@@ Text@@ Scanner scanner , SV@@ DB@@ File active@@ _@@ file , int lin@@ en@@ o , int line@@ pos ) { SV@@ Expr@@ Scanner expr@@ _@@ sc@@ an = new SV@@ Expr@@ Scanner ( ) ; synchronized ( f@@ CompletionPropos@@ als ) { f@@ CompletionPropos@@ als . clear ( ) ; } f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" + active@@ _@@ file . getFile@@ Path ( ) + ":" + lin@@ en@@ o + ":" + line@@ pos ) ; IS@@ V@@ DB@@ Scope@@ Item src@@ _@@ scope = SV@@ DB@@ Search@@ Utils . find@@ Active@@ Scope ( active@@ _@@ file , lin@@ en@@ o ) ; if ( src@@ _@@ scope != null ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "@@ src@@ _@@ s@@ cop@@ e@@ : " + src@@ _@@ scope . getType ( ) + " " + SV@@ DB@@ Item . getName ( src@@ _@@ scope ) ) ; } SV@@ Expr@@ Context ctxt = expr@@ _@@ sc@@ an . extract@@ Expr@@ Context ( scanner , false ) ; f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "c@@ txt@@ : type@@ =" + ctxt . f@@ Type + " trig@@ ger@@ =" + ctxt . f@@ Trig@@ ger + " root@@ =" + ctxt . f@@ Root + " le@@ af@@ =" + ctxt . f@@ Lea@@ f + " start@@ =" + ctxt . f@@ Start ) ; if ( ctxt . f@@ Trig@@ ger != null ) { if ( ctxt . f@@ Trig@@ ger . equals ( "@@ `@@ " ) ) { find@@ M@@ ac@@ ro@@ Items ( ctxt , getIndex@@ Iterator ( ) ) ; } else if ( ctxt . f@@ Root != null && ( ctxt . f@@ Trig@@ ger . equals ( "=" ) || ctxt . f@@ Trig@@ ger . equals ( "." ) || ctxt . f@@ Trig@@ ger . equals ( ":@@ :" ) || ctxt . f@@ Trig@@ ger . equals ( ":" ) ) ) { if ( ctxt . f@@ Trig@@ ger . equals ( "." ) || ctxt . f@@ Trig@@ ger . equals ( ":@@ :" ) ) { SV@@ DB@@ Expr expr = null ; SV@@ Expr@@ Util@@ s@@ Parser parser = new SV@@ Expr@@ Util@@ s@@ Parser ( ctxt ) ; try { expr = parser . parsers ( ) . expr@@ Parser ( ) . expression ( ) ; } catch ( SV@@ ParseException e ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" , e ) ; return ; } SV@@ Content@@ As@@ sist@@ Expr@@ Visitor v = new SV@@ Content@@ As@@ sist@@ Expr@@ Visitor ( src@@ _@@ scope , SV@@ DB@@ Find@@ Default@@ Name@@ Matcher . getDefault ( ) , getIndex@@ Iterator ( ) ) ; IS@@ V@@ DB@@ Item@@ Base item = null ; if ( expr != null ) { item = v . find@@ Type@@ Item ( expr ) ; } if ( item == null ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" ) ; return ; } f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "@@ Item@@ : " + item . getType ( ) + " " + SV@@ DB@@ Item . getName ( item ) ) ; find@@ Trig@@ ger@@ ed@@ Propos@@ als ( ctxt , src@@ _@@ scope , item ) ; } else if ( ctxt . f@@ Trig@@ ger . equals ( "=" ) ) { SV@@ DB@@ Expr expr = null ; SV@@ Expr@@ Util@@ s@@ Parser parser = new SV@@ Expr@@ Util@@ s@@ Parser ( ctxt ) ; try { expr = parser . parsers ( ) . expr@@ Parser ( ) . expression ( ) ; } catch ( SV@@ ParseException e ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" , e ) ; return ; } SV@@ Content@@ As@@ sist@@ Expr@@ Visitor v = new SV@@ Content@@ As@@ sist@@ Expr@@ Visitor ( src@@ _@@ scope , SV@@ DB@@ Find@@ Default@@ Name@@ Matcher . getDefault ( ) , getIndex@@ Iterator ( ) ) ; IS@@ V@@ DB@@ Item@@ Base item = null ; if ( expr != null ) { try { item = v . find@@ Type@@ Item ( expr ) ; } catch ( RuntimeException e ) { } } if ( item == null ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" ) ; } f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "@@ Item@@ : " + ( ( item != null ) ? ( item . getType ( ) + " " + SV@@ DB@@ Item . getName ( item ) ) : "null" ) ) ; find@@ Assign@@ Trig@@ ger@@ ed@@ Propos@@ als ( ctxt , src@@ _@@ scope , item ) ; } else if ( ctxt . f@@ Trig@@ ger . equals ( ":" ) ) { if ( ctxt . f@@ Root . startsWith ( "@@ end@@ " ) ) { find@@ End@@ Label@@ Propos@@ als ( ctxt , src@@ _@@ scope ) ; } else { find@@ Un@@ trig@@ ger@@ ed@@ Propos@@ als ( ctxt , src@@ _@@ scope ) ; } } else { } } else if ( ctxt . f@@ Trig@@ ger . equals ( "." ) ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "" ) ; find@@ Port@@ CompletionPropos@@ als ( ctxt , src@@ _@@ scope , lin@@ en@@ o , line@@ pos ) ; } else { } } else { find@@ Un@@ trig@@ ger@@ ed@@ Propos@@ als ( ctxt , src@@ _@@ scope ) ; } order@@ _@@ pro@@ pos@@ als ( ctxt . f@@ Lea@@ f , f@@ CompletionPropos@@ als ) ; } private void find@@ Trig@@ ger@@ ed@@ Propos@@ als ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Child@@ Item src@@ _@@ scope , IS@@ V@@ DB@@ Item@@ Base le@@ af@@ _@@ item ) { boolean stati@@ c_@@ ref = ctxt . f@@ Trig@@ ger . equals ( ":@@ :" ) ; f@@ Log . debug ( "" + le@@ af@@ _@@ item . getType ( ) ) ; if ( le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl || le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ Struct || le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Interface@@ Decl || le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Module@@ Decl ) { SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; SV@@ DB@@ Find@@ Super@@ Class super@@ _@@ fin@@ der = new SV@@ DB@@ Find@@ Super@@ Class ( getIndex@@ Iterator ( ) ) ; IS@@ V@@ DB@@ Child@@ Parent si = ( IS@@ V@@ DB@@ Child@@ Parent ) le@@ af@@ _@@ item ; while ( si != null ) { for ( IS@@ V@@ DB@@ Child@@ Item it : si . getChildren ( ) ) { if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Stmt ) { SV@@ DB@@ Var@@ Decl@@ Stmt v = ( SV@@ DB@@ Var@@ Decl@@ Stmt ) it ; if ( ( v . get@@ Attr ( ) & SV@@ DB@@ Var@@ Decl@@ Stmt . Field@@ Attr@@ _@@ Stati@@ c ) != 0 == stati@@ c_@@ ref ) { for ( IS@@ V@@ DB@@ Item@@ Base it@@ _1 : ( ( SV@@ DB@@ Var@@ Decl@@ Stmt ) it ) . getChildren ( ) ) { debug ( "" + SV@@ DB@@ Item . getName ( it@@ _1 ) ) ; if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _1 , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it@@ _1 , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } else if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) { SV@@ DB@@ Typed@@ ef@@ Stmt t@@ d_@@ stmt = ( SV@@ DB@@ Typed@@ ef@@ Stmt ) it ; if ( matcher . match ( t@@ d_@@ stmt , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( t@@ d_@@ stmt , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } if ( t@@ d_@@ stmt . getType@@ Info ( ) != null && t@@ d_@@ stmt . getType@@ Info ( ) . getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ Enum ) { SV@@ DB@@ Type@@ Info@@ Enum enum@@ _type = ( SV@@ DB@@ Type@@ Info@@ Enum ) t@@ d_@@ stmt . getType@@ Info ( ) ; for ( SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator enum@@ er@@ ator : enum@@ _type . get@@ Enum@@ er@@ ators ( ) ) { if ( matcher . match ( enum@@ er@@ ator , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( enum@@ er@@ ator , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } else if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Mod@@ port@@ Decl ) { for ( IS@@ V@@ DB@@ Item@@ Base it@@ _1 : ( ( SV@@ DB@@ Mod@@ port@@ Decl ) it ) . getChildren ( ) ) { debug ( "" + SV@@ DB@@ Item . getName ( it@@ _1 ) ) ; if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _1 , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it@@ _1 , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } else if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Mod@@ If@@ c@@ In@@ st ) { for ( IS@@ V@@ DB@@ Item@@ Base it@@ _1 : ( ( SV@@ DB@@ Mod@@ If@@ c@@ In@@ st ) it ) . getChildren ( ) ) { if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _1 , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it@@ _1 , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } else if ( it instanceof IS@@ V@@ DB@@ Named@@ Item ) { if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } if ( si . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl ) { SV@@ DB@@ Class@@ Decl cl@@ s_@@ dec@@ l = ( SV@@ DB@@ Class@@ Decl ) si ; si = super@@ _@@ fin@@ der . find ( cl@@ s_@@ dec@@ l ) ; } else { if ( si . getType ( ) . is@@ Elem@@ Of ( SV@@ DB@@ Item@@ Type . Interface@@ Decl ) ) { SV@@ DB@@ Interface@@ Decl if@@ c = ( SV@@ DB@@ Interface@@ Decl ) si ; for ( SV@@ DB@@ Param@@ Port@@ Decl p : if@@ c . getPort@@ s ( ) ) { for ( IS@@ V@@ DB@@ Item@@ Base v@@ i : p . getChildren ( ) ) { if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) v@@ i , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( v@@ i , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } si = null ; } } } else if ( le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Package@@ Decl ) { SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; if ( ! stati@@ c_@@ ref ) { f@@ Log . debug ( "" ) ; } IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it = getIndex@@ Iterator ( ) ; SV@@ DB@@ Package@@ Decl pk@@ g_@@ dec@@ l = ( SV@@ DB@@ Package@@ Decl ) le@@ af@@ _@@ item ; List < SV@@ DB@@ Decl@@ Cache@@ Item > result = index@@ _@@ it . find@@ Global@@ Scope@@ Decl ( new Null@@ ProgressMonitor ( ) , pk@@ g_@@ dec@@ l . getName ( ) , new SV@@ DB@@ Find@@ By@@ Name@@ Matcher ( SV@@ DB@@ Item@@ Type . Package@@ Decl ) ) ; if ( result . size ( ) > 0 ) { SV@@ DB@@ Decl@@ Cache@@ Item pk@@ g_@@ item = result . get ( 0 ) ; List < SV@@ DB@@ Decl@@ Cache@@ Item > pk@@ g_@@ items = index@@ _@@ it . find@@ Package@@ Decl ( new Null@@ ProgressMonitor ( ) , pk@@ g_@@ item ) ; for ( SV@@ DB@@ Decl@@ Cache@@ Item ci : pk@@ g_@@ items ) { IS@@ V@@ DB@@ Item@@ Base item = ci . getS@@ V@@ DB@@ Item ( ) ; if ( item . getType ( ) == SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) { SV@@ DB@@ Typed@@ ef@@ Stmt t@@ d_@@ stmt = ( SV@@ DB@@ Typed@@ ef@@ Stmt ) item ; if ( matcher . match ( t@@ d_@@ stmt , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( t@@ d_@@ stmt , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } if ( t@@ d_@@ stmt . getType@@ Info ( ) != null && t@@ d_@@ stmt . getType@@ Info ( ) . getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ Enum ) { SV@@ DB@@ Type@@ Info@@ Enum enum@@ _type = ( SV@@ DB@@ Type@@ Info@@ Enum ) t@@ d_@@ stmt . getType@@ Info ( ) ; for ( SV@@ DB@@ Type@@ Info@@ Enum@@ er@@ ator enum@@ er@@ ator : enum@@ _type . get@@ Enum@@ er@@ ators ( ) ) { if ( matcher . match ( enum@@ er@@ ator , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( enum@@ er@@ ator , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } else if ( item instanceof IS@@ V@@ DB@@ Named@@ Item ) { IS@@ V@@ DB@@ Named@@ Item n@@ i = ( IS@@ V@@ DB@@ Named@@ Item ) item ; f@@ Log . debug ( "" + n@@ i . getName ( ) + "\"" ) ; if ( matcher . match ( n@@ i , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( item , ctxt . f@@ Lea@@ f , true , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { f@@ Log . debug ( "" + SV@@ DB@@ Item . getName ( item ) ) ; } } } else { f@@ Log . debug ( "" + pk@@ g_@@ dec@@ l . getName ( ) + "\"" ) ; } System . out . println ( "@@ Package Decl@@ " ) ; } else if ( le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Item ) { IS@@ V@@ DB@@ Item@@ Base ite@@ m_@@ type = getItem@@ Type ( le@@ af@@ _@@ item ) ; if ( ite@@ m_@@ type != null && ite@@ m_@@ type . getType ( ) . is@@ Elem@@ Of ( SV@@ DB@@ Item@@ Type . Class@@ Decl ) ) { IS@@ V@@ DB@@ Scope@@ Item si = ( IS@@ V@@ DB@@ Scope@@ Item ) ite@@ m_@@ type ; SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; for ( IS@@ V@@ DB@@ Item@@ Base it : si . getChildren ( ) ) { if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Stmt ) { for ( IS@@ V@@ DB@@ Item@@ Base it@@ _1 : ( ( SV@@ DB@@ Var@@ Decl@@ Stmt ) it ) . getChildren ( ) ) { debug ( "" + SV@@ DB@@ Item . getName ( it@@ _1 ) ) ; if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it@@ _1 , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it@@ _1 , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } else if ( it instanceof IS@@ V@@ DB@@ Named@@ Item ) { if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) it , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } } else if ( le@@ af@@ _@@ item . getType ( ) == SV@@ DB@@ Item@@ Type . Mod@@ port@@ Item ) { SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; SV@@ DB@@ Mod@@ port@@ Item mp@@ i = ( SV@@ DB@@ Mod@@ port@@ Item ) le@@ af@@ _@@ item ; for ( SV@@ DB@@ Mod@@ port@@ Port@@ s@@ Decl p@@ d : mp@@ i . getPort@@ sList ( ) ) { if ( p@@ d . getType ( ) == SV@@ DB@@ Item@@ Type . Mod@@ port@@ Simple@@ Port@@ s@@ Decl ) { SV@@ DB@@ Mod@@ port@@ Simple@@ Port@@ s@@ Decl simple@@ _p@@ d = ( SV@@ DB@@ Mod@@ port@@ Simple@@ Port@@ s@@ Decl ) p@@ d ; for ( SV@@ DB@@ Mod@@ port@@ Simple@@ Port p : simple@@ _p@@ d . getPort@@ List ( ) ) { if ( matcher . match ( p , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( p , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } else { f@@ Log . debug ( LE@@ VE@@ L_@@ MI@@ N , "" + p@@ d . getType ( ) ) ; } } } } private void find@@ Assign@@ Trig@@ ger@@ ed@@ Propos@@ als ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Child@@ Item src@@ _@@ scope , IS@@ V@@ DB@@ Item@@ Base item ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\"" ) ; List < IS@@ V@@ DB@@ Item@@ Base > result = new ArrayList < IS@@ V@@ DB@@ Item@@ Base > ( ) ; List < IS@@ V@@ DB@@ Item@@ Base > tmp = null ; SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; SV@@ DB@@ Find@@ By@@ Name@@ In@@ Scop@@ es fin@@ der@@ _@@ s = new SV@@ DB@@ Find@@ By@@ Name@@ In@@ Scop@@ es ( getIndex@@ Iterator ( ) , matcher ) ; tmp = fin@@ der@@ _@@ s . find ( src@@ _@@ scope , ctxt . f@@ Lea@@ f , false ) ; result . addAll ( tmp ) ; SV@@ DB@@ Find@@ By@@ Name@@ In@@ Class@@ Hierarch@@ y fin@@ der@@ _@@ h = new SV@@ DB@@ Find@@ By@@ Name@@ In@@ Class@@ Hierarch@@ y ( getIndex@@ Iterator ( ) , matcher ) ; tmp = fin@@ der@@ _@@ h . find ( src@@ _@@ scope , ctxt . f@@ Lea@@ f ) ; result . addAll ( tmp ) ; if ( result . size ( ) > 0 ) { for ( int i = 0 ; i < result . size ( ) ; i ++ ) { boolean add = true ; if ( result . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Function && ( ( IS@@ V@@ DB@@ Named@@ Item ) result . get ( i ) ) . getName ( ) . equals ( "@@ new@@ " ) ) { add = false ; } if ( add ) { add@@ Propos@@ al ( result . get ( i ) , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c fin@@ der@@ _c@@ ls = new SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c ( getIndex@@ Iterator ( ) , matcher ) ; List < IS@@ V@@ DB@@ Child@@ Item > cl@@ _@@ l = fin@@ der@@ _c@@ ls . find ( ctxt . f@@ Lea@@ f ) ; if ( cl@@ _@@ l . size ( ) > 0 ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\" retur@@ ned " + cl@@ _@@ l . size ( ) ) ; for ( IS@@ V@@ DB@@ Child@@ Item cl : cl@@ _@@ l ) { f@@ Log . debug ( " " + cl . getType ( ) + " " + SV@@ DB@@ Item . getName ( cl ) ) ; } for ( IS@@ V@@ DB@@ Item@@ Base it : cl@@ _@@ l ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "" ) ; } SV@@ DB@@ Find@@ ByName fin@@ der@@ _@@ t@@ f = new SV@@ DB@@ Find@@ ByName ( getIndex@@ Iterator ( ) , matcher ) ; List < IS@@ V@@ DB@@ Item@@ Base > it@@ _@@ l = fin@@ der@@ _@@ t@@ f . find ( ctxt . f@@ Lea@@ f ) ; for ( int i = 0 ; i < it@@ _@@ l . size ( ) ; i ++ ) { if ( it@@ _@@ l . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Function || it@@ _@@ l . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Task ) { SV@@ DB@@ Task t@@ f = ( SV@@ DB@@ Task ) it@@ _@@ l . get ( i ) ; if ( ( t@@ f . get@@ Attr ( ) & I@@ Field@@ Item@@ Attr . Field@@ Attr@@ _@@ Ex@@ tern ) == 0 && t@@ f . getName ( ) . contains ( ":@@ :" ) ) { it@@ _@@ l . remove ( i ) ; i -- ; } IS@@ V@@ DB@@ Item@@ Base s@@ cop@@ e_@@ t = t@@ f ; while ( s@@ cop@@ e_@@ t != null && s@@ cop@@ e_@@ t . getType ( ) != SV@@ DB@@ Item@@ Type . Class@@ Decl && s@@ cop@@ e_@@ t . getType ( ) != SV@@ DB@@ Item@@ Type . Module@@ Decl ) { s@@ cop@@ e_@@ t = ( ( IS@@ V@@ DB@@ Child@@ Item ) s@@ cop@@ e_@@ t ) . getParent ( ) ; } if ( s@@ cop@@ e_@@ t != null && ( s@@ cop@@ e_@@ t . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl || s@@ cop@@ e_@@ t . getType ( ) == SV@@ DB@@ Item@@ Type . Module@@ Decl ) ) { it@@ _@@ l . remove ( i ) ; i -- ; } } } if ( it@@ _@@ l != null && it@@ _@@ l . size ( ) > 0 ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\" retur@@ ned@@ :" ) ; for ( IS@@ V@@ DB@@ Item@@ Base it : it@@ _@@ l ) { f@@ Log . debug ( " " + it . getType ( ) + " " + ( ( IS@@ V@@ DB@@ Named@@ Item ) it ) . getName ( ) ) ; } for ( IS@@ V@@ DB@@ Item@@ Base it : it@@ _@@ l ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "" ) ; } f@@ Log . debug ( "" + ( ( item != null ) ? item . getType ( ) : "null" ) ) ; if ( item != null && ( item . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl ) && ( "@@ new@@ " . startsWith ( ctxt . f@@ Lea@@ f ) || ctxt . f@@ Lea@@ f . equals ( "" ) ) ) { SV@@ DB@@ Class@@ Decl cls = ( SV@@ DB@@ Class@@ Decl ) item ; f@@ Log . debug ( "" + SV@@ DB@@ Item . getName ( item ) ) ; for ( IS@@ V@@ DB@@ Child@@ Item c : cls . getChildren ( ) ) { if ( c . getType ( ) == SV@@ DB@@ Item@@ Type . Function ) { SV@@ DB@@ Function f = ( SV@@ DB@@ Function ) c ; if ( f . getName ( ) . equals ( "@@ new@@ " ) ) { add@@ Propos@@ al ( c , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } } } private void find@@ Port@@ CompletionPropos@@ als ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Child@@ Parent src@@ _@@ scope , int lin@@ en@@ o , int line@@ pos ) { f@@ Log . debug ( "" ) ; SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; f@@ Log . debug ( "1" ) ; if ( src@@ _@@ scope == null || ( src@@ _@@ scope . getType ( ) != SV@@ DB@@ Item@@ Type . Module@@ Decl && src@@ _@@ scope . getType ( ) != SV@@ DB@@ Item@@ Type . Interface@@ Decl ) ) { f@@ Log . debug ( "" + src@@ _@@ scope + ")" ) ; return ; } f@@ Log . debug ( "2" ) ; SV@@ DB@@ Mod@@ If@@ c@@ In@@ st inst = find@@ In@@ st ( src@@ _@@ scope , lin@@ en@@ o , line@@ pos ) ; f@@ Log . debug ( "@@ 3" ) ; if ( inst == null ) { f@@ Log . debug ( "" ) ; return ; } f@@ Log . debug ( "@@ 4" ) ; f@@ Log . debug ( "" + inst . getType@@ Name ( ) ) ; SV@@ DB@@ Mod@@ If@@ c@@ Decl dec@@ l ; SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c fin@@ der = new SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c ( getIndex@@ Iterator ( ) ) ; List < IS@@ V@@ DB@@ Child@@ Item > result = fin@@ der . find ( inst . getType@@ Name ( ) ) ; if ( result . size ( ) > 0 && ( result . get ( 0 ) . getType ( ) == SV@@ DB@@ Item@@ Type . Module@@ Decl || result . get ( 0 ) . getType ( ) == SV@@ DB@@ Item@@ Type . Interface@@ Decl ) ) { dec@@ l = ( SV@@ DB@@ Mod@@ If@@ c@@ Decl ) result . get ( 0 ) ; } else { f@@ Log . debug ( "" + inst . getType@@ Name ( ) + "\"" ) ; return ; } for ( SV@@ DB@@ Param@@ Port@@ Decl p : dec@@ l . getPort@@ s ( ) ) { for ( IS@@ V@@ DB@@ Child@@ Item pi : p . getChildren ( ) ) { if ( matcher . match ( ( IS@@ V@@ DB@@ Named@@ Item ) pi , ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( pi , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } f@@ Log . debug ( "" ) ; } private SV@@ DB@@ Mod@@ If@@ c@@ In@@ st find@@ In@@ st ( IS@@ V@@ DB@@ Child@@ Parent p , int lin@@ en@@ o , int line@@ pos ) { SV@@ DB@@ Mod@@ If@@ c@@ In@@ st last@@ _@@ inst = null ; for ( IS@@ V@@ DB@@ Child@@ Item c : p . getChildren ( ) ) { if ( c . getType ( ) == SV@@ DB@@ Item@@ Type . Mod@@ If@@ c@@ In@@ st ) { last@@ _@@ inst = ( SV@@ DB@@ Mod@@ If@@ c@@ In@@ st ) c ; if ( c . getLocation ( ) . getL@@ ine ( ) > lin@@ en@@ o ) { break ; } } else if ( c instanceof IS@@ V@@ DB@@ Child@@ Parent ) { if ( c . getLocation ( ) != null && c . getLocation ( ) . getL@@ ine ( ) > lin@@ en@@ o ) { break ; } if ( ( last@@ _@@ inst = find@@ In@@ st ( ( IS@@ V@@ DB@@ Child@@ Parent ) c , lin@@ en@@ o , line@@ pos ) ) != null ) { break ; } } } return last@@ _@@ inst ; } private void find@@ End@@ Label@@ Propos@@ als ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Child@@ Item src@@ _@@ scope ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\"" ) ; f@@ Log . debug ( "" + SV@@ DB@@ Item . getName ( src@@ _@@ scope ) ) ; if ( src@@ _@@ scope == null || ! ( src@@ _@@ scope instanceof IS@@ V@@ DB@@ Named@@ Item ) ) { return ; } IS@@ V@@ DB@@ Named@@ Item item = ( IS@@ V@@ DB@@ Named@@ Item ) src@@ _@@ scope ; if ( ctxt . f@@ Lea@@ f . equals ( "" ) || item . getName ( ) . startsWith ( ctxt . f@@ Lea@@ f ) ) { add@@ Propos@@ al ( new SV@@ CompletionPropos@@ al ( ( ( IS@@ V@@ DB@@ Named@@ Item ) src@@ _@@ scope ) . getName ( ) , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ) ; } else { find@@ Un@@ trig@@ ger@@ ed@@ Propos@@ als ( ctxt , src@@ _@@ scope ) ; } } private void find@@ Un@@ trig@@ ger@@ ed@@ Propos@@ als ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Child@@ Item src@@ _@@ scope ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\"" ) ; List < IS@@ V@@ DB@@ Item@@ Base > result = null ; SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; SV@@ DB@@ Find@@ By@@ Name@@ In@@ Scop@@ es fin@@ der@@ _@@ s = new SV@@ DB@@ Find@@ By@@ Name@@ In@@ Scop@@ es ( getIndex@@ Iterator ( ) , matcher ) ; f@@ Log . debug ( "" ) ; result = fin@@ der@@ _@@ s . find ( src@@ _@@ scope , ctxt . f@@ Lea@@ f , false ) ; f@@ Log . debug ( " " + result . size ( ) + " result@@ s" ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { if ( ! ( SV@@ DB@@ Item . getName ( result . get ( i ) ) . equals ( ctxt . f@@ Lea@@ f ) && is@@ Same@@ Scope@@ Var@@ Decl ( src@@ _@@ scope , result . get ( i ) ) ) ) { add@@ Propos@@ al ( result . get ( i ) , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } SV@@ DB@@ Find@@ By@@ Name@@ In@@ Class@@ Hierarch@@ y fin@@ der@@ _@@ h = new SV@@ DB@@ Find@@ By@@ Name@@ In@@ Class@@ Hierarch@@ y ( getIndex@@ Iterator ( ) , matcher ) ; result = fin@@ der@@ _@@ h . find ( src@@ _@@ scope , ctxt . f@@ Lea@@ f ) ; if ( result . size ( ) > 0 ) { for ( int i = 0 ; i < result . size ( ) ; i ++ ) { boolean add = true ; if ( ctxt . f@@ Trig@@ ger != null && ctxt . f@@ Trig@@ ger . equals ( "=" ) && "@@ new@@ " . startsWith ( ctxt . f@@ Lea@@ f ) ) { if ( result . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Function && ( ( IS@@ V@@ DB@@ Named@@ Item ) result . get ( i ) ) . getName ( ) . equals ( "@@ new@@ " ) ) { add = false ; } } if ( ctxt . f@@ Type == Context@@ Type . Ext@@ ends ) { f@@ Log . debug ( "@@ Ext@@ end@@ s@@ : " + result . get ( i ) . getType ( ) ) ; if ( result . get ( i ) . getType ( ) != SV@@ DB@@ Item@@ Type . Class@@ Decl ) { add = false ; } } if ( add ) { add@@ Propos@@ al ( result . get ( i ) , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c fin@@ der@@ _c@@ ls = new SV@@ DB@@ Find@@ Named@@ Mod@@ If@@ c@@ Class@@ If@@ c ( getIndex@@ Iterator ( ) , matcher ) ; List < IS@@ V@@ DB@@ Child@@ Item > cl@@ _@@ l = fin@@ der@@ _c@@ ls . find ( ctxt . f@@ Lea@@ f ) ; if ( cl@@ _@@ l . size ( ) > 0 ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\" retur@@ ned " + cl@@ _@@ l . size ( ) ) ; for ( IS@@ V@@ DB@@ Child@@ Item cl : cl@@ _@@ l ) { f@@ Log . debug ( " " + cl . getType ( ) + " " + SV@@ DB@@ Item . getName ( cl ) ) ; } for ( IS@@ V@@ DB@@ Item@@ Base it : cl@@ _@@ l ) { if ( ctxt . f@@ Type == Context@@ Type . Ext@@ ends ) { if ( it . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } else { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "" ) ; } if ( ctxt . f@@ Type != Context@@ Type . Ext@@ ends ) { SV@@ DB@@ Find@@ ByName fin@@ der@@ _@@ t@@ f = new SV@@ DB@@ Find@@ ByName ( getIndex@@ Iterator ( ) , matcher ) ; List < IS@@ V@@ DB@@ Item@@ Base > it@@ _@@ l = fin@@ der@@ _@@ t@@ f . find ( ctxt . f@@ Lea@@ f , SV@@ DB@@ Item@@ Type . Task , SV@@ DB@@ Item@@ Type . Function , SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Stmt , SV@@ DB@@ Item@@ Type . Package@@ Decl , SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) ; for ( int i = 0 ; i < it@@ _@@ l . size ( ) ; i ++ ) { if ( it@@ _@@ l . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Function || it@@ _@@ l . get ( i ) . getType ( ) == SV@@ DB@@ Item@@ Type . Task ) { SV@@ DB@@ Task t@@ f = ( SV@@ DB@@ Task ) it@@ _@@ l . get ( i ) ; if ( ( t@@ f . get@@ Attr ( ) & I@@ Field@@ Item@@ Attr . Field@@ Attr@@ _@@ Ex@@ tern ) == 0 && t@@ f . getName ( ) . contains ( ":@@ :" ) ) { it@@ _@@ l . remove ( i ) ; i -- ; } IS@@ V@@ DB@@ Item@@ Base s@@ cop@@ e_@@ t = t@@ f ; while ( s@@ cop@@ e_@@ t != null && s@@ cop@@ e_@@ t . getType ( ) != SV@@ DB@@ Item@@ Type . Class@@ Decl && s@@ cop@@ e_@@ t . getType ( ) != SV@@ DB@@ Item@@ Type . Module@@ Decl ) { s@@ cop@@ e_@@ t = ( ( IS@@ V@@ DB@@ Child@@ Item ) s@@ cop@@ e_@@ t ) . getParent ( ) ; } if ( s@@ cop@@ e_@@ t != null && ( s@@ cop@@ e_@@ t . getType ( ) == SV@@ DB@@ Item@@ Type . Class@@ Decl || s@@ cop@@ e_@@ t . getType ( ) == SV@@ DB@@ Item@@ Type . Module@@ Decl ) ) { it@@ _@@ l . remove ( i ) ; i -- ; } } } if ( it@@ _@@ l != null && it@@ _@@ l . size ( ) > 0 ) { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "\" retur@@ ned@@ :" ) ; for ( IS@@ V@@ DB@@ Item@@ Base it : it@@ _@@ l ) { f@@ Log . debug ( " " + it . getType ( ) + " " + ( ( IS@@ V@@ DB@@ Named@@ Item ) it ) . getName ( ) ) ; } for ( IS@@ V@@ DB@@ Item@@ Base it : it@@ _@@ l ) { add@@ Propos@@ al ( it , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { f@@ Log . debug ( "" + ctxt . f@@ Lea@@ f + "" ) ; } } } private boolean is@@ Same@@ Scope@@ Var@@ Decl ( IS@@ V@@ DB@@ Child@@ Item src@@ _@@ scope , IS@@ V@@ DB@@ Item@@ Base pro@@ pos@@ al ) { if ( pro@@ pos@@ al instanceof SV@@ DB@@ Var@@ Decl@@ Item ) { SV@@ DB@@ Var@@ Decl@@ Item v = ( SV@@ DB@@ Var@@ Decl@@ Item ) pro@@ pos@@ al ; if ( v . getParent ( ) != null && v . getParent ( ) . getParent ( ) != null ) { return ( v . getParent ( ) . getParent ( ) == src@@ _@@ scope ) ; } } return false ; } private void find@@ M@@ ac@@ ro@@ Items ( SV@@ Expr@@ Context ctxt , IS@@ V@@ DB@@ Index@@ Iterator index@@ _@@ it ) { SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher matcher = new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( ) ; if ( ctxt . f@@ Root != null && ctxt . f@@ Root . equals ( "@@ include@@ " ) ) { SV@@ DB@@ Find@@ Inclu@@ ded@@ File fin@@ der = new SV@@ DB@@ Find@@ Inclu@@ ded@@ File ( index@@ _@@ it , matcher ) ; List < SV@@ DB@@ File > it@@ _@@ l = fin@@ der . find ( ctxt . f@@ Lea@@ f ) ; if ( it@@ _@@ l . size ( ) > 0 ) { add@@ Propos@@ al ( it@@ _@@ l . get ( 0 ) , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } else { List < SV@@ DB@@ Decl@@ Cache@@ Item > result = index@@ _@@ it . find@@ Global@@ Scope@@ Decl ( new Null@@ ProgressMonitor ( ) , ctxt . f@@ Lea@@ f , new SV@@ DB@@ Find@@ Content@@ As@@ sist@@ Name@@ Matcher ( SV@@ DB@@ Item@@ Type . M@@ ac@@ ro@@ Def ) ) ; for ( SV@@ DB@@ Decl@@ Cache@@ Item i : result ) { f@@ Log . debug ( LE@@ VE@@ L_@@ M@@ ID , "M@@ ac@@ ro@@ : " + i . getName ( ) ) ; add@@ Propos@@ al ( i . getS@@ V@@ DB@@ Item ( ) , ctxt . f@@ Lea@@ f , ctxt . f@@ Start , ctxt . f@@ Lea@@ f . length ( ) ) ; } } } private IS@@ V@@ DB@@ Item@@ Base getItem@@ Type ( IS@@ V@@ DB@@ Item@@ Base item ) { SV@@ DB@@ TypeInfo t@@ i = null ; if ( item . getType ( ) == SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Stmt ) { t@@ i = ( ( SV@@ DB@@ Var@@ Decl@@ Stmt ) item ) . getType@@ Info ( ) ; } else if ( item . getType ( ) == SV@@ DB@@ Item@@ Type . Var@@ Decl@@ Item ) { SV@@ DB@@ Var@@ Decl@@ Item v@@ i = ( SV@@ DB@@ Var@@ Decl@@ Item ) item ; if ( v@@ i . getParent ( ) != null ) { t@@ i = v@@ i . getParent ( ) . getType@@ Info ( ) ; } } if ( t@@ i != null ) { IS@@ V@@ DB@@ Item@@ Base target = resolve@@ Type ( t@@ i ) ; if ( target != null ) { return target ; } } return t@@ i ; } private IS@@ V@@ DB@@ Item@@ Base resolve@@ Type ( SV@@ DB@@ TypeInfo t@@ i ) { IS@@ V@@ DB@@ Item@@ Base target = null ; if ( t@@ i . getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ User@@ Def ) { SV@@ DB@@ Find@@ ByName fin@@ der = new SV@@ DB@@ Find@@ ByName ( getIndex@@ Iterator ( ) ) ; List < IS@@ V@@ DB@@ Item@@ Base > ret = fin@@ der . find ( t@@ i . getName ( ) ) ; if ( ret . size ( ) > 0 ) { target = ret . get ( 0 ) ; } } else if ( t@@ i . getType ( ) == SV@@ DB@@ Item@@ Type . Type@@ Info@@ Struct ) { } else { } if ( target != null ) { if ( target . getType ( ) == SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) { target = resolve@@ Type ( ( ( SV@@ DB@@ Typed@@ ef@@ Stmt ) target ) . getType@@ Info ( ) ) ; } } return target ; } protected boolean is@@ Prefix ( String pr@@ e , SV@@ DB@@ Item it ) { return it . getName ( ) . toLowerCase ( ) . startsWith ( pr@@ e . toLowerCase ( ) ) ; } private void order@@ _@@ pro@@ pos@@ als ( String prefix , List < SV@@ CompletionPropos@@ al > pro@@ pos@@ als ) { synchronized ( pro@@ pos@@ als ) { for ( int i = 0 ; i < pro@@ pos@@ als . size ( ) ; i ++ ) { SV@@ CompletionPropos@@ al p = pro@@ pos@@ als . get ( i ) ; if ( p . getItem ( ) != null && SV@@ DB@@ Stmt . is@@ Type ( p . getItem ( ) , SV@@ DB@@ Item@@ Type . Typed@@ ef@@ Stmt ) ) { boolean found = false ; for ( SV@@ CompletionPropos@@ al p_@@ t : pro@@ pos@@ als ) { if ( p_@@ t != p && p_@@ t . getItem ( ) != null && SV@@ DB@@ Item . getName ( p_@@ t . getItem ( ) ) . equals ( SV@@ DB@@ Item . getName ( p . getItem ( ) ) ) ) { found = true ; break ; } } if ( found ) { pro@@ pos@@ als . remove ( i ) ; i -- ; } } } for ( int i = 0 ; i < pro@@ pos@@ als . size ( ) ; i ++ ) { SV@@ CompletionPropos@@ al p_@@ i = pro@@ pos@@ als . get ( i ) ; for ( int j = i + 1 ; j < pro@@ pos@@ als . size ( ) ; j ++ ) { SV@@ CompletionPropos@@ al p_@@ j = pro@@ pos@@ als . get ( j ) ; String s_@@ i , s_@@ j ; if ( p_@@ i . getItem ( ) != null ) { s_@@ i = SV@@ DB@@ Item . getName ( p_@@ i . getItem ( ) ) ; } else { s_@@ i = p_@@ i . get@@ Repl@@ acement ( ) ; } if ( p_@@ j . getItem ( ) != null ) { s_@@ j = SV@@ DB@@ Item . getName ( p_@@ j . getItem ( ) ) ; } else { s_@@ j = p_@@ j . get@@ Repl@@ acement ( ) ; } if ( s_@@ i . compareTo ( s_@@ j ) > 0 ) { pro@@ pos@@ als . set ( i , p_@@ j ) ; pro@@ pos@@ als . set ( j , p_@@ i ) ; p_@@ i = p_@@ j ; } } } for ( int i = 0 ; i < pro@@ pos@@ als . size ( ) ; i ++ ) { SV@@ CompletionPropos@@ al p_@@ i = pro@@ pos@@ als . get ( i ) ; for ( int j = i + 1 ; j < pro@@ pos@@ als . size ( ) ; j ++ ) { SV@@ CompletionPropos@@ al p_@@ j = pro@@ pos@@ als . get ( j ) ; String s_@@ i , s_@@ j ; if ( p_@@ i . getItem ( ) != null ) { s_@@ i = SV@@ DB@@ Item . getName ( p_@@ i . getItem ( ) ) ; } else { s_@@ i = p_@@ i . get@@ Repl@@ acement ( ) ; } if ( p_@@ j . getItem ( ) != null ) { s_@@ j = SV@@ DB@@ Item . getName ( p_@@ j . getItem ( ) ) ; } else { s_@@ j = p_@@ j . get@@ Repl@@ acement ( ) ; } if ( prefix . compareTo ( s_@@ i ) < prefix . compareTo ( s_@@ j ) ) { pro@@ pos@@ als . set ( i , p_@@ j ) ; pro@@ pos@@ als . set ( j , p_@@ i ) ; p_@@ i = p_@@ j ; } } } } } protected void add@@ Propos@@ al ( IS@@ V@@ DB@@ Item@@ Base it , String prefix , int repl@@ ac@@ ement@@ Offset , int repl@@ ac@@ ement@@ Length ) { add@@ Propos@@ al ( it , prefix , false , repl@@ ac@@ ement@@ Offset , repl@@ ac@@ ement@@ Length ) ; } protected void add@@ Propos@@ al ( IS@@ V@@ DB@@ Item@@ Base it , String prefix , boolean name@@ _b@@ as@@ ed@@ _@@ check , int repl@@ ac@@ ement@@ Offset , int repl@@ ac@@ ement@@ Length ) { boolean found = false ; synchronized ( f@@ CompletionPropos@@ als ) { for ( SV@@ CompletionPropos@@ al p : f@@ CompletionPropos@@ als ) { if ( p . getItem ( ) != null ) { if ( p . getItem ( ) == it ) { found = true ; break ; } else if ( name@@ _b@@ as@@ ed@@ _@@ check ) { if ( p . getItem ( ) instanceof IS@@ V@@ DB@@ Named@@ Item && it instanceof IS@@ V@@ DB@@ Named@@ Item ) { IS@@ V@@ DB@@ Named@@ Item i1 = ( IS@@ V@@ DB@@ Named@@ Item ) p . getItem ( ) ; IS@@ V@@ DB@@ Named@@ Item i2 = ( IS@@ V@@ DB@@ Named@@ Item ) it ; if ( i1 . getName ( ) == null || i1 . getName ( ) == null ) { if ( i1 . getName ( ) == i2 . getName ( ) ) { found = true ; break ; } } else if ( i1 . getName ( ) . equals ( i2 . getName ( ) ) ) { found = true ; break ; } } } } } if ( ! found ) { debug ( "" + SV@@ DB@@ Item . getName ( it ) + " " + it . getType ( ) ) ; add@@ Propos@@ al ( new SV@@ CompletionPropos@@ al ( it , prefix , repl@@ ac@@ ement@@ Offset , repl@@ ac@@ ement@@ Length ) ) ; } } } protected void debug ( String msg ) { f@@ Log . debug ( msg ) ; } } </s>
<s> package net . sf . sv@@ editor . core . content@@ _@@ assist ; import java . util . ArrayList ; import net . sf . sv@@ editor . core . db . IS@@ V@@ DB@@ Child@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Item ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Mod@@ If@@ c@@ Decl ; import net . sf . sv@@ editor . core . db . SV@@ DB@@ Task ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Param@@ Port@@ Decl ; import net . sf . sv@@ editor . core . db . stmt . SV@@ DB@@ Var@@ Decl@@ Item ; public class SV@@ CompletionPropos@@ al@@ Utils { private int f@@ T@@ F@@ Max@@ Char@@ sPer@@ Line = 80 ; private int f@@ T@@ F@@ Port@@ sPer@@ Line = 0 ; private boolean f@@ T@@ F@@ Named@@ Port@@ s = true ; private int f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line = 80 ; private int f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line = 1 ; private boolean f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s = true ; public SV@@ CompletionPropos@@ al@@ Utils ( ) { } public void setT@@ F@@ Max@@ Char@@ sPer@@ Line ( int max ) { f@@ T@@ F@@ Max@@ Char@@ sPer@@ Line = max ; } public void setT@@ F@@ Port@@ sPer@@ Line ( int max ) { f@@ T@@ F@@ Port@@ sPer@@ Line = max ; } public void setT@@ F@@ Named@@ Port@@ s ( boolean nam@@ ed ) { f@@ T@@ F@@ Named@@ Port@@ s = nam@@ ed ; } public void set@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line ( int max ) { f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line = max ; } public void set@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line ( int max ) { f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line = max ; } public void set@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s ( boolean nam@@ ed ) { f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s = nam@@ ed ; } private static String escape@@ Id ( String id ) { StringBuilder sb = new StringBuilder ( id ) ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { if ( sb . charAt ( i ) == '@@ $@@ ' ) { sb . insert ( i , '@@ $@@ ' ) ; i ++ ; } } return sb . toString ( ) ; } public static String getLine@@ Ind@@ ent ( String doc , String ind@@ ent@@ _@@ inc@@ r ) { StringBuilder doc@@ _@@ str = new StringBuilder ( doc ) ; int last@@ _@@ line@@ _@@ idx = doc@@ _@@ str . lastIndexOf ( "n" ) ; String indent = "" ; if ( last@@ _@@ line@@ _@@ idx != - 1 ) { int end@@ _@@ line@@ _@@ idx = last@@ _@@ line@@ _@@ idx ; while ( end@@ _@@ line@@ _@@ idx < doc@@ _@@ str . length ( ) && Character . is@@ Whit@@ espace ( doc@@ _@@ str . charAt ( end@@ _@@ line@@ _@@ idx ) ) ) { end@@ _@@ line@@ _@@ idx ++ ; } indent = doc@@ _@@ str . substring ( last@@ _@@ line@@ _@@ idx + 1 , end@@ _@@ line@@ _@@ idx ) ; } return indent ; } public String create@@ T@@ F@@ Template ( SV@@ DB@@ Task t@@ f , String sub@@ se@@ q_@@ line@@ _@@ indent , int first@@ _@@ line@@ _@@ pos , int sub@@ se@@ q_@@ line@@ _@@ pos ) { String new@@ line = "n" + sub@@ se@@ q_@@ line@@ _@@ indent ; StringBuilder r = new StringBuilder ( ) ; int curr@@ _@@ pos = first@@ _@@ line@@ _@@ pos ; int long@@ est@@ _@@ string = 0 ; int port@@ _@@ length = 0 ; int port@@ _@@ count = 0 ; ArrayList < String > all@@ _@@ port@@ s = new ArrayList < String > ( ) ; ArrayList < String > all@@ _@@ types = new ArrayList < String > ( ) ; for ( int i = 0 ; i < t@@ f . getPar@@ ams ( ) . size ( ) ; i ++ ) { SV@@ DB@@ Param@@ Port@@ Decl param = t@@ f . getPar@@ ams ( ) . get ( i ) ; for ( IS@@ V@@ DB@@ Child@@ Item c : param . getChildren ( ) ) { SV@@ DB@@ Var@@ Decl@@ Item v@@ i = ( SV@@ DB@@ Var@@ Decl@@ Item ) c ; all@@ _@@ port@@ s . add ( v@@ i . getName ( ) ) ; all@@ _@@ types . add ( param . getType@@ Name ( ) ) ; port@@ _@@ count ++ ; port@@ _@@ length += v@@ i . getName ( ) . length ( ) ; if ( v@@ i . getName ( ) . length ( ) > long@@ est@@ _@@ string ) { long@@ est@@ _@@ string = v@@ i . getName ( ) . length ( ) ; } } } boolean multi@@ _@@ line@@ _@@ instan@@ ti@@ ation = false ; int multi@@ pli@@ er = f@@ T@@ F@@ Named@@ Port@@ s ? 2 : 1 ; if ( ( ( f@@ T@@ F@@ Max@@ Char@@ sPer@@ Line != 0 ) && ( ( first@@ _@@ line@@ _@@ pos + ( port@@ _@@ length * multi@@ pli@@ er ) + ( 2 * multi@@ pli@@ er ) ) > ( ( f@@ T@@ F@@ Max@@ Char@@ sPer@@ Line * 7 ) / 8 ) ) ) || ( ( f@@ T@@ F@@ Port@@ sPer@@ Line != 0 ) && ( port@@ _@@ count > f@@ T@@ F@@ Port@@ sPer@@ Line ) ) ) { multi@@ _@@ line@@ _@@ instan@@ ti@@ ation = true ; curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; } else { new@@ line = "" ; } r . append ( escape@@ Id ( SV@@ DB@@ Item . getName ( t@@ f ) ) + "(" + new@@ line ) ; for ( int i = 0 ; i < port@@ _@@ count ; i ++ ) { StringBuilder padd@@ ing = new StringBuilder ( "" ) ; String name@@ _@@ str = all@@ _@@ port@@ s . get ( i ) ; if ( multi@@ _@@ line@@ _@@ instan@@ ti@@ ation ) { for ( int cnt = name@@ _@@ str . length ( ) ; cnt < long@@ est@@ _@@ string + 1 ; cnt ++ ) { padd@@ ing . append ( " " ) ; } } if ( f@@ T@@ F@@ Named@@ Port@@ s == true ) { r . append ( "." ) ; r . append ( name@@ _@@ str + padd@@ ing . toString ( ) ) ; r . append ( " (" ) ; curr@@ _@@ pos += 3 + name@@ _@@ str . length ( ) + padd@@ ing . toString ( ) . length ( ) ; } r . append ( "$@@ {@@ " + all@@ _@@ port@@ s . get ( i ) + "}" + padd@@ ing . toString ( ) ) ; curr@@ _@@ pos += 3 + all@@ _@@ port@@ s . get ( i ) . length ( ) + padd@@ ing . toString ( ) . length ( ) ; if ( f@@ T@@ F@@ Named@@ Port@@ s == true ) { r . append ( ")" ) ; curr@@ _@@ pos ++ ; } if ( i + 1 < port@@ _@@ count ) { r . append ( ", " ) ; curr@@ _@@ pos += 2 ; if ( ( f@@ T@@ F@@ Port@@ sPer@@ Line != 0 && multi@@ _@@ line@@ _@@ instan@@ ti@@ ation && ( ( ( i + 1 ) % f@@ T@@ F@@ Port@@ sPer@@ Line ) == 0 ) ) || ( curr@@ _@@ pos > ( 7 * f@@ T@@ F@@ Max@@ Char@@ sPer@@ Line ) / 8 ) ) { r . append ( new@@ line ) ; curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; } } } r . append ( ")" ) ; return r . toString ( ) ; } public String create@@ Module@@ Template ( SV@@ DB@@ Mod@@ If@@ c@@ Decl t@@ f , String sub@@ se@@ q_@@ line@@ _@@ indent , int first@@ _@@ line@@ _@@ pos , int sub@@ se@@ q_@@ line@@ _@@ pos ) { String new@@ line = "n" + sub@@ se@@ q_@@ line@@ _@@ indent ; StringBuilder r = new StringBuilder ( ) ; int curr@@ _@@ pos = first@@ _@@ line@@ _@@ pos ; int long@@ est@@ _@@ string = 0 ; int port@@ _@@ len = 0 ; int param@@ _@@ len = 0 ; int port@@ _@@ count = 0 ; int param@@ _@@ count = 0 ; ArrayList < String > all@@ _@@ port@@ s = new ArrayList < String > ( ) ; ArrayList < String > all@@ _@@ types = new ArrayList < String > ( ) ; ArrayList < String > all@@ _@@ params = new ArrayList < String > ( ) ; for ( int i = 0 ; i < t@@ f . getParameters ( ) . size ( ) ; i ++ ) { String param@@ _name = t@@ f . getParameters ( ) . get ( i ) . getName ( ) ; all@@ _@@ params . add ( param@@ _name ) ; param@@ _@@ count ++ ; int len = param@@ _name . length ( ) ; param@@ _@@ len += len ; if ( len > long@@ est@@ _@@ string ) { long@@ est@@ _@@ string = len ; } } for ( int i = 0 ; i < t@@ f . getPort@@ s ( ) . size ( ) ; i ++ ) { SV@@ DB@@ Param@@ Port@@ Decl param = t@@ f . getPort@@ s ( ) . get ( i ) ; for ( IS@@ V@@ DB@@ Child@@ Item c : param . getChildren ( ) ) { SV@@ DB@@ Var@@ Decl@@ Item v@@ i = ( SV@@ DB@@ Var@@ Decl@@ Item ) c ; all@@ _@@ port@@ s . add ( v@@ i . getName ( ) ) ; all@@ _@@ types . add ( param . getType@@ Name ( ) ) ; port@@ _@@ count ++ ; int len = v@@ i . getName ( ) . length ( ) ; port@@ _@@ len += len ; if ( len > long@@ est@@ _@@ string ) { long@@ est@@ _@@ string = len ; } } } boolean multi@@ _@@ line@@ _@@ instan@@ ti@@ ation = false ; int multi@@ pli@@ er = f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s ? 2 : 1 ; if ( ( ( f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line != 0 ) && ( ( first@@ _@@ line@@ _@@ pos + ( ( port@@ _@@ len + param@@ _@@ len ) * multi@@ pli@@ er ) + ( 2 * multi@@ pli@@ er ) ) > ( ( f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line * 7 ) / 8 ) ) ) || ( ( f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line != 0 ) && ( ( port@@ _@@ count > f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line ) || ( param@@ _@@ count > f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line ) ) ) ) { multi@@ _@@ line@@ _@@ instan@@ ti@@ ation = true ; curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; } else { new@@ line = "" ; } r . append ( escape@@ Id ( SV@@ DB@@ Item . getName ( t@@ f ) ) ) ; if ( param@@ _@@ count != 0 ) { r . append ( " #@@ (" + new@@ line ) ; for ( int i = 0 ; i < param@@ _@@ count ; i ++ ) { StringBuilder padd@@ ing = new StringBuilder ( "" ) ; String name@@ _@@ str = all@@ _@@ params . get ( i ) ; if ( multi@@ _@@ line@@ _@@ instan@@ ti@@ ation ) { for ( int cnt = name@@ _@@ str . length ( ) ; cnt < long@@ est@@ _@@ string + 1 ; cnt ++ ) { padd@@ ing . append ( " " ) ; } } if ( f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s == true ) { r . append ( "." ) ; r . append ( name@@ _@@ str + padd@@ ing . toString ( ) ) ; r . append ( " (" ) ; curr@@ _@@ pos += 3 + name@@ _@@ str . length ( ) + padd@@ ing . toString ( ) . length ( ) ; } r . append ( "$@@ {@@ " + name@@ _@@ str + "}" + padd@@ ing . toString ( ) ) ; curr@@ _@@ pos += 3 + name@@ _@@ str . length ( ) + padd@@ ing . toString ( ) . length ( ) ; if ( f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s == true ) { r . append ( ")" ) ; curr@@ _@@ pos ++ ; } if ( i + 1 < param@@ _@@ count ) { r . append ( ", " ) ; curr@@ _@@ pos += 2 ; if ( ( f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line != 0 && multi@@ _@@ line@@ _@@ instan@@ ti@@ ation && ( ( ( i + 1 ) % f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line ) == 0 ) ) || ( curr@@ _@@ pos > ( 7 * f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line ) / 8 ) ) { r . append ( new@@ line ) ; curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; } } } r . append ( escape@@ Id ( new@@ line + ")" ) ) ; } r . append ( " $@@ {@@ " + escape@@ Id ( SV@@ DB@@ Item . getName ( t@@ f ) ) + "}" + " (" + new@@ line ) ; if ( ! new@@ line . isEmpty ( ) ) curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; for ( int i = 0 ; i < port@@ _@@ count ; i ++ ) { StringBuilder padd@@ ing = new StringBuilder ( "" ) ; String name@@ _@@ str = all@@ _@@ port@@ s . get ( i ) ; if ( multi@@ _@@ line@@ _@@ instan@@ ti@@ ation ) { for ( int cnt = name@@ _@@ str . length ( ) ; cnt < long@@ est@@ _@@ string + 1 ; cnt ++ ) { padd@@ ing . append ( " " ) ; } } if ( f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s == true ) { r . append ( "." ) ; r . append ( name@@ _@@ str + padd@@ ing . toString ( ) ) ; r . append ( " (" ) ; curr@@ _@@ pos += 3 + name@@ _@@ str . length ( ) + padd@@ ing . toString ( ) . length ( ) ; } r . append ( "$@@ {@@ " + all@@ _@@ port@@ s . get ( i ) + "}" + padd@@ ing . toString ( ) ) ; curr@@ _@@ pos += 3 + all@@ _@@ port@@ s . get ( i ) . length ( ) + padd@@ ing . toString ( ) . length ( ) ; if ( f@@ Mod@@ If@@ c@@ In@@ st@@ Named@@ Port@@ s == true ) { r . append ( ")" ) ; curr@@ _@@ pos ++ ; } if ( i + 1 < port@@ _@@ count ) { r . append ( ", " ) ; curr@@ _@@ pos += 2 ; if ( ( f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line != 0 && multi@@ _@@ line@@ _@@ instan@@ ti@@ ation && ( ( ( i + 1 ) % f@@ Mod@@ If@@ c@@ In@@ st@@ Port@@ sPer@@ Line ) == 0 ) ) || ( curr@@ _@@ pos > ( 7 * f@@ Mod@@ If@@ c@@ In@@ st@@ Max@@ Char@@ sPer@@ Line ) / 8 ) ) { r . append ( new@@ line ) ; curr@@ _@@ pos = sub@@ se@@ q_@@ line@@ _@@ pos ; } } } r . append ( ")@@ ;" ) ; return r . toString ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . content@@ _@@ assist ; public enum SV@@ CompletionPropos@@ al@@ Type { SV@@ Object , Keyword , Un@@ known } </s>
<s> package net . sf . sv@@ editor . core . indent ; import java . util . List ; public class SV@@ Ind@@ ent@@ Stmt { protected List < SV@@ Ind@@ ent@@ Stmt > f@@ St@@ mt@@ List ; protected SV@@ Ind@@ ent@@ St@@ mt@@ Type f@@ Type ; public SV@@ Ind@@ ent@@ Stmt ( SV@@ Ind@@ ent@@ St@@ mt@@ Type type ) { f@@ Type = type ; } public SV@@ Ind@@ ent@@ St@@ mt@@ Type getType ( ) { return f@@ Type ; } } </s>
<s> package net . sf . sv@@ editor . core . indent ; public class SV@@ Ind@@ ent@@ Token { protected SV@@ Ind@@ ent@@ TokenType f@@ Type ; protected String f@@ Le@@ ad@@ ing@@ WS ; protected String f@@ Tr@@ ail@@ ing@@ WS = "" ; protected String f@@ Image ; protected boolean f@@ End@@ Line ; protected boolean f@@ Start@@ Line ; protected boolean f@@ Do@@ I@@ t ; protected int f@@ Pos ; protected int f@@ Lin@@ en@@ o ; public SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType type , String le@@ ad@@ ing_@@ ws , String image ) { f@@ Type = type ; f@@ Le@@ ad@@ ing@@ WS = le@@ ad@@ ing_@@ ws ; f@@ Tr@@ ail@@ ing@@ WS = "" ; f@@ Image = image ; f@@ Do@@ I@@ t = true ; } protected SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType type , String le@@ ad@@ ing_@@ ws ) { f@@ Type = type ; f@@ Le@@ ad@@ ing@@ WS = le@@ ad@@ ing_@@ ws ; f@@ Tr@@ ail@@ ing@@ WS = "" ; f@@ Image = "" ; f@@ Do@@ I@@ t = true ; } public boolean is@@ Id ( String s ) { return ( getType ( ) == SV@@ Ind@@ ent@@ TokenType . Identifier && get@@ Image ( ) . equals ( s ) ) ; } public boolean is@@ Op ( String ... s ) { if ( getType ( ) == SV@@ Ind@@ ent@@ TokenType . Operator ) { if ( s . length == 0 ) { return true ; } else { for ( String s_@@ i : s ) { if ( get@@ Image ( ) . equals ( s_@@ i ) ) { return true ; } } } } return false ; } public boolean is@@ Pre@@ Pro@@ c ( ) { return ( getType ( ) == SV@@ Ind@@ ent@@ TokenType . Identifier && get@@ Image ( ) . startsWith ( "@@ `@@ " ) ) ; } public void set@@ Pos ( int pos ) { f@@ Pos = pos ; } public int get@@ Pos ( ) { return f@@ Pos ; } public void set@@ Lin@@ en@@ o ( int lin@@ en@@ o ) { f@@ Lin@@ en@@ o = lin@@ en@@ o ; } public int get@@ Lin@@ en@@ o ( ) { return f@@ Lin@@ en@@ o ; } public SV@@ Ind@@ ent@@ TokenType getType ( ) { return f@@ Type ; } public void set@@ Tr@@ ail@@ ing@@ WS ( String tr@@ ail@@ ing_@@ ws ) { f@@ Tr@@ ail@@ ing@@ WS = tr@@ ail@@ ing_@@ ws ; } public String get@@ Tr@@ ail@@ ing@@ WS ( ) { return f@@ Tr@@ ail@@ ing@@ WS ; } public boolean is@@ End@@ Line ( ) { return f@@ End@@ Line ; } public void set@@ Is@@ End@@ Line ( boolean end ) { f@@ End@@ Line = end ; } public boolean is@@ Start@@ Line ( ) { return f@@ Start@@ Line ; } public void set@@ Is@@ Start@@ Line ( boolean start ) { f@@ Start@@ Line = start ; } public String getLe@@ ad@@ ing@@ WS ( ) { return f@@ Le@@ ad@@ ing@@ WS ; } public void set@@ Le@@ ad@@ ing@@ WS ( String le@@ ad@@ ing_@@ ws ) { f@@ Le@@ ad@@ ing@@ WS = le@@ ad@@ ing_@@ ws ; } public String get@@ Image ( ) { return f@@ Image ; } public void set@@ Image ( String image ) { f@@ Image = image ; } public boolean get@@ Do@@ I@@ t ( ) { return f@@ Do@@ I@@ t ; } public void set@@ Do@@ I@@ t ( boolean do@@ it ) { f@@ Do@@ I@@ t = do@@ it ; } public boolean is@@ Blan@@ k@@ Line ( ) { return ( f@@ Start@@ Line && f@@ End@@ Line && f@@ Image . trim ( ) . equals ( "" ) ) ; } public boolean is@@ Comment ( ) { return ( f@@ Type == SV@@ Ind@@ ent@@ TokenType . Single@@ Line@@ Comment || f@@ Type == SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment ) ; } } </s>
<s> package net . sf . sv@@ editor . core . indent ; import java . util . HashSet ; import java . util . Set ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; import net . sf . sv@@ editor . core . scan@@ utils . I@@ Text@@ Scanner ; public class SV@@ Ind@@ ent@@ Scanner implements IS@@ V@@ Ind@@ ent@@ Scanner { private I@@ Text@@ Scanner f@@ Scanner ; private int f@@ Un@@ getC@@ h ; private int f@@ Last@@ C@@ h [ ] = { - 1 , - 1 } ; private int f@@ Last@@ Ch@@ T = - 1 ; private int f@@ Lin@@ en@@ o ; private boolean f@@ Start@@ Line ; private String f@@ Le@@ ad@@ ing@@ WS ; private SV@@ Ind@@ ent@@ Token f@@ Curr@@ ent ; private static Set < String > f@@ Scope@@ Key@@ words ; private static Set < String > f@@ Quali@@ fiers ; private StringBuilder f@@ T@@ mp ; private static final boolean f@@ Debug@@ E@@ n = false ; private static Set < String > f@@ Oper@@ ators ; private Log@@ Handle f@@ Log ; private static final String f@@ Operator@@ List [ ] = { "@@ +" , "-" , "@@ !" , "@@ ~@@ " , "&@@ " , "@@ |" , "@@ ~@@ |" , "@@ ^@@ " , "@@ ~@@ ^@@ " , "@@ ^@@ ~@@ " , "@@ +" , "-" , "*" , "/" , "%" , "@@ =@@ =" , "@@ !@@ =" , "@@ =@@ =@@ =" , "@@ !@@ =@@ =" , "@@ =@@ =@@ ?" , "@@ !@@ =@@ ?" , "&@@ &@@ " , "@@ |@@ |" , "@@ *@@ *" , "<@@ " , "<@@ =" , ">" , "@@ >@@ =" , "&@@ " , "@@ |" , "@@ >@@ >" , "<@@ <@@ " , "@@ >@@ >@@ >" , "<@@ <@@ <@@ " , "@@ +@@ +" , "-@@ -" , "=" , "@@ +@@ =" , "-@@ =" , "@@ *@@ =" , "/@@ =" , "%@@ =" , "&@@ =" , "@@ |@@ =" , "@@ ^@@ =" , "<@@ <@@ =" , "@@ >@@ >@@ =" , "<@@ <@@ <@@ =" , "@@ >@@ >@@ >@@ =" , "@@ !" , "@@ ~@@ " , "&@@ " , "@@ ~@@ &@@ " , "@@ |" , "@@ ~@@ |" , "@@ ^@@ " , "@@ ~@@ ^@@ " , "@@ ^@@ ~@@ " , "@@ =@@ =" , "@@ !@@ =" , "&@@ &@@ " , "@@ |@@ |" , "&@@ " , "@@ |" , "@@ ^@@ " , "@@ ^@@ ~@@ " , "@@ ~@@ ^@@ " , ":" , ":@@ :" , "{@@ " , "}" , "#@@ " , "[" , "]" , "." , "," , "@@@ " , "@@ ?" , "$@@ " , "(" , ")" , "\\@@ " , "-@@ >" , "-@@ >@@ >" } ; static { f@@ Scope@@ Key@@ words = new HashSet < String > ( ) ; f@@ Scope@@ Key@@ words . add ( "@@ class@@ " ) ; f@@ Scope@@ Key@@ words . add ( "@@ function@@ " ) ; f@@ Scope@@ Key@@ words . add ( "@@ task@@ " ) ; f@@ Scope@@ Key@@ words . add ( "@@ cover@@ group@@ " ) ; f@@ Quali@@ fiers = new HashSet < String > ( ) ; f@@ Quali@@ fiers . add ( "@@ vi@@ r@@ tual@@ " ) ; f@@ Quali@@ fiers . add ( "@@ stati@@ c" ) ; f@@ Quali@@ fiers . add ( "@@ publi@@ c" ) ; f@@ Quali@@ fiers . add ( "@@ local@@ " ) ; f@@ Quali@@ fiers . add ( "@@ protec@@ ted@@ " ) ; f@@ Oper@@ ators = new HashSet < String > ( ) ; for ( String op : f@@ Operator@@ List ) { if ( ! f@@ Oper@@ ators . contains ( op ) ) { f@@ Oper@@ ators . add ( op ) ; } } } public SV@@ Ind@@ ent@@ Scanner ( I@@ Text@@ Scanner scanner ) { f@@ T@@ mp = new StringBuilder ( ) ; f@@ Scanner = scanner ; f@@ Un@@ getC@@ h = - 1 ; f@@ Last@@ C@@ h [ 0 ] = - 1 ; f@@ Last@@ C@@ h [ 1 ] = '\n' ; f@@ Lin@@ en@@ o = 1 ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; f@@ Start@@ Line = true ; } public SV@@ Ind@@ ent@@ Token next ( ) { boolean start@@ _@@ line ; int pos = 0 ; SV@@ Ind@@ ent@@ Token token = null ; start@@ _@@ line = f@@ Start@@ Line ; f@@ Start@@ Line = false ; if ( f@@ Le@@ ad@@ ing@@ WS == null ) { pos = ( int ) f@@ Scanner . get@@ Pos ( ) ; f@@ Le@@ ad@@ ing@@ WS = getIn@@ d@@ ent ( ) ; } int c = get_@@ ch ( ) ; int lin@@ en@@ o = f@@ Lin@@ en@@ o ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( char ) c + "\"" ) ; } if ( c == '\n' ) { token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Blan@@ k@@ Line , f@@ Le@@ ad@@ ing@@ WS ) ; f@@ Start@@ Line = true ; token . set@@ Is@@ End@@ Line ( true ) ; } else if ( c == '/' ) { int c2 = get_@@ ch ( ) ; if ( c2 == '/' ) { token = read@@ _@@ single@@ _@@ line@@ _@@ comment ( f@@ Le@@ ad@@ ing@@ WS ) ; token . set@@ Is@@ End@@ Line ( true ) ; } else if ( c2 == '@@ *@@ ' ) { token = read@@ _@@ multi@@ _@@ line@@ _@@ comment ( f@@ Le@@ ad@@ ing@@ WS ) ; } else { un@@ get_@@ ch ( c2 ) ; token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Operator , f@@ Le@@ ad@@ ing@@ WS , "/" ) ; } } else if ( c == '@@ "' ) { int last@@ _@@ c = - 1 ; f@@ T@@ mp . set@@ Length ( 0 ) ; f@@ T@@ mp . append ( ( char ) c ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && ( c != '@@ "' || last@@ _@@ c == '\@@ \@@ ' ) ) { f@@ T@@ mp . append ( ( char ) c ) ; last@@ _@@ c = c ; } f@@ T@@ mp . append ( ( char ) c ) ; token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . String , f@@ Le@@ ad@@ ing@@ WS , f@@ T@@ mp . toString ( ) ) ; } else if ( c == '@@ `@@ ' || c == '@@ $@@ ' || Character . is@@ Java@@ Identifier@@ Start ( c ) ) { boolean is_@@ m@@ ac@@ ro = ( c == '@@ `@@ ' ) ; int tmp@@ _@@ c = c ; if ( is_@@ m@@ ac@@ ro ) { c = get_@@ ch ( ) ; } String id = read@@ Identifier ( c ) ; if ( is_@@ m@@ ac@@ ro ) { id = ( char ) tmp@@ _@@ c + id ; } token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Identifier , f@@ Le@@ ad@@ ing@@ WS , id ) ; } else if ( c == '@@ ;@@ ' ) { token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Operator , f@@ Le@@ ad@@ ing@@ WS , ";" ) ; } else if ( Character . is@@ Digit ( c ) || c == '\@@ '@@ ' ) { f@@ T@@ mp . set@@ Length ( 0 ) ; if ( c == '\@@ '@@ ' ) { int c2 = get_@@ ch ( ) ; if ( ( c2 >= 'a' && c2 <= '@@ o@@ ' ) || ( c2 >= '@@ A@@ ' && c2 <= '@@ O@@ ' ) ) { f@@ T@@ mp . append ( ( char ) c ) ; f@@ T@@ mp . append ( ( char ) c2 ) ; } else { un@@ get_@@ ch ( c2 ) ; token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Operator , f@@ Le@@ ad@@ ing@@ WS , "'" ) ; } } else { f@@ T@@ mp . append ( ( char ) c ) ; } if ( token == null ) { while ( ( c = get_@@ ch ( ) ) != - 1 && ( c == '@@ _@@ ' || Character . is@@ Digit ( c ) || ( c >= 'a' && c <= '@@ f@@ ' ) || ( c >= '@@ A@@ ' && c <= '@@ F@@ ' ) ) ) { f@@ T@@ mp . append ( ( char ) c ) ; } un@@ get_@@ ch ( c ) ; token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Number , f@@ Le@@ ad@@ ing@@ WS , f@@ T@@ mp . toString ( ) ) ; } } else if ( c == - 1 ) { if ( f@@ Debug@@ E@@ n ) { debug ( "@@ End of input@@ " ) ; } token = null ; } else { f@@ T@@ mp . set@@ Length ( 0 ) ; f@@ T@@ mp . append ( ( char ) c ) ; while ( f@@ Oper@@ ators . contains ( f@@ T@@ mp . toString ( ) ) ) { if ( ( c = get_@@ ch ( ) ) == - 1 ) { break ; } f@@ T@@ mp . append ( ( char ) c ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" + f@@ T@@ mp . toString ( ) + "\"" ) ; } if ( ! f@@ Oper@@ ators . contains ( f@@ T@@ mp . toString ( ) ) ) { if ( f@@ T@@ mp . length ( ) > 1 ) { f@@ T@@ mp . set@@ Length ( f@@ T@@ mp . length ( ) - 1 ) ; un@@ get_@@ ch ( c ) ; } else { un@@ get_@@ ch ( c ) ; } } if ( f@@ Oper@@ ators . contains ( f@@ T@@ mp . toString ( ) ) ) { token = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Operator , f@@ Le@@ ad@@ ing@@ WS , f@@ T@@ mp . toString ( ) ) ; } else { token = null ; f@@ Log . error ( "" + ( char ) c + "\"" ) ; } } f@@ Le@@ ad@@ ing@@ WS = null ; if ( token != null ) { token . set@@ Lin@@ en@@ o ( lin@@ en@@ o ) ; token . set@@ Pos ( pos ) ; c = get_@@ ch ( ) ; if ( c == '\n' ) { token . set@@ Is@@ End@@ Line ( true ) ; f@@ Start@@ Line = true ; if ( token . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Blan@@ k@@ Line ) { un@@ get_@@ ch ( c ) ; } else { f@@ T@@ mp . set@@ Length ( 0 ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && Character . is@@ Whit@@ espace ( c ) && c != '\n' ) { f@@ T@@ mp . append ( ( char ) c ) ; } un@@ get_@@ ch ( c ) ; f@@ Le@@ ad@@ ing@@ WS = f@@ T@@ mp . toString ( ) ; } } else { if ( token . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Blan@@ k@@ Line ) { un@@ get_@@ ch ( c ) ; } else { f@@ T@@ mp . set@@ Length ( 0 ) ; un@@ get_@@ ch ( c ) ; pos = ( int ) f@@ Scanner . get@@ Pos ( ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && Character . is@@ Whit@@ espace ( c ) && c != '\n' ) { f@@ T@@ mp . append ( ( char ) c ) ; } if ( c == '\n' ) { token . set@@ Is@@ End@@ Line ( true ) ; token . set@@ Tr@@ ail@@ ing@@ WS ( f@@ T@@ mp . toString ( ) ) ; f@@ Start@@ Line = true ; } else { f@@ Le@@ ad@@ ing@@ WS = f@@ T@@ mp . toString ( ) ; un@@ get_@@ ch ( c ) ; } } } token . set@@ Is@@ Start@@ Line ( start@@ _@@ line ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "@@ token \"" + ( ( token . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Identifier || token . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Operator ) ? token . get@@ Image ( ) : token . getType ( ) ) + "\" - line " + token . get@@ Lin@@ en@@ o ( ) ) ; } } else { if ( f@@ Debug@@ E@@ n ) { debug ( "@@ null token@@ " ) ; } } f@@ Curr@@ ent = token ; return token ; } public SV@@ Ind@@ ent@@ Token current ( ) { return f@@ Curr@@ ent ; } private SV@@ Ind@@ ent@@ Token read@@ _@@ single@@ _@@ line@@ _@@ comment ( String le@@ ad@@ ing_@@ ws ) { int c ; f@@ T@@ mp . set@@ Length ( 0 ) ; f@@ T@@ mp . append ( "/@@ /" ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && c != '\n' ) { f@@ T@@ mp . append ( ( char ) c ) ; } un@@ get_@@ ch ( c ) ; return new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Single@@ Line@@ Comment , le@@ ad@@ ing_@@ ws , f@@ T@@ mp . toString ( ) ) ; } private SV@@ Multi@@ Line@@ Ind@@ ent@@ Token read@@ _@@ multi@@ _@@ line@@ _@@ comment ( String le@@ ad@@ ing_@@ ws ) { SV@@ Multi@@ Line@@ Ind@@ ent@@ Token ret = new SV@@ Multi@@ Line@@ Ind@@ ent@@ Token ( le@@ ad@@ ing_@@ ws ) ; int comment [ ] = { - 1 , - 1 } , c ; boolean read@@ _@@ new@@ line = false ; f@@ T@@ mp . set@@ Length ( 0 ) ; f@@ T@@ mp . append ( "/@@ *" ) ; while ( ( c = get_@@ ch ( ) ) != - 1 ) { if ( read@@ _@@ new@@ line ) { if ( Character . is@@ Whit@@ espace ( c ) && c != '\n' ) { f@@ T@@ mp . append ( ( char ) c ) ; } else { le@@ ad@@ ing_@@ ws = f@@ T@@ mp . toString ( ) ; f@@ T@@ mp . set@@ Length ( 0 ) ; read@@ _@@ new@@ line = false ; un@@ get_@@ ch ( c ) ; } } else { if ( c == '\n' ) { SV@@ Ind@@ ent@@ Token to@@ k = new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment , le@@ ad@@ ing_@@ ws , f@@ T@@ mp . toString ( ) ) ; to@@ k . set@@ Is@@ End@@ Line ( true ) ; read@@ _@@ new@@ line = true ; ret . add@@ Comment@@ Lines ( to@@ k ) ; f@@ T@@ mp . set@@ Length ( 0 ) ; le@@ ad@@ ing_@@ ws = "" ; } else { comment [ 0 ] = comment [ 1 ] ; comment [ 1 ] = c ; f@@ T@@ mp . append ( ( char ) c ) ; if ( comment [ 0 ] == '@@ *@@ ' && comment [ 1 ] == '/' ) { break ; } } } } if ( f@@ T@@ mp . length ( ) > 0 ) { ret . add@@ Comment@@ Lines ( new SV@@ Ind@@ ent@@ Token ( SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment , le@@ ad@@ ing_@@ ws , f@@ T@@ mp . toString ( ) ) ) ; } if ( c == - 1 ) { return null ; } else { return ret ; } } private String read@@ Identifier ( int c ) { f@@ T@@ mp . set@@ Length ( 0 ) ; f@@ T@@ mp . append ( ( char ) c ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && Character . is@@ Java@@ Identifier@@ Part ( c ) ) { f@@ T@@ mp . append ( ( char ) c ) ; } un@@ get_@@ ch ( c ) ; return f@@ T@@ mp . toString ( ) ; } private String getIn@@ d@@ ent ( ) { int c ; f@@ T@@ mp . set@@ Length ( 0 ) ; while ( ( c = get_@@ ch ( ) ) != - 1 && Character . is@@ Whit@@ espace ( c ) && c != '\n' ) { f@@ T@@ mp . append ( ( char ) c ) ; } if ( c != - 1 ) { un@@ get_@@ ch ( c ) ; } return f@@ T@@ mp . toString ( ) ; } private int get_@@ ch ( ) { int c = - 1 ; if ( f@@ Un@@ getC@@ h != - 1 ) { c = f@@ Un@@ getC@@ h ; f@@ Un@@ getC@@ h = - 1 ; } else { c = f@@ Scanner . get_@@ ch ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "c@@ =\"" + ( char ) c + "\"" ) ; } f@@ Last@@ C@@ h [ 0 ] = f@@ Last@@ C@@ h [ 1 ] ; f@@ Last@@ C@@ h [ 1 ] = c ; if ( f@@ Last@@ Ch@@ T == '\n' ) { f@@ Lin@@ en@@ o ++ ; } f@@ Last@@ Ch@@ T = c ; } return c ; } private void un@@ get_@@ ch ( int ch ) { f@@ Un@@ getC@@ h = ch ; } private void debug ( String msg ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( msg ) ; } } } </s>
<s> package net . sf . sv@@ editor . core . indent ; public interface IS@@ V@@ Ind@@ ent@@ Scanner { SV@@ Ind@@ ent@@ Token next ( ) ; SV@@ Ind@@ ent@@ Token current ( ) ; } </s>
<s> package net . sf . sv@@ editor . core . indent ; public class SV@@ Ind@@ ent@@ L@@ oop@@ Stmt { } </s>
<s> package net . sf . sv@@ editor . core . indent ; import java . util . ArrayList ; import java . util . List ; public class SV@@ Multi@@ Line@@ Ind@@ ent@@ Token extends SV@@ Ind@@ ent@@ Token { private List < SV@@ Ind@@ ent@@ Token > f@@ Comment@@ List ; public SV@@ Multi@@ Line@@ Ind@@ ent@@ Token ( String le@@ ad@@ ing_@@ ws ) { super ( SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment , le@@ ad@@ ing_@@ ws ) ; f@@ Comment@@ List = new ArrayList < SV@@ Ind@@ ent@@ Token > ( ) ; } public List < SV@@ Ind@@ ent@@ Token > get@@ Comment@@ Lines ( ) { return f@@ Comment@@ List ; } public void add@@ Comment@@ Lines ( SV@@ Ind@@ ent@@ Token to@@ k ) { f@@ Comment@@ List . add ( to@@ k ) ; } @ Override public String get@@ Image ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < f@@ Comment@@ List . size ( ) ; i ++ ) { SV@@ Ind@@ ent@@ Token line = f@@ Comment@@ List . get ( i ) ; if ( i != 0 ) { sb . append ( line . getLe@@ ad@@ ing@@ WS ( ) ) ; } sb . append ( line . get@@ Image ( ) ) ; if ( line . is@@ End@@ Line ( ) ) { sb . append ( "n" ) ; } } return sb . toString ( ) ; } @ Override public void set@@ Image ( String image ) { System . out . println ( "" ) ; } } </s>
<s> package net . sf . sv@@ editor . core . indent ; import java . io . ByteArrayOutputStream ; import java . io . PrintStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . Stack ; import java . util . regex . Pattern ; import net . sf . sv@@ editor . core . Tuple ; import net . sf . sv@@ editor . core . log . LogFactory ; import net . sf . sv@@ editor . core . log . Log@@ Handle ; public class SV@@ Default@@ Ind@@ enter@@ 2 implements IS@@ V@@ Ind@@ enter { private IS@@ V@@ Ind@@ ent@@ Scanner f@@ Scanner ; private Stack < Tuple < String , Boolean > > f@@ Ind@@ ent@@ Stack ; private List < SV@@ Ind@@ ent@@ Token > f@@ Token@@ List ; private SV@@ Ind@@ ent@@ Token f@@ Curr@@ ent ; private String f@@ Current@@ Ind@@ ent ; private Log@@ Handle f@@ Log ; private int f@@ Quali@@ fiers ; private static final boolean f@@ Debug@@ E@@ n = false ; private int f@@ N@@ Left@@ Par@@ en , f@@ N@@ Right@@ Par@@ en ; private String f@@ Ind@@ ent@@ In@@ cr = "t" ; private Pattern f@@ Tab@@ Repl@@ ace@@ Pattern ; private int f@@ Adap@@ tive@@ Ind@@ ent@@ End ; private boolean f@@ Test@@ Mode ; static private Map < String , Integer > f@@ Quali@@ fier@@ Map ; static private Set < String > f@@ Pre@@ Proc@@ Direc@@ tiv@@ es ; private class Ind@@ ent@@ EO@@ F@@ Exception extends RuntimeException { private static final long serialVersionUID = 1L ; } static { f@@ Quali@@ fier@@ Map = new HashMap < String , Integer > ( ) ; f@@ Quali@@ fier@@ Map . put ( "@@ stati@@ c" , 1 << 0 ) ; f@@ Quali@@ fier@@ Map . put ( "@@ vi@@ r@@ tual@@ " , 1 << 1 ) ; f@@ Quali@@ fier@@ Map . put ( "@@ local@@ " , 1 << 2 ) ; f@@ Quali@@ fier@@ Map . put ( "@@ protec@@ ted@@ " , 1 << 3 ) ; f@@ Quali@@ fier@@ Map . put ( "@@ publi@@ c" , 1 << 4 ) ; f@@ Quali@@ fier@@ Map . put ( "@@ ex@@ ter@@ n" , 1 << 5 ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es = new HashSet < String > ( ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ defin@@ e" ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ un@@ def@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ if@@ def@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ el@@ se@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ if@@ n@@ def@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ end@@ if@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ include@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "@@ `@@ tim@@ es@@ c@@ ale@@ " ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "" ) ; f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . add ( "" ) ; } public SV@@ Default@@ Ind@@ enter@@ 2 ( ) { f@@ Ind@@ ent@@ Stack = new Stack < Tuple < String , Boolean > > ( ) ; f@@ Token@@ List = new ArrayList < SV@@ Ind@@ ent@@ Token > ( ) ; f@@ Log = LogFactory . get@@ Log@@ Handle ( "" ) ; } public void set@@ Adap@@ tive@@ Ind@@ ent ( boolean adap@@ tive ) { } public void setIn@@ d@@ ent@@ In@@ cr ( String inc@@ r ) { f@@ Ind@@ ent@@ In@@ cr = inc@@ r ; if ( f@@ Ind@@ ent@@ In@@ cr . charAt ( 0 ) != '\@@ t' ) { f@@ Tab@@ Repl@@ ace@@ Pattern = Pattern . compile ( "t" ) ; } else { f@@ Tab@@ Repl@@ ace@@ Pattern = null ; } } public void set@@ Adap@@ tive@@ Ind@@ ent@@ End ( int lin@@ en@@ o ) { f@@ Adap@@ tive@@ Ind@@ ent@@ End = lin@@ en@@ o ; } public void setTest@@ Mode ( boolean tm ) { f@@ Test@@ Mode = tm ; } public void init ( IS@@ V@@ Ind@@ ent@@ Scanner scanner ) { f@@ Scanner = scanner ; push@@ _@@ ind@@ ent@@ _@@ stack ( "" , true ) ; } public String indent ( ) { return indent ( - 1 , - 1 ) ; } public String indent ( int start@@ _@@ line , int end@@ _@@ line ) { StringBuilder sb = new StringBuilder ( ) ; SV@@ Ind@@ ent@@ Token to@@ k ; f@@ N@@ Left@@ Par@@ en = f@@ N@@ Right@@ Par@@ en = 1 ; while ( ( to@@ k = next ( ) ) != null ) { try { do { if ( to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Identifier && f@@ Quali@@ fier@@ Map . containsKey ( to@@ k . get@@ Image ( ) ) ) { f@@ Quali@@ fiers |= f@@ Quali@@ fier@@ Map . get ( to@@ k . get@@ Image ( ) ) ; to@@ k = next ( ) ; } else if ( to@@ k . is@@ Id ( "@@ class@@ " ) || to@@ k . is@@ Id ( "@@ module@@ " ) || to@@ k . is@@ Id ( "@@ inter@@ face@@ " ) || to@@ k . is@@ Id ( "@@ program@@ " ) || to@@ k . is@@ Id ( "@@ package@@ " ) || to@@ k . is@@ Id ( "@@ sequence@@ " ) || to@@ k . is@@ Id ( "@@ property@@ " ) ) { to@@ k = ind@@ ent@@ _@@ if@@ c_@@ module@@ _@@ class ( to@@ k . get@@ Image ( ) ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ config@@ " ) ) { to@@ k = ind@@ ent@@ _@@ config ( to@@ k . get@@ Image ( ) ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ cover@@ group@@ " ) ) { to@@ k = ind@@ ent@@ _@@ cover@@ group ( ) ; } else if ( to@@ k . is@@ Id ( "@@ function@@ " ) || to@@ k . is@@ Id ( "@@ task@@ " ) ) { to@@ k = ind@@ ent@@ _@@ task@@ _@@ function ( to@@ k . get@@ Image ( ) ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ typed@@ ef@@ " ) ) { to@@ k = ind@@ ent@@ _@@ typed@@ e@@ f ( ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Op ( ";" ) ) { f@@ Quali@@ fiers = 0 ; to@@ k = next ( ) ; } else { to@@ k = next ( ) ; } } while ( ( to@@ k = current ( ) ) != null ) ; } catch ( Ind@@ ent@@ EO@@ F@@ Exception e ) { break ; } catch ( RuntimeException e ) { if ( f@@ Test@@ Mode ) { throw e ; } } } if ( f@@ Test@@ Mode ) { if ( f@@ Ind@@ ent@@ Stack . size ( ) != 1 ) { throw new RuntimeException ( "" + f@@ Ind@@ ent@@ Stack . size ( ) + "" ) ; } } if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; } for ( SV@@ Ind@@ ent@@ Token t : f@@ Token@@ List ) { if ( ( t . get@@ Lin@@ en@@ o ( ) >= start@@ _@@ line || start@@ _@@ line == - 1 ) && ( t . get@@ Lin@@ en@@ o ( ) <= end@@ _@@ line || end@@ _@@ line == - 1 ) ) { if ( f@@ Debug@@ E@@ n ) { debug ( "@@ to@@ k \"" + t . getType ( ) + "\" line@@ =" + t . get@@ Lin@@ en@@ o ( ) + " image@@ =" + t . get@@ Image ( ) ) ; } String le@@ ad@@ ing_@@ ws = t . getLe@@ ad@@ ing@@ WS ( ) ; if ( t . is@@ Start@@ Line ( ) && f@@ Tab@@ Repl@@ ace@@ Pattern != null ) { le@@ ad@@ ing_@@ ws = f@@ Tab@@ Repl@@ ace@@ Pattern . matcher ( le@@ ad@@ ing_@@ ws ) . replaceAll ( f@@ Ind@@ ent@@ In@@ cr ) ; } sb . append ( le@@ ad@@ ing_@@ ws + t . get@@ Image ( ) + t . get@@ Tr@@ ail@@ ing@@ WS ( ) + ( ( t . is@@ End@@ Line ( ) ) ? "n" : "" ) ) ; } } return sb . toString ( ) ; } public String getLine@@ Ind@@ ent ( int lin@@ en@@ o ) { String ret = null ; for ( SV@@ Ind@@ ent@@ Token t : f@@ Token@@ List ) { if ( t . get@@ Lin@@ en@@ o ( ) == lin@@ en@@ o ) { ret = t . getLe@@ ad@@ ing@@ WS ( ) ; if ( t . is@@ Start@@ Line ( ) && f@@ Tab@@ Repl@@ ace@@ Pattern != null ) { ret = f@@ Tab@@ Repl@@ ace@@ Pattern . matcher ( ret ) . replaceAll ( f@@ Ind@@ ent@@ In@@ cr ) ; } break ; } } return ret ; } public boolean is@@ Quali@@ fier@@ Set ( String key ) { return ( ( f@@ Quali@@ fier@@ Map . get ( key ) & f@@ Quali@@ fiers ) != 0 ) ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ if ( boolean is_@@ el@@ se@@ _@@ if ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + to@@ k . get@@ Image ( ) ) ; } start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Op ( "(" ) ) { to@@ k = consum@@ e_@@ expression ( ) ; } else { return to@@ k ; } to@@ k = ind@@ ent@@ _@@ if@@ _@@ st@@ m@@ ts ( null ) ; if ( to@@ k . is@@ Id ( "@@ el@@ se@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Id ( "@@ if@@ " ) ) { to@@ k = ind@@ ent@@ _@@ if ( true ) ; } else { start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = ind@@ ent@@ _@@ if@@ _@@ st@@ m@@ ts ( null ) ; } } if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ if@@ _@@ st@@ m@@ ts ( String parent ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; if ( to@@ k . is@@ Id ( "@@ begin@@ " ) ) { parent = "@@ begin@@ " ; boolean begin@@ _@@ is_@@ start@@ _@@ line = to@@ k . is@@ Start@@ Line ( ) ; if ( begin@@ _@@ is_@@ start@@ _@@ line ) { enter@@ _@@ scope ( to@@ k ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; } to@@ k = next@@ _@@ s ( ) ; if ( ! begin@@ _@@ is_@@ start@@ _@@ line ) { enter@@ _@@ scope ( to@@ k ) ; } else { enter@@ _@@ scope ( to@@ k ) ; } while ( to@@ k != null ) { if ( f@@ Debug@@ E@@ n ) { debug ( "" + to@@ k . getType ( ) + " " + to@@ k . get@@ Image ( ) ) ; } if ( to@@ k . is@@ Id ( "@@ end@@ " ) ) { le@@ ave@@ _@@ scope ( to@@ k ) ; if ( begin@@ _@@ is_@@ start@@ _@@ line ) { le@@ ave@@ _@@ scope ( ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } to@@ k = next@@ _@@ s ( ) ; if ( begin@@ _@@ is_@@ start@@ _@@ line ) { set_@@ indent ( to@@ k , false ) ; } to@@ k = consum@@ e_@@ lab@@ ele@@ d_@@ block ( to@@ k ) ; break ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( parent , true ) ; } } } else { enter@@ _@@ scope ( to@@ k ) ; to@@ k = ind@@ ent@@ _@@ stmt ( parent ) ; le@@ ave@@ _@@ scope ( to@@ k ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ for@@ k ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( to@@ k != null && ! to@@ k . is@@ Id ( "@@ join@@ " ) && ! to@@ k . is@@ Id ( "@@ jo@@ in_@@ n@@ one" ) && ! to@@ k . is@@ Id ( "@@ jo@@ in_@@ an@@ y" ) ) { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( "@@ for@@ k" , true ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ loop@@ _@@ stmt ( ) { SV@@ Ind@@ ent@@ Token to@@ k , first ; to@@ k = first = current ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + to@@ k . get@@ Image ( ) ) ; } if ( ! to@@ k . is@@ Id ( "@@ do@@ " ) && ! to@@ k . is@@ Id ( "@@ fore@@ ver@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Op ( "(" ) ) { to@@ k = consum@@ e_@@ expression ( ) ; } else { return to@@ k ; } } else { to@@ k = next@@ _@@ s ( ) ; } to@@ k = ind@@ ent@@ _@@ if@@ _@@ st@@ m@@ ts ( null ) ; if ( first . is@@ Id ( "@@ do@@ " ) ) { while ( ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ typed@@ e@@ f ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; boolean enum@@ _@@ struct = false ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; } to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Id ( "@@ enum@@ " ) || to@@ k . is@@ Id ( "@@ struc@@ t" ) || to@@ k . is@@ Id ( "un@@ ion@@ " ) ) { to@@ k = ind@@ ent@@ _@@ struc@@ t_@@ un@@ ion@@ _@@ enum ( "@@ typed@@ ef@@ " ) ; enum@@ _@@ struct = true ; } while ( ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; } if ( ! enum@@ _@@ struct ) { le@@ ave@@ _@@ scope ( to@@ k ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ struc@@ t_@@ un@@ ion@@ _@@ enum ( String parent ) { SV@@ Ind@@ ent@@ Token to@@ k = next@@ _@@ s ( ) ; if ( ! parent . equals ( "@@ typed@@ ef@@ " ) ) { start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; } while ( ! to@@ k . is@@ Op ( "{@@ " , ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } if ( to@@ k . is@@ Op ( "{@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; if ( ! to@@ k . is@@ Op ( "}" ) ) { enter@@ _@@ scope ( to@@ k ) ; } while ( ! to@@ k . is@@ Op ( "}" ) ) { to@@ k = next@@ _@@ s ( ) ; } } le@@ ave@@ _@@ scope ( to@@ k ) ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ if@@ c_@@ module@@ _@@ class ( String item ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; String end = get_@@ end@@ _@@ k@@ w ( item ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + ")" ) ; } start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; while ( ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; f@@ Quali@@ fiers = 0 ; while ( to@@ k != null ) { if ( to@@ k . is@@ Id ( end ) ) { break ; } else if ( to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Identifier && f@@ Quali@@ fier@@ Map . containsKey ( to@@ k . get@@ Image ( ) ) ) { f@@ Quali@@ fiers |= f@@ Quali@@ fier@@ Map . get ( to@@ k . get@@ Image ( ) ) ; to@@ k = next@@ _@@ s ( ) ; } else if ( to@@ k . is@@ Id ( "@@ function@@ " ) || to@@ k . is@@ Id ( "@@ task@@ " ) ) { to@@ k = ind@@ ent@@ _@@ task@@ _@@ function ( to@@ k . get@@ Image ( ) ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ class@@ " ) || to@@ k . is@@ Id ( "@@ module@@ " ) || to@@ k . is@@ Id ( "@@ inter@@ face@@ " ) || to@@ k . is@@ Id ( "@@ property@@ " ) || to@@ k . is@@ Id ( "@@ sequence@@ " ) ) { to@@ k = ind@@ ent@@ _@@ if@@ c_@@ module@@ _@@ class ( to@@ k . get@@ Image ( ) ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ struc@@ t" ) || to@@ k . is@@ Id ( "un@@ ion@@ " ) || to@@ k . is@@ Id ( "@@ enum@@ " ) ) { to@@ k = ind@@ ent@@ _@@ struc@@ t_@@ un@@ ion@@ _@@ enum ( "" ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ initial@@ " ) || is_@@ al@@ way@@ s ( to@@ k ) || to@@ k . is@@ Id ( "@@ final@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Op ( "@@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; to@@ k = consum@@ e_@@ expression ( ) ; } if ( current ( ) . get@@ Image ( ) . equals ( "@@ begin@@ " ) ) { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( null , false ) ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( null , false ) ; } f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ cover@@ group@@ " ) ) { to@@ k = ind@@ ent@@ _@@ cover@@ group ( ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Id ( "@@ constra@@ int@@ " ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int ( ) ; f@@ Quali@@ fiers = 0 ; } else if ( to@@ k . is@@ Pre@@ Pro@@ c ( ) && to@@ k . is@@ Start@@ Line ( ) ) { while ( ! to@@ k . is@@ End@@ Line ( ) && ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; f@@ Quali@@ fiers = 0 ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( item , true ) ; } } le@@ ave@@ _@@ scope ( to@@ k ) ; end@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = consum@@ e_@@ lab@@ ele@@ d_@@ block ( next@@ _@@ s ( ) ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + "@@ ) next@@ =" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ config ( String item ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; String end = "@@ end@@ config@@ " ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + ")" ) ; } start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; while ( ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; f@@ Quali@@ fiers = 0 ; while ( to@@ k != null ) { if ( to@@ k . is@@ Id ( end ) ) { break ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( item , true ) ; } } le@@ ave@@ _@@ scope ( to@@ k ) ; end@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = consum@@ e_@@ lab@@ ele@@ d_@@ block ( next@@ _@@ s ( ) ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + "@@ ) next@@ =" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private static boolean is_@@ al@@ way@@ s ( SV@@ Ind@@ ent@@ Token to@@ k ) { return ( to@@ k . is@@ Id ( "@@ al@@ way@@ s" ) || to@@ k . is@@ Id ( "@@ al@@ way@@ s_@@ co@@ mb@@ " ) || to@@ k . is@@ Id ( "@@ al@@ way@@ s_@@ l@@ atch@@ " ) || to@@ k . is@@ Id ( "@@ al@@ way@@ s_@@ ff@@ " ) ) ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ cover@@ group ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; } start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; while ( to@@ k != null && ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } le@@ ave@@ _@@ scope ( ) ; to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( to@@ k != null ) { if ( to@@ k . is@@ Id ( "@@ end@@ group@@ " ) ) { le@@ ave@@ _@@ scope ( to@@ k ) ; break ; } else { to@@ k = ind@@ ent@@ _@@ cover@@ group@@ _@@ item ( ) ; } } to@@ k = next@@ _@@ s ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ constra@@ int ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; to@@ k = next@@ _@@ s ( ) ; if ( ! to@@ k . is@@ Op ( "{@@ " ) ) { return to@@ k ; } to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( ! to@@ k . is@@ Op ( "}" ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ stmt ( ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ cover@@ group@@ _@@ item ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; to@@ k = next@@ _@@ s ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; enter@@ _@@ scope ( to@@ k ) ; while ( ! to@@ k . is@@ Op ( ";" ) && ! to@@ k . is@@ Op ( "{@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; if ( to@@ k . is@@ Op ( "{@@ " ) ) { boolean do@@ _@@ indent = true ; int l@@ b_@@ count = 1 , r@@ b_@@ count = 0 ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; do { to@@ k = next@@ _@@ s ( ) ; if ( do@@ _@@ indent ) { enter@@ _@@ scope ( to@@ k ) ; do@@ _@@ indent = false ; } if ( to@@ k . is@@ Op ( "{@@ " ) ) { l@@ b_@@ count ++ ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; do@@ _@@ indent = true ; } else if ( to@@ k . is@@ Op ( "}" ) ) { r@@ b_@@ count ++ ; le@@ ave@@ _@@ scope ( to@@ k ) ; } } while ( l@@ b_@@ count != r@@ b_@@ count ) ; } to@@ k = next@@ _@@ s ( ) ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ task@@ _@@ function ( String item ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; String end = get_@@ end@@ _@@ k@@ w ( item ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + ")" ) ; } while ( to@@ k != null && ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } if ( ! is@@ Quali@@ fier@@ Set ( "@@ ex@@ ter@@ n" ) ) { enter@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; while ( to@@ k != null ) { if ( to@@ k . is@@ Id ( end ) ) { break ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( item , true ) ; } } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = consum@@ e_@@ lab@@ ele@@ d_@@ block ( next@@ _@@ s ( ) ) ; } else { le@@ ave@@ _@@ scope ( ) ; to@@ k = next@@ _@@ s ( ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" + item + "@@ ) " + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } end@@ _@@ o@@ f_@@ scope ( ) ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( String parent , boolean parent@@ _@@ is_@@ block ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + parent@@ _@@ is_@@ block + " to@@ k@@ =" + to@@ k . get@@ Image ( ) ) ; } if ( to@@ k . is@@ Id ( "@@ begin@@ " ) ) { parent = "@@ begin@@ " ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( to@@ k != null ) { if ( f@@ Debug@@ E@@ n ) { debug ( "" + to@@ k . getType ( ) + " " + to@@ k . get@@ Image ( ) ) ; } if ( to@@ k . is@@ Id ( "@@ end@@ " ) ) { le@@ ave@@ _@@ scope ( to@@ k ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } to@@ k = next@@ _@@ s ( ) ; to@@ k = consum@@ e_@@ lab@@ ele@@ d_@@ block ( to@@ k ) ; break ; } else { to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( parent , true ) ; } } } else { if ( ! parent@@ _@@ is_@@ block ) { start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; enter@@ _@@ scope ( to@@ k ) ; } to@@ k = ind@@ ent@@ _@@ stmt ( parent ) ; if ( ! parent@@ _@@ is_@@ block ) { le@@ ave@@ _@@ scope ( to@@ k ) ; } } if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) + " parent@@ =" + parent ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ stmt ( String parent ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + parent + " to@@ k@@ =" + to@@ k . get@@ Image ( ) ) ; } if ( to@@ k . is@@ Id ( "@@ if@@ " ) ) { to@@ k = ind@@ ent@@ _@@ if ( false ) ; } else if ( to@@ k . is@@ Id ( "@@ for@@ k" ) ) { to@@ k = ind@@ ent@@ _@@ for@@ k ( ) ; } else if ( to@@ k . is@@ Id ( "c@@ ase@@ " ) || to@@ k . is@@ Id ( "@@ rand@@ case@@ " ) ) { to@@ k = ind@@ ent@@ _@@ case ( ) ; } else if ( is_@@ al@@ way@@ s ( to@@ k ) || to@@ k . is@@ Id ( "@@ initial@@ " ) || to@@ k . is@@ Id ( "@@ final@@ " ) ) { enter@@ _@@ scope ( to@@ k ) ; if ( ( to@@ k = next@@ _@@ s ( ) ) . is@@ Op ( "@@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; to@@ k = next@@ _@@ s ( ) ; ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( null , false ) ; } le@@ ave@@ _@@ scope ( ) ; } else if ( to@@ k . is@@ Id ( "@@ typed@@ ef@@ " ) ) { to@@ k = ind@@ ent@@ _@@ typed@@ e@@ f ( ) ; } else if ( to@@ k . is@@ Id ( "@@ whi@@ le@@ " ) || to@@ k . is@@ Id ( "@@ do@@ " ) || to@@ k . is@@ Id ( "@@ repeat@@ " ) || to@@ k . is@@ Id ( "@@ fore@@ ver@@ " ) || to@@ k . is@@ Id ( "@@ for@@ " ) || to@@ k . is@@ Id ( "@@ fore@@ ach@@ " ) ) { to@@ k = ind@@ ent@@ _@@ loop@@ _@@ stmt ( ) ; } else { boolean do@@ _@@ next = true ; while ( ! to@@ k . is@@ Op ( ";" ) ) { if ( parent != null ) { if ( ( parent . equals ( "@@ begin@@ " ) && to@@ k . is@@ Id ( "@@ end@@ " ) ) || to@@ k . is@@ Id ( "@@ end@@ " + parent ) ) { do@@ _@@ next = false ; break ; } else if ( parent . equals ( "@@ for@@ k" ) && ( to@@ k . is@@ Id ( "@@ join@@ " ) || to@@ k . is@@ Id ( "@@ jo@@ in_@@ an@@ y" ) || to@@ k . is@@ Id ( "@@ jo@@ in_@@ n@@ one" ) ) ) { do@@ _@@ next = false ; break ; } } if ( to@@ k . is@@ Op ( "(" ) ) { start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; } else if ( to@@ k . is@@ Op ( ")" ) ) { le@@ ave@@ _@@ scope ( ) ; } to@@ k = next@@ _@@ s ( ) ; } if ( do@@ _@@ next ) { to@@ k = next@@ _@@ s ( ) ; } } if ( f@@ Debug@@ E@@ n ) { debug ( "" + parent + " to@@ k@@ =" + to@@ k . get@@ Image ( ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ constra@@ int@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; if ( to@@ k . is@@ Op ( "{@@ " ) ) { start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( ! to@@ k . is@@ Op ( "}" ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; } else { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ stmt ( ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ constra@@ int@@ _@@ if@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; if ( to@@ k . is@@ Op ( "{@@ " ) ) { boolean begin@@ _@@ is_@@ start@@ _@@ line = to@@ k . is@@ Start@@ Line ( ) ; if ( begin@@ _@@ is_@@ start@@ _@@ line ) { enter@@ _@@ scope ( to@@ k ) ; } to@@ k = next@@ _@@ s ( ) ; if ( ! begin@@ _@@ is_@@ start@@ _@@ line ) { enter@@ _@@ scope ( to@@ k ) ; } while ( ! to@@ k . is@@ Op ( "}" ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) ; } le@@ ave@@ _@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; } else { enter@@ _@@ scope ( to@@ k ) ; to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ stmt ( ) ; le@@ ave@@ _@@ scope ( to@@ k ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ constra@@ int@@ _@@ stmt ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current_@@ s ( ) ; if ( to@@ k . is@@ Id ( "@@ if@@ " ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ if ( false ) ; } else if ( to@@ k . is@@ Op ( "(" ) ) { to@@ k = consum@@ e_@@ expression ( ) ; if ( to@@ k . is@@ Op ( "-@@ >" ) || to@@ k . is@@ Op ( "-@@ >@@ >" ) ) { to@@ k = next@@ _@@ s ( ) ; to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) ; } } else { while ( ! to@@ k . is@@ Op ( ";" ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ constra@@ int@@ _@@ if ( boolean is_@@ el@@ se@@ _@@ if ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + to@@ k . get@@ Image ( ) ) ; } start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Op ( "(" ) ) { to@@ k = consum@@ e_@@ expression ( ) ; } else { return to@@ k ; } enter@@ _@@ scope ( to@@ k ) ; to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ if@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) ; if ( to@@ k . is@@ Id ( "@@ el@@ se@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; if ( to@@ k . is@@ Id ( "@@ if@@ " ) ) { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ if ( true ) ; } else { to@@ k = ind@@ ent@@ _@@ constra@@ int@@ _@@ block@@ _@@ or@@ _@@ stmt ( ) ; } } if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token ind@@ ent@@ _@@ case ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; String type = to@@ k . get@@ Image ( ) ; enter@@ _@@ scope ( to@@ k ) ; start@@ _@@ o@@ f_@@ scope ( to@@ k ) ; if ( type . equals ( "c@@ ase@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; } to@@ k = next@@ _@@ s ( ) ; enter@@ _@@ scope ( to@@ k ) ; while ( ! to@@ k . is@@ Id ( "@@ end@@ case@@ " ) ) { while ( ! to@@ k . is@@ Op ( ":" ) && ! to@@ k . is@@ Id ( "@@ end@@ case@@ " ) ) { to@@ k = next@@ _@@ s ( ) ; } if ( to@@ k . is@@ Op ( ":" ) ) { to@@ k = next@@ _@@ s ( ) ; to@@ k = ind@@ ent@@ _@@ block@@ _@@ or@@ _@@ statement ( "c@@ ase@@ " , false ) ; } } le@@ ave@@ _@@ scope ( ) ; if ( to@@ k . is@@ Id ( "@@ end@@ case@@ " ) ) { set_@@ indent ( to@@ k , false ) ; } to@@ k = next@@ _@@ s ( ) ; return to@@ k ; } private void start@@ _@@ o@@ f_@@ scope ( SV@@ Ind@@ ent@@ Token to@@ k ) { inc@@ r_@@ indent ( true ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } } private void end@@ _@@ o@@ f_@@ scope ( ) { end@@ _@@ o@@ f_@@ scope ( null ) ; } private void end@@ _@@ o@@ f_@@ scope ( SV@@ Ind@@ ent@@ Token to@@ k ) { } private void enter@@ _@@ scope ( SV@@ Ind@@ ent@@ Token to@@ k ) { set_@@ indent ( to@@ k , false ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } } private void le@@ ave@@ _@@ scope ( ) { le@@ ave@@ _@@ scope ( null ) ; } private void le@@ ave@@ _@@ scope ( SV@@ Ind@@ ent@@ Token to@@ k ) { po@@ p_@@ indent ( to@@ k ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } } private void push@@ _@@ ind@@ ent@@ _@@ stack ( String indent , boolean pro@@ visi@@ on@@ al ) { if ( f@@ Debug@@ E@@ n ) { debug ( "[" + ( f@@ Ind@@ ent@@ Stack . size ( ) + 1 ) + "" + indent + "" + pro@@ visi@@ on@@ al ) ; } f@@ Ind@@ ent@@ Stack . push ( new Tuple < String , Boolean > ( indent , pro@@ visi@@ on@@ al ) ) ; } private String pe@@ ek@@ _@@ indent ( ) { return f@@ Ind@@ ent@@ Stack . peek ( ) . first ( ) ; } private void inc@@ r_@@ indent ( boolean pro@@ visi@@ on@@ al ) { push@@ _@@ ind@@ ent@@ _@@ stack ( f@@ Ind@@ ent@@ Stack . peek ( ) . first ( ) + f@@ Ind@@ ent@@ In@@ cr , pro@@ visi@@ on@@ al ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + pro@@ visi@@ on@@ al + "@@ ) - " + "@@ ind@@ ent@@ =\"" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } } private void po@@ p_@@ indent ( SV@@ Ind@@ ent@@ Token to@@ k ) { if ( f@@ Debug@@ E@@ n ) { String img = ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "" ; debug ( "[" + ( f@@ Ind@@ ent@@ Stack . size ( ) - 1 ) + "" + img + ")" ) ; } if ( f@@ Ind@@ ent@@ Stack . size ( ) > 1 ) { f@@ Ind@@ ent@@ Stack . pop ( ) ; } else { if ( f@@ Test@@ Mode ) { throw new RuntimeException ( "" ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; ByteArrayOutputStream bo@@ s = new ByteArrayOutputStream ( ) ; PrintStream ps = new PrintStream ( bo@@ s ) ; try { throw new Exception ( ) ; } catch ( Exception e ) { e . printStackTrace ( ps ) ; } ps . flush ( ) ; debug ( bo@@ s . toString ( ) ) ; } } if ( to@@ k != null ) { set_@@ indent ( to@@ k , false ) ; } if ( f@@ Debug@@ E@@ n ) { debug ( "" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; } } private void set_@@ indent ( SV@@ Ind@@ ent@@ Token to@@ k , boolean imp@@ lic@@ it ) { if ( to@@ k . is@@ Start@@ Line ( ) ) { if ( is@@ Adap@@ tive@@ Train@@ ing ( to@@ k ) && f@@ Ind@@ ent@@ Stack . peek ( ) . second ( ) && ! to@@ k . is@@ Blan@@ k@@ Line ( ) && ! to@@ k . is@@ Comment ( ) ) { if ( f@@ Debug@@ E@@ n ) { debug ( "" + f@@ Ind@@ ent@@ Stack . peek ( ) . first ( ) + "\" to \"" + f@@ Current@@ Ind@@ ent + "\" to@@ k@@ =\"" + to@@ k . get@@ Image ( ) + "\"" ) ; } f@@ Ind@@ ent@@ Stack . peek ( ) . set@@ First ( f@@ Current@@ Ind@@ ent ) ; } debug ( "" + imp@@ lic@@ it + " \"" + to@@ k . get@@ Image ( ) + "\" \"" + pe@@ ek@@ _@@ indent ( ) + "\"" ) ; to@@ k . set@@ Le@@ ad@@ ing@@ WS ( pe@@ ek@@ _@@ indent ( ) ) ; } } private void ind@@ ent@@ _@@ multi@@ _@@ line@@ _@@ comment ( SV@@ Ind@@ ent@@ Token to@@ k ) { SV@@ Multi@@ Line@@ Ind@@ ent@@ Token ml_@@ comment = ( SV@@ Multi@@ Line@@ Ind@@ ent@@ Token ) to@@ k ; if ( to@@ k . is@@ Start@@ Line ( ) ) { set_@@ indent ( to@@ k , false ) ; for ( SV@@ Ind@@ ent@@ Token line : ml_@@ comment . get@@ Comment@@ Lines ( ) ) { if ( line . get@@ Image ( ) . startsWith ( "*" ) ) { line . set@@ Le@@ ad@@ ing@@ WS ( pe@@ ek@@ _@@ indent ( ) + " " ) ; } } } else { if ( f@@ Debug@@ E@@ n ) { debug ( "" ) ; } } } private SV@@ Ind@@ ent@@ Token consum@@ e_@@ lab@@ ele@@ d_@@ block ( SV@@ Ind@@ ent@@ Token to@@ k ) { if ( to@@ k . is@@ Op ( ":" ) ) { to@@ k = next@@ _@@ s ( ) ; to@@ k = next@@ _@@ s ( ) ; } return to@@ k ; } private SV@@ Ind@@ ent@@ Token consum@@ e_@@ expression ( ) { SV@@ Ind@@ ent@@ Token to@@ k = current ( ) ; int n@@ _@@ l@@ br@@ ace = 0 , n@@ _r@@ br@@ ace = 0 ; do { if ( to@@ k . is@@ Op ( "(" ) ) { n@@ _@@ l@@ br@@ ace ++ ; } else if ( to@@ k . is@@ Op ( ")" ) ) { n@@ _r@@ br@@ ace ++ ; } to@@ k = next@@ _@@ s ( ) ; } while ( n@@ _@@ l@@ br@@ ace != n@@ _r@@ br@@ ace ) ; return to@@ k ; } private boolean is@@ Adap@@ tive@@ Train@@ ing ( SV@@ Ind@@ ent@@ Token to@@ k ) { return ( f@@ Adap@@ tive@@ Ind@@ ent@@ End != - 1 && to@@ k . get@@ Lin@@ en@@ o ( ) <= f@@ Adap@@ tive@@ Ind@@ ent@@ End ) ; } private SV@@ Ind@@ ent@@ Token next ( ) { SV@@ Ind@@ ent@@ Token to@@ k = null ; while ( ( to@@ k = f@@ Scanner . next ( ) ) != null && ( to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Blan@@ k@@ Line || to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment || to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Single@@ Line@@ Comment || ( to@@ k . is@@ Pre@@ Pro@@ c ( ) && f@@ Pre@@ Proc@@ Direc@@ tiv@@ es . contains ( to@@ k . get@@ Image ( ) ) ) ) ) { if ( to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Single@@ Line@@ Comment ) { set_@@ indent ( to@@ k , true ) ; f@@ Token@@ List . add ( to@@ k ) ; } else if ( to@@ k . getType ( ) == SV@@ Ind@@ ent@@ TokenType . Multi@@ Line@@ Comment ) { ind@@ ent@@ _@@ multi@@ _@@ line@@ _@@ comment ( to@@ k ) ; f@@ Token@@ List . add ( to@@ k ) ; } else if ( to@@ k . is@@ Pre@@ Pro@@ c ( ) && ! to@@ k . get@@ Image ( ) . equals ( "@@ `@@ include@@ " ) ) { Stack < Tuple < String , Boolean > > stack = f@@ Ind@@ ent@@ Stack ; f@@ Ind@@ ent@@ Stack = new Stack < Tuple < String , Boolean > > ( ) ; push@@ _@@ ind@@ ent@@ _@@ stack ( "" , false ) ; set_@@ indent ( to@@ k , true ) ; while ( to@@ k != null && ! to@@ k . is@@ End@@ Line ( ) ) { f@@ Token@@ List . add ( to@@ k ) ; to@@ k = f@@ Scanner . next ( ) ; if ( f@@ Debug@@ E@@ n ) { debug ( "" + ( ( to@@ k != null ) ? to@@ k . get@@ Image ( ) : "null" ) ) ; } } if ( to@@ k != null ) { f@@ Token@@ List . add ( to@@ k ) ; } f@@ Ind@@ ent@@ Stack = stack ; } else { f@@ Token@@ List . add ( to@@ k ) ; } } if ( to@@ k != null ) { if ( to@@ k . is@@ Op ( "(" ) ) { if ( f@@ N@@ Left@@ Par@@ en == f@@ N@@ Right@@ Par@@ en ) { } f@@ N@@ Left@@ Par@@ en ++ ; } else if ( to@@ k . is@@ Op ( ")" ) ) { f@@ N@@ Right@@ Par@@ en ++ ; if ( f@@ N@@ Left@@ Par@@ en == f@@ N@@ Right@@ Par@@ en ) { f@@ N@@ Left@@ Par@@ en = f@@ N@@ Right@@ Par@@ en = 0 ; } } if ( to@@ k . is@@ Start@@ Line ( ) ) { f@@ Current@@ Ind@@ ent = to@@ k . getLe@@ ad@@ ing@@ WS ( ) ; set_@@ indent ( to@@ k , true ) ; } f@@ Token@@ List . add ( to@@ k ) ; } f@@ Curr@@ ent = to@@ k ; return to@@ k ; } private SV@@ Ind@@ ent@@ Token current ( ) { return f@@ Curr@@ ent ; } private SV@@ Ind@@ ent@@ Token current_@@ s ( ) { if ( current ( ) == null ) { throw new RuntimeException ( ) ; } return current ( ) ; } private SV@@ Ind@@ ent@@ Token next@@ _@@ s ( ) { SV@@ Ind@@ ent@@ Token ret = next ( ) ; if ( f@@ Debug@@ E@@ n ) { if ( ret != null ) { debug ( "@@ next@@ _@@ s@@ : " + ret . get@@ Image ( ) ) ; } else { debug ( "@@ next@@ _@@ s@@ : null@@ " ) ; } } if ( ret == null ) { throw new Ind@@ ent@@ EO@@ F@@ Exception ( ) ; } return ret ; } private static String get_@@ end@@ _@@ k@@ w ( String k@@ w ) { if ( k@@ w . equals ( "@@ cover@@ group@@ " ) ) { return "@@ end@@ group@@ " ; } else { return "@@ end@@ " + k@@ w ; } } private void debug ( String msg ) { if ( f@@ Debug@@ E@@ n ) { f@@ Log . debug ( msg ) ; } } } </s>
<s> package net . sf . sv@@ editor . core . indent ; import java . util . ArrayList ; import java . util . List ; public class SV@@ Ind@@ ent@@ Expr@@ Token extends SV@@ Ind@@ ent@@ Token { protected List < SV@@ Ind@@ ent@@ Token > f@@ Expr@@ Elem@@ s ; public SV@@ Ind@@ ent@@ Expr@@ Token ( String le@@ ad@@ ing_@@ ws ) { super ( SV@@ Ind@@ ent@@ TokenType . Expression , le@@ ad@@ ing_@@ ws ) ; f@@ Expr@@ Elem@@ s = new ArrayList < SV@@ Ind@@ ent@@ Token > ( ) ; } public List < SV@@ Ind@@ ent@@ Token > get@@ Expr@@ Elem@@ s ( ) { return f@@ Expr@@ Elem@@ s ; } public void add@@ Expr@@ E@@ le@@ m ( SV@@ Ind@@ ent@@ Token elem ) { f@@ Expr@@ Elem@@ s . add ( elem ) ; } @ Override public String get@@ Image ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < f@@ Expr@@ Elem@@ s . size ( ) ; i ++ ) { SV@@ Ind@@ ent@@ Token to@@ k = f@@ Expr@@ Elem@@ s . get ( i ) ; if ( i > 0 ) { sb . append ( to@@ k . getLe@@ ad@@ ing@@ WS ( ) ) ; } sb . append ( to@@ k . get@@ Image ( ) ) ; } return sb . toString ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . indent ; public interface IS@@ V@@ Ind@@ enter { void setIn@@ d@@ ent@@ In@@ cr ( String inc@@ r ) ; void init ( IS@@ V@@ Ind@@ ent@@ Scanner scanner ) ; String indent ( ) ; String indent ( int start , int end ) ; String getLine@@ Ind@@ ent ( int lin@@ en@@ o ) ; void set@@ Adap@@ tive@@ Ind@@ ent ( boolean en ) ; void set@@ Adap@@ tive@@ Ind@@ ent@@ End ( int lin@@ en@@ o ) ; void setTest@@ Mode ( boolean tm ) ; } </s>
<s> package net . sf . sv@@ editor . core . indent ; public enum SV@@ Ind@@ ent@@ St@@ mt@@ Type { Block , L@@ oop , If , Case } </s>
<s> package net . sf . sv@@ editor . core . indent ; public enum SV@@ Ind@@ ent@@ TokenType { Identifier , Operator , Expression , Multi@@ Line@@ Comment , Single@@ Line@@ Comment , Number , Blan@@ k@@ Line , String } </s>
<s> package net . sf . sv@@ editor . core . log ; import java . lang . ref . W@@ eak@@ Reference ; import java . util . ArrayList ; import java . util . List ; public class Log@@ Category { private String f@@ Category ; private int f@@ Log@@ Level ; private List < W@@ eak@@ Reference < I@@ Log@@ Handle > > f@@ Log@@ Hand@@ les ; public Log@@ Category ( String category , int level ) { f@@ Category = category ; f@@ Log@@ Level = level ; f@@ Log@@ Hand@@ les = new ArrayList < W@@ eak@@ Reference < I@@ Log@@ Handle > > ( ) ; } public String getC@@ ateg@@ ory ( ) { return f@@ Category ; } public void set@@ Log@@ Level ( int level ) { f@@ Log@@ Level = level ; for ( int i = 0 ; i < f@@ Log@@ Hand@@ les . size ( ) ; i ++ ) { W@@ eak@@ Reference < I@@ Log@@ Handle > lr = f@@ Log@@ Hand@@ les . get ( i ) ; if ( lr . get ( ) == null ) { f@@ Log@@ Hand@@ les . remove ( i ) ; i -- ; } else { lr . get ( ) . set@@ Debug@@ Level ( level ) ; } } } public int get@@ Log@@ Level ( ) { return f@@ Log@@ Level ; } public void add@@ Log@@ Handle ( I@@ Log@@ Handle handle ) { handle . set@@ Debug@@ Level ( f@@ Log@@ Level ) ; f@@ Log@@ Hand@@ les . add ( new W@@ eak@@ Reference < I@@ Log@@ Handle > ( handle ) ) ; } public void remove@@ Log@@ Handle ( I@@ Log@@ Handle handle ) { f@@ Log@@ Hand@@ les . remove ( handle ) ; } } </s>
<s> package net . sf . sv@@ editor . core . log ; public interface I@@ Log@@ Listener { int Type@@ _@@ Info = 1 ; int Type@@ _@@ Debug = 2 ; int Type@@ _@@ Error = 4 ; void message ( I@@ Log@@ Handle handle , int type , int level , String message ) ; } </s>
<s> package net . sf . sv@@ editor . core . log ; import java . lang . ref . W@@ eak@@ Reference ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; public class LogFactory implements I@@ Log@@ Listener { private static LogFactory f@@ Default ; private Map < String , Log@@ Handle > f@@ Log@@ Handle@@ Map ; private int f@@ Log@@ Level = 0 ; private Map < String , Log@@ Category > f@@ Log@@ Handle@@ Category@@ Map ; private List < W@@ eak@@ Reference < I@@ Log@@ Listener > > f@@ Log@@ Listeners ; public LogFactory ( ) { f@@ Log@@ Handle@@ Map = new HashMap < String , Log@@ Handle > ( ) ; f@@ Log@@ Handle@@ Category@@ Map = new HashMap < String , Log@@ Category > ( ) ; f@@ Log@@ Listeners = new ArrayList < W@@ eak@@ Reference < I@@ Log@@ Listener > > ( ) ; } public synchronized static LogFactory getDefault ( ) { if ( f@@ Default == null ) { f@@ Default = new LogFactory ( ) ; } return f@@ Default ; } public static synchronized Log@@ Handle get@@ Log@@ Handle ( String name ) { return get@@ Log@@ Handle ( name , I@@ Log@@ Handle . LOG_@@ C@@ AT_@@ DEFAULT ) ; } public void set@@ Log@@ Level ( String category , int level ) { if ( category == null ) { f@@ Log@@ Level = level ; for ( Entry < String , Log@@ Category > e : f@@ Log@@ Handle@@ Category@@ Map . entrySet ( ) ) { e . getValue ( ) . set@@ Log@@ Level ( level ) ; } } else { Log@@ Category cat ; if ( f@@ Log@@ Handle@@ Category@@ Map . containsKey ( category ) ) { cat = new Log@@ Category ( category , level ) ; f@@ Log@@ Handle@@ Category@@ Map . put ( category , cat ) ; } else { cat = f@@ Log@@ Handle@@ Category@@ Map . get ( category ) ; } cat . set@@ Log@@ Level ( level ) ; } } public static synchronized Log@@ Handle get@@ Log@@ Handle ( String name , String category ) { LogFactory f = getDefault ( ) ; boolean create@@ d = false ; Log@@ Handle handle = null ; synchronized ( f . f@@ Log@@ Handle@@ Map ) { if ( ! f . f@@ Log@@ Handle@@ Map . containsKey ( name ) ) { handle = new Log@@ Handle ( name , category ) ; handle . init ( f ) ; f . f@@ Log@@ Handle@@ Map . put ( name , handle ) ; create@@ d = true ; } else { handle = f . f@@ Log@@ Handle@@ Map . get ( name ) ; } } if ( create@@ d ) { synchronized ( f . f@@ Log@@ Handle@@ Category@@ Map ) { Log@@ Category cat ; if ( ! f . f@@ Log@@ Handle@@ Category@@ Map . containsKey ( handle . getC@@ ateg@@ ory ( ) ) ) { cat = new Log@@ Category ( handle . getC@@ ateg@@ ory ( ) , f . f@@ Log@@ Level ) ; f . f@@ Log@@ Handle@@ Category@@ Map . put ( handle . getC@@ ateg@@ ory ( ) , cat ) ; } else { cat = f . f@@ Log@@ Handle@@ Category@@ Map . get ( handle . getC@@ ateg@@ ory ( ) ) ; } cat . add@@ Log@@ Handle ( handle ) ; } } return handle ; } public static void remove@@ Log@@ Handle ( Log@@ Handle log ) { LogFactory f = getDefault ( ) ; synchronized ( f . f@@ Log@@ Handle@@ Map ) { f . f@@ Log@@ Handle@@ Map . remove ( log . getName ( ) ) ; } synchronized ( f . f@@ Log@@ Handle@@ Category@@ Map ) { f . f@@ Log@@ Handle@@ Category@@ Map . get ( log . getC@@ ateg@@ ory ( ) ) . remove@@ Log@@ Handle ( log ) ; } } public void add@@ Log@@ Listener ( I@@ Log@@ Listener l ) { synchronized ( f@@ Log@@ Listeners ) { f@@ Log@@ Listeners . add ( new W@@ eak@@ Reference < I@@ Log@@ Listener > ( l ) ) ; } } public void remove@@ Log@@ Listener ( I@@ Log@@ Listener l ) { synchronized ( f@@ Log@@ Listeners ) { for ( int i = 0 ; i < f@@ Log@@ Listeners . size ( ) ; i ++ ) { if ( f@@ Log@@ Listeners . get ( i ) . get ( ) == l ) { f@@ Log@@ Listeners . remove ( i ) ; } } } } public void message ( I@@ Log@@ Handle handle , int type , int level , String message ) { synchronized ( f@@ Log@@ Listeners ) { for ( int i = 0 ; i < f@@ Log@@ Listeners . size ( ) ; i ++ ) { W@@ eak@@ Reference < I@@ Log@@ Listener > lr = f@@ Log@@ Listeners . get ( i ) ; if ( lr . get ( ) == null ) { f@@ Log@@ Listeners . remove ( i ) ; i -- ; } else { lr . get ( ) . message ( handle , type , level , message ) ; } } } } } </s>
<s> package net . sf . sv@@ editor . core . log ; public interface I@@ Log@@ Handle extends I@@ Log@@ Level { String LOG_@@ C@@ AT_@@ DEFAULT = "@@ DEFAUL@@ T" ; String LOG_@@ C@@ AT_@@ PAR@@ SE@@ R = "@@ Parser@@ " ; String getName ( ) ; void init ( I@@ Log@@ Listener parent ) ; void print ( int type , int level , String msg ) ; void println ( int type , int level , String msg ) ; boolean isEnabled ( ) ; int get@@ Debug@@ Level ( ) ; void set@@ Debug@@ Level ( int level ) ; void add@@ Log@@ Level@@ Listener ( I@@ Log@@ Level@@ Listener l ) ; } </s>
<s> package net . sf . sv@@ editor . core . log ; import java . lang . ref . W@@ eak@@ Reference ; import java . util . ArrayList ; import java . util . List ; public class Log@@ Handle implements I@@ Log@@ Handle { private String f@@ Name ; private String f@@ Category ; private I@@ Log@@ Listener f@@ Listener ; private int f@@ Debug@@ Level = 1 ; private int f@@ Ind@@ ent ; private List < W@@ eak@@ Reference < I@@ Log@@ Level@@ Listener > > f@@ Log@@ Level@@ Listeners ; public Log@@ Handle ( String name ) { this ( name , LOG_@@ C@@ AT_@@ DEFAULT ) ; } public Log@@ Handle ( String name , String category ) { f@@ Name = name ; f@@ Category = category ; f@@ Log@@ Level@@ Listeners = new ArrayList < W@@ eak@@ Reference < I@@ Log@@ Level@@ Listener > > ( ) ; } public void init ( I@@ Log@@ Listener parent ) { f@@ Listener = parent ; } public String getName ( ) { return f@@ Name ; } public String getC@@ ateg@@ ory ( ) { return f@@ Category ; } public void add@@ Log@@ Level@@ Listener ( I@@ Log@@ Level@@ Listener l ) { f@@ Log@@ Level@@ Listeners . add ( new W@@ eak@@ Reference < I@@ Log@@ Level@@ Listener > ( l ) ) ; } public void set@@ Debug@@ Level ( int level ) { if ( f@@ Debug@@ Level != level ) { f@@ Debug@@ Level = level ; for ( int i = 0 ; i < f@@ Log@@ Level@@ Listeners . size ( ) ; i ++ ) { W@@ eak@@ Reference < I@@ Log@@ Level@@ Listener > l = f@@ Log@@ Level@@ Listeners . get ( i ) ; if ( l == null || l . get ( ) == null ) { f@@ Log@@ Level@@ Listeners . remove ( i ) ; i -- ; } else { l . get ( ) . log@@ Level@@ Changed ( this ) ; } } } f@@ Debug@@ Level = level ; } public int get@@ Debug@@ Level ( ) { return f@@ Debug@@ Level ; } public boolean isEnabled ( ) { return ( f@@ Debug@@ Level > 0 ) ; } public boolean isEnabled ( int level ) { return ( f@@ Debug@@ Level > level ) ; } public void print ( int type , int level , String msg ) { } public void println ( int type , int level , String msg ) { f@@ Listener . message ( this , type , level , msg ) ; } public void not@@ e ( String msg ) { println ( I@@ Log@@ Listener . Type@@ _@@ Info , 0 , msg ) ; } public void debug ( String msg ) { println ( I@@ Log@@ Listener . Type@@ _@@ Debug , 3 , ( f@@ Ind@@ ent > 0 ) ? ( indent ( f@@ Ind@@ ent ) + msg ) : msg ) ; } public void debug ( String msg , Exception e ) { int level = I@@ Log@@ Listener . Type@@ _@@ Error + I@@ Log@@ Listener . Type@@ _@@ Debug ; println ( level , 3 , msg ) ; println ( level , 3 , e . getMessage ( ) ) ; for ( Stack@@ Trace@@ Element s_@@ e : e . get@@ StackTrace ( ) ) { String m = " at " + s_@@ e . getClass@@ Name ( ) + "." + s_@@ e . get@@ MethodName ( ) + "(" + s_@@ e . get@@ FileName ( ) + ":" + s_@@ e . getLine@@ Number ( ) + ")" ; println ( level , 3 , m ) ; } } public void debug ( int level , String msg ) { println ( I@@ Log@@ Listener . Type@@ _@@ Debug , level , ( f@@ Ind@@ ent > 0 ) ? ( indent ( f@@ Ind@@ ent ) + msg ) : msg ) ; } public void debug ( int level , String msg , Exception e ) { int type = I@@ Log@@ Listener . Type@@ _@@ Error + I@@ Log@@ Listener . Type@@ _@@ Debug ; println ( type , level , msg ) ; println ( type , level , e . getMessage ( ) ) ; for ( Stack@@ Trace@@ Element s_@@ e : e . get@@ StackTrace ( ) ) { String m = " at " + s_@@ e . getClass@@ Name ( ) + "." + s_@@ e . get@@ MethodName ( ) + "(" + s_@@ e . get@@ FileName ( ) + ":" + s_@@ e . getLine@@ Number ( ) + ")" ; println ( type , level , m ) ; } } public void enter ( String msg ) { debug ( msg ) ; f@@ Ind@@ ent ++ ; } public void le@@ ave ( String msg ) { if ( f@@ Ind@@ ent > 0 ) { f@@ Ind@@ ent -- ; } debug ( msg ) ; } public void error ( String msg ) { println ( I@@ Log@@ Listener . Type@@ _@@ Error , f@@ Debug@@ Level , msg ) ; } public void error ( String msg , Exception e ) { println ( I@@ Log@@ Listener . Type@@ _@@ Error , f@@ Debug@@ Level , msg ) ; println ( I@@ Log@@ Listener . Type@@ _@@ Error , f@@ Debug@@ Level , e . getMessage ( ) ) ; for ( Stack@@ Trace@@ Element s_@@ e : e . get@@ StackTrace ( ) ) { println ( I@@ Log@@ Listener . Type@@ _@@ Error , f@@ Debug@@ Level , " at " + s_@@ e . getClass@@ Name ( ) + "." + s_@@ e . get@@ MethodName ( ) + "(" + s_@@ e . get@@ FileName ( ) + ":" + s_@@ e . getLine@@ Number ( ) + ")" ) ; } } private String indent ( int ind ) { String ret = "" ; while ( ind -- > 0 ) { ret += " " ; } return ret ; } } </s>
<s> package net . sf . sv@@ editor . core . log ; public interface I@@ Log@@ Level@@ Listener extends I@@ Log@@ Level { void log@@ Level@@ Changed ( I@@ Log@@ Handle handle ) ; } </s>
<s> package net . sf . sv@@ editor . core . log ; public interface I@@ Log@@ Level { int LE@@ VE@@ L_@@ O@@ FF = 0 ; int LE@@ VE@@ L_@@ MI@@ N = 1 ; int LE@@ VE@@ L_@@ M@@ ID = 2 ; int LE@@ VE@@ L_@@ MA@@ X = 3 ; } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; import org . eclipse . core . runtime . Null@@ ProgressMonitor ; public class Job@@ M@@ gr@@ Worker@@ Thread extends Thread { public enum Thread@@ State { Wait@@ ing , Work@@ ing } ; private Thread@@ State f@@ State ; private int f@@ Id@@ le@@ Timeout = 1000 ; private Job@@ Mgr f@@ Job@@ Mgr ; public Job@@ M@@ gr@@ Worker@@ Thread ( Job@@ Mgr m@@ gr ) { super ( "" ) ; f@@ Job@@ Mgr = m@@ gr ; } public synchronized Thread@@ State get@@ Thread@@ State ( ) { return f@@ State ; } @ Override public void run ( ) { while ( true ) { I@@ Job job = f@@ Job@@ Mgr . de@@ queue@@ Job ( f@@ Id@@ le@@ Timeout ) ; if ( job != null ) { try { job . run ( new Null@@ ProgressMonitor ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } f@@ Job@@ Mgr . job@@ En@@ ded ( job ) ; } else { if ( f@@ Job@@ Mgr . try@@ To@@ Ex@@ it ( this ) ) { break ; } } } } } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; public interface I@@ Job@@ Mgr { I@@ Job create@@ Job ( ) ; void queue@@ Job ( I@@ Job job ) ; void add@@ Job@@ Listener ( I@@ Job@@ Listener l ) ; void remove@@ Job@@ Listener ( I@@ Job@@ Listener l ) ; void dispose ( ) ; } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; public interface I@@ Job@@ Listener { void job@@ Started ( I@@ Job job ) ; void job@@ En@@ ded ( I@@ Job job ) ; } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public interface I@@ Job { void init ( String name , Runnable runn@@ able ) ; String getName ( ) ; void set@@ Priority ( int p ) ; int getPri@@ ority ( ) ; void run ( I@@ ProgressMonitor monitor ) ; void addListener ( I@@ Job@@ Listener l ) ; void remove@@ Listener ( I@@ Job@@ Listener l ) ; void clear@@ Listeners ( ) ; void join ( ) ; boolean join ( int wait@@ _@@ ms ) ; } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; import java . util . ArrayList ; import java . util . List ; import net . sf . sv@@ editor . core . job@@ _@@ m@@ gr . Job@@ M@@ gr@@ Worker@@ Thread . Thread@@ State ; public class Job@@ Mgr implements I@@ Job@@ Mgr { private List < I@@ Job@@ Listener > f@@ Job@@ Listeners ; private List < Job@@ M@@ gr@@ Worker@@ Thread > f@@ Thread@@ Pool ; private List < I@@ Job > f@@ Job@@ Queue ; private int f@@ Max@@ Threads ; private boolean f@@ Dis@@ po@@ sed ; public Job@@ Mgr ( ) { f@@ Job@@ Listeners = new ArrayList < I@@ Job@@ Listener > ( ) ; f@@ Thread@@ Pool = new ArrayList < Job@@ M@@ gr@@ Worker@@ Thread > ( ) ; f@@ Job@@ Queue = new ArrayList < I@@ Job > ( ) ; f@@ Max@@ Threads = 4 ; } public void dispose ( ) { f@@ Dis@@ po@@ sed = true ; synchronized ( f@@ Thread@@ Pool ) { while ( f@@ Thread@@ Pool . size ( ) > 0 ) { try { f@@ Thread@@ Pool . wait ( ) ; } catch ( InterruptedException e ) { break ; } } } } public void add@@ Job@@ Listener ( I@@ Job@@ Listener l ) { synchronized ( f@@ Job@@ Listeners ) { f@@ Job@@ Listeners . add ( l ) ; } } public void remove@@ Job@@ Listener ( I@@ Job@@ Listener l ) { synchronized ( f@@ Job@@ Listeners ) { f@@ Job@@ Listeners . remove ( l ) ; } } public I@@ Job create@@ Job ( ) { return new Job@@ M@@ gr@@ Job ( ) ; } public void queue@@ Job ( I@@ Job job ) { check@@ Worker@@ Threads ( ) ; synchronized ( f@@ Job@@ Queue ) { if ( f@@ Job@@ Queue . size ( ) == 0 || f@@ Job@@ Queue . get ( f@@ Job@@ Queue . size ( ) - 1 ) . getPri@@ ority ( ) <= job . getPri@@ ority ( ) ) { f@@ Job@@ Queue . add ( job ) ; } else { boolean ad@@ ded = false ; for ( int i = 0 ; i < f@@ Job@@ Queue . size ( ) ; i ++ ) { if ( f@@ Job@@ Queue . get ( i ) . getPri@@ ority ( ) > job . getPri@@ ority ( ) ) { f@@ Job@@ Queue . add ( i , job ) ; ad@@ ded = true ; break ; } } if ( ! ad@@ ded ) { f@@ Job@@ Queue . add ( job ) ; } } f@@ Job@@ Queue . notify@@ All ( ) ; } } private void check@@ Worker@@ Threads ( ) { synchronized ( f@@ Thread@@ Pool ) { boolean all@@ _@@ bu@@ s@@ y = true ; for ( Job@@ M@@ gr@@ Worker@@ Thread t : f@@ Thread@@ Pool ) { if ( t . get@@ Thread@@ State ( ) == Thread@@ State . Wait@@ ing ) { all@@ _@@ bu@@ s@@ y = false ; } } if ( all@@ _@@ bu@@ s@@ y && f@@ Thread@@ Pool . size ( ) < f@@ Max@@ Threads ) { Job@@ M@@ gr@@ Worker@@ Thread t = new Job@@ M@@ gr@@ Worker@@ Thread ( this ) ; f@@ Thread@@ Pool . add ( t ) ; t . start ( ) ; } } } public I@@ Job de@@ queue@@ Job ( int id@@ le@@ _@@ timeout ) { I@@ Job job = null ; for ( int i = 0 ; i < 2 ; i ++ ) { synchronized ( f@@ Job@@ Queue ) { if ( f@@ Job@@ Queue . size ( ) > 0 ) { job = f@@ Job@@ Queue . remove ( 0 ) ; break ; } else if ( i == 0 ) { try { f@@ Job@@ Queue . wait ( id@@ le@@ _@@ timeout ) ; } catch ( InterruptedException e ) { } } } } if ( job != null ) { job@@ Started ( job ) ; } return job ; } private void job@@ Started ( I@@ Job job ) { synchronized ( f@@ Job@@ Listeners ) { for ( I@@ Job@@ Listener l : f@@ Job@@ Listeners ) { l . job@@ Started ( job ) ; } } } void job@@ En@@ ded ( I@@ Job job ) { synchronized ( f@@ Job@@ Listeners ) { for ( I@@ Job@@ Listener l : f@@ Job@@ Listeners ) { l . job@@ En@@ ded ( job ) ; } } } public boolean try@@ To@@ Ex@@ it ( Job@@ M@@ gr@@ Worker@@ Thread t ) { boolean can@@ _@@ exit = true ; synchronized ( f@@ Thread@@ Pool ) { can@@ _@@ exit = ( f@@ Thread@@ Pool . size ( ) > 1 || f@@ Dis@@ po@@ sed ) ; if ( can@@ _@@ exit ) { f@@ Thread@@ Pool . remove ( t ) ; f@@ Thread@@ Pool . notify@@ All ( ) ; } } return can@@ _@@ exit ; } } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . I@@ ProgressMonitor ; public class Job@@ M@@ gr@@ Job implements I@@ Job { private List < I@@ Job@@ Listener > f@@ Job@@ Listeners ; private String f@@ Name ; private Runnable f@@ Runnable ; private Object f@@ Job@@ D@@ one@@ M@@ ute@@ x ; private boolean f@@ Job@@ Done ; private int f@@ Priority = 5 ; public Job@@ M@@ gr@@ Job ( ) { f@@ Job@@ Listeners = new ArrayList < I@@ Job@@ Listener > ( ) ; f@@ Job@@ D@@ one@@ M@@ ute@@ x = new Object ( ) ; } public void init ( String name , Runnable runn@@ able ) { f@@ Name = name ; f@@ Runnable = runn@@ able ; f@@ Job@@ Done = false ; } public String getName ( ) { return f@@ Name ; } public void set@@ Priority ( int p ) { f@@ Priority = p ; } public int getPri@@ ority ( ) { return f@@ Priority ; } public void run ( I@@ ProgressMonitor monitor ) { try { job@@ Started ( ) ; f@@ Runnable . run ( ) ; } finally { job@@ En@@ ded ( ) ; } } private void job@@ Started ( ) { synchronized ( f@@ Job@@ D@@ one@@ M@@ ute@@ x ) { f@@ Job@@ Done = false ; } synchronized ( f@@ Job@@ Listeners ) { for ( I@@ Job@@ Listener l : f@@ Job@@ Listeners ) { l . job@@ Started ( this ) ; } } } private void job@@ En@@ ded ( ) { synchronized ( f@@ Job@@ D@@ one@@ M@@ ute@@ x ) { f@@ Job@@ Done = true ; f@@ Job@@ D@@ one@@ M@@ ute@@ x . notify@@ All ( ) ; } synchronized ( f@@ Job@@ Listeners ) { for ( I@@ Job@@ Listener l : f@@ Job@@ Listeners ) { l . job@@ En@@ ded ( this ) ; } } } public void addListener ( I@@ Job@@ Listener l ) { synchronized ( f@@ Job@@ Listeners ) { f@@ Job@@ Listeners . add ( l ) ; } } public void remove@@ Listener ( I@@ Job@@ Listener l ) { synchronized ( f@@ Job@@ Listeners ) { f@@ Job@@ Listeners . remove ( l ) ; } } public void clear@@ Listeners ( ) { synchronized ( f@@ Job@@ Listeners ) { f@@ Job@@ Listeners . clear ( ) ; } } public void join ( ) { synchronized ( f@@ Job@@ D@@ one@@ M@@ ute@@ x ) { while ( ! f@@ Job@@ Done ) { try { f@@ Job@@ D@@ one@@ M@@ ute@@ x . wait ( ) ; } catch ( InterruptedException e ) { break ; } } } } public boolean join ( int wait@@ _@@ ms ) { boolean job@@ _d@@ one = false ; synchronized ( f@@ Job@@ D@@ one@@ M@@ ute@@ x ) { if ( ! f@@ Job@@ Done ) { try { f@@ Job@@ D@@ one@@ M@@ ute@@ x . wait ( wait@@ _@@ ms ) ; } catch ( InterruptedException e ) { } } job@@ _d@@ one = f@@ Job@@ Done ; } return job@@ _d@@ one ; } } </s>
<s> package net . sf . sv@@ editor . core . job@@ _@@ m@@ gr ; public class SV@@ Job@@ Exception extends Exception { private static final long serialVersionUID = 1L ; public SV@@ Job@@ Exception ( String msg ) { super ( msg ) ; } } </s>
<s> package net . sf . sv@@ editor . core . dir@@ tree ; import java . util . ArrayList ; import java . util . List ; public class SV@@ DB@@ Dir@@ TreeNode { private String f@@ Name ; private boolean f@@ Is@@ Dir ; private SV@@ DB@@ Dir@@ TreeNode f@@ Parent ; private List < SV@@ DB@@ Dir@@ TreeNode > f@@ Children ; public SV@@ DB@@ Dir@@ TreeNode ( SV@@ DB@@ Dir@@ TreeNode parent , String name , boolean is_@@ dir ) { f@@ Parent = parent ; f@@ Name = name ; f@@ Is@@ Dir = is_@@ dir ; f@@ Children = new ArrayList < SV@@ DB@@ Dir@@ TreeNode > ( ) ; } public void addChild ( SV@@ DB@@ Dir@@ TreeNode node ) { f@@ Children . add ( node ) ; } public List < SV@@ DB@@ Dir@@ TreeNode > getChildren ( ) { return f@@ Children ; } public boolean is@@ Dir ( ) { return f@@ Is@@ Dir ; } public String getName ( ) { return f@@ Name ; } public SV@@ DB@@ Dir@@ TreeNode getParent ( ) { return f@@ Parent ; } public SV@@ DB@@ Dir@@ TreeNode find@@ Child ( String name ) { for ( SV@@ DB@@ Dir@@ TreeNode n : f@@ Children ) { if ( n . getName ( ) . equals ( name ) ) { return n ; } } return null ; } @ Override public int hashCode ( ) { return f@@ Name . hashCode ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . dir@@ tree ; import net . sf . sv@@ editor . core . SV@@ FileUtils ; public class SV@@ DB@@ Dir@@ Tree@@ Factory { private SV@@ DB@@ Dir@@ TreeNode f@@ Root ; public SV@@ DB@@ Dir@@ Tree@@ Factory ( ) { f@@ Root = new SV@@ DB@@ Dir@@ TreeNode ( null , "" , true ) ; } public void add@@ Path ( String path , boolean is_@@ dir ) { path = SV@@ FileUtils . normali@@ ze ( path ) ; String path@@ _@@ s [ ] = path . split ( "/" ) ; add@@ Path ( f@@ Root , path@@ _@@ s , 0 , is_@@ dir ) ; } private void add@@ Path ( SV@@ DB@@ Dir@@ TreeNode parent , String path@@ _@@ s [ ] , int path@@ _@@ idx , boolean is_@@ dir ) { String elem = path@@ _@@ s [ path@@ _@@ idx ] ; SV@@ DB@@ Dir@@ TreeNode child ; if ( ( child = parent . find@@ Child ( elem ) ) == null ) { child = new SV@@ DB@@ Dir@@ TreeNode ( parent , elem , ( is_@@ dir || path@@ _@@ idx + 1 != path@@ _@@ s . length ) ) ; parent . addChild ( child ) ; } if ( path@@ _@@ idx + 1 < path@@ _@@ s . length ) { add@@ Path ( child , path@@ _@@ s , path@@ _@@ idx + 1 , is_@@ dir ) ; } } public SV@@ DB@@ Dir@@ TreeNode build@@ Tree ( ) { return f@@ Root ; } } </s>
<s> package net . sf . sv@@ editor . core ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . security . Message@@ Digest ; import java . util . regex . Pattern ; import org . eclipse . core . resources . I@@ Container ; import org . eclipse . core . resources . I@@ File ; import org . eclipse . core . resources . I@@ Project ; import org . eclipse . core . resources . I@@ Resource ; import org . eclipse . core . resources . I@@ Work@@ space@@ Root ; import org . eclipse . core . resources . Resources@@ Plugin ; import org . eclipse . core . runtime . Path ; public class SV@@ FileUtils { private static Pattern f@@ W@@ in@@ Path@@ Pattern ; public static boolean f@@ I@@ sW@@ in@@ P@@ latform ; static { f@@ W@@ in@@ Path@@ Pattern = Pattern . compile ( "\@@ \\@@ \@@ " ) ; } public static String getPath@@ Parent ( String path ) { String parent = new File ( path ) . getParent ( ) ; if ( parent == null ) { parent = path ; } return f@@ W@@ in@@ Path@@ Pattern . matcher ( parent ) . replaceAll ( "/" ) ; } public static String getPath@@ Lea@@ f ( String path ) { String le@@ af = new File ( path ) . getName ( ) ; return le@@ af ; } public static String normali@@ ze ( String path ) { if ( path . indexOf ( '\@@ \@@ ' ) != - 1 ) { path = f@@ W@@ in@@ Path@@ Pattern . matcher ( path ) . replaceAll ( "/" ) ; if ( path . length ( ) >= 3 && path . charAt ( 0 ) == '/' && Character . is@@ L@@ et@@ ter ( path . charAt ( 1 ) ) && path . charAt ( 2 ) == ':' ) { path = path . substring ( 1 ) ; } } return path ; } public static I@@ Container get@@ Work@@ space@@ Folder ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ Resource r = null ; I@@ Project p = null ; path = normali@@ ze ( path ) ; try { if ( ( r = root . get@@ Folder ( new Path ( path ) ) ) != null && r . exists ( ) ) { return ( I@@ Container ) r ; } } catch ( IllegalArgumentException e ) { } String p@@ name = path ; if ( p@@ name . startsWith ( "/" ) ) { p@@ name = p@@ name . substring ( 1 ) ; } if ( p@@ name . endsWith ( "/" ) ) { p@@ name = p@@ name . substring ( 0 , p@@ name . length ( ) - 1 ) ; } for ( I@@ Project p_@@ t : root . get@@ Projec@@ ts ( ) ) { if ( p_@@ t . getName ( ) . equals ( p@@ name ) ) { p = p_@@ t ; break ; } } return p ; } public static I@@ File get@@ Work@@ space@@ File ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ File f = null ; path = normali@@ ze ( path ) ; f = root . getFile ( new Path ( path ) ) ; if ( ! f . exists ( ) ) { f = null ; } return f ; } public static I@@ File find@@ Work@@ space@@ File ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ File f = root . getFile@@ For@@ Location ( new Path ( path ) ) ; return f ; } public static I@@ Container find@@ Work@@ space@@ Folder ( String path ) { I@@ Work@@ space@@ Root root = Resources@@ Plugin . get@@ Workspace ( ) . getRoot ( ) ; I@@ Container c = root . get@@ Container@@ For@@ Location ( new Path ( path ) ) ; return c ; } private static String convertTo@@ Hex ( byte [ ] data ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < data . length ; i ++ ) { int h@@ alf@@ byte = ( data [ i ] >>> 4 ) & 0x0@@ F ; int tw@@ o@@ _h@@ al@@ fs = 0 ; do { if ( ( 0 <= h@@ alf@@ byte ) && ( h@@ alf@@ byte <= 9 ) ) buf . append ( ( char ) ( '0' + h@@ alf@@ byte ) ) ; else buf . append ( ( char ) ( 'a' + ( h@@ alf@@ byte - 10 ) ) ) ; h@@ alf@@ byte = data [ i ] & 0x0@@ F ; } while ( tw@@ o@@ _h@@ al@@ fs ++ < 1 ) ; } return buf . toString ( ) ; } public static String compute@@ MD@@ 5 ( String text ) { try { Message@@ Digest md ; md = Message@@ Digest . getInstance ( "M@@ D@@ 5" ) ; byte [ ] md@@ 5@@ hash = new byte [ 32 ] ; md . update ( text . getBytes ( "@@ is@@ o@@ -@@ 88@@ 59@@ -@@ 1" ) , 0 , text . length ( ) ) ; md@@ 5@@ hash = md . digest ( ) ; return convertTo@@ Hex ( md@@ 5@@ hash ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return "@@ UN@@ SUP@@ POR@@ TE@@ D" ; } public static void write@@ To@@ File ( File file , String content ) { try { PrintWriter out = new PrintWriter ( new FileWriter ( file . toString ( ) ) ) ; out . print ( content ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void delete ( File file ) { if ( ! file . exists ( ) ) { return ; } if ( file . isDirectory ( ) ) { for ( File f : file . list@@ Files ( ) ) { delete ( f ) ; } } file . delete ( ) ; } } </s>
<s> package net . sf . sv@@ editor . core . db ; public class SV@@ DB@@ Gener@@ ate@@ Block extends SV@@ DB@@ Scope@@ Item { public SV@@ DB@@ Gener@@ ate@@ Block ( ) { super ( "" , SV@@ DB@@ Item@@ Type . Gener@@ ate@@ Block ) ; } public SV@@ DB@@ Gener@@ ate@@ Block ( String name ) { super ( name , SV@@ DB@@ Item@@ Type . Gener@@ ate@@ Block ) ; } } </s>